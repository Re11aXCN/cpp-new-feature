# 一、关键字

# (1) [`restrict`](https://cppreference.cn/w/c/language/restrict)

**在 ISO C++ 标准中，** `restrict` 是一个源自 C 语言（从 C99 标准开始）的关键字。

然而，主流的 C++ 编译器都提供了功能等价的、非标准的扩展来满足这一需求。因此，这个问题通常是在“如何使用 C++ 实现 C 中 `restrict` 的效果”的语境下被讨论的。

---

## 1. `restrict` 的核心思想与作用

`restrict` 是一个指针限定符（type qualifier）。它向编译器做出一个**承诺**：在该指针的生命周期内，**只有它本身（或者直接由它衍生的指针，如 `p+1`）是用于访问其所指向内存区域的唯一方式**。

换句话说，它告诉编译器：“我指向的这块内存，不会有其他任何指针来‘捣乱’（进行读写操作）。你可以放心地针对这一点进行激进的优化。”

**主要作用：解决指针别名问题，启用编译器优化。**

*   **指针别名**：指两块或多块不同的指针指向（或重叠于）同一片内存区域。
*   **问题所在**：当编译器看到通过指针 `a` 写内存，又通过指针 `b` 读内存时，由于无法确定 `a` 和 `b` 是否指向同一位置（即是否存在别名），编译器必须保守地假设它们**可能**指向同一位置。这意味着它不能将读写操作的顺序进行重排优化，也不能将变量缓存在寄存器中，必须频繁地、按代码顺序写回内存，导致性能下降。
*   **`restrict` 的解决方案**：程序员通过 `restrict` 关键字向编译器保证“**我承诺这两个指针不会指向重叠的内存！**”。编译器信任这个承诺，从而可以生成更高效的代码。

---

## 2. C++ 中的等价物（编译器扩展）

由于 C++ 标准没有定义 `restrict`，各大编译器提供了自己的版本：

1.  **GCC / Clang**: 使用 `__restrict__` 或 `__restrict`
2.  **Microsoft Visual C++**: 使用 `__restrict`

从 C++11 开始，你也可以考虑使用标准属性 **`[[gnu::restrict]]`**，但这仍然是编译器相关的，其可移植性依赖于其他编译器是否也选择支持这个 GNU 属性。

---

## 3. 代码示例：对比有无 `restrict` 的区别

让我们看一个经典的例子：计算两个向量的点积。

### 示例 1：没有使用 `restrict`（保守编译）

```cpp
void dot_product(const double* a, const double* b, double* result, size_t n) {
    double sum = 0.0;
    for (size_t i = 0; i < n; ++i) {
        sum += a[i] * b[i];
    }
    *result = sum;
}

// 调用示例
double arr1[1000] = {...};
double arr2[1000] = {...};
double res;

dot_product(arr1, arr2, &res, 1000); // 标准情况，没问题
// 但是，如果出现下面这种调用呢？
// dot_product(arr1, arr1, &res, 1000); // a 和 b 是同一个数组！存在别名！
```
**编译器视角**：编译器看到 `a[i]` 和 `b[i]` 的读写操作。它必须考虑最坏情况——`a` 和 `b` 可能指向同一数组（甚至是 `result` 可能指向 `a` 或 `b` 的某个元素）。因此，它不敢做任何激进的优化：
*   不能在循环开始前将 `a[i]` 和 `b[i]` 提前加载到寄存器。
*   每次写入 `sum` 后，必须确保内存中的值是最新的，因为 `a` 或 `b` 可能会修改 `sum` 所在的内存（虽然这个例子中不会，但编译器不知道）。
*   循环无法被充分向量化（SIMD）。

### 示例 2：使用 `__restrict__`（允许激进优化）

```cpp
// 使用 GCC/Clang 的扩展
void dot_product_optimized(const double* __restrict__ a,
                          const double* __restrict__ b,
                          double* __restrict__ result,
                          size_t n) {
    double sum = 0.0;
    for (size_t i = 0; i < n; ++i) {
        sum += a[i] * b[i];
    }
    *result = sum;
}
```
**编译器视角**：程序员已经用 `__restrict__` 承诺了 `a`、`b`、`result` 这三者指向的内存绝无重叠。编译器可以放心大胆地优化：
*   **循环展开和向量化**：编译器可以使用 SSE/AVX 指令一次处理 4 个或 8 个 double 值，极大提升性能。
*   **寄存器缓存**：可以将 `a[i]` 和 `b[i]` 的值长时间保留在 CPU 寄存器中，减少访问内存的次数。
*   **指令重排**：可以重新安排计算顺序以更好地利用 CPU 的流水线。

**生成的汇编代码差异**：如果你在编译器资源管理器（如 [Compiler Explorer](https://godbolt.org/)）上对比这两个函数，会发现 `dot_product_optimized` 的汇编代码中包含了 `vmulpd`、`vaddpd` 等 SIMD 指令，而第一个函数则可能是一串冗长而保守的标量指令。

### **非常重要的警告**

使用 `restrict` 是在和编译器做一个**契约**。如果你违背了这个契约（即指针确实存在别名），将会导致**未定义行为**。程序可能会产生错误的结果，甚至崩溃。

```cpp
double my_array[10] = {...};

// 这是错误的！违背了 restrict 承诺！
dot_product_optimized(my_array, my_array, &some_result, 10);
```
上面的错误调用会导致未定义行为，因为 `a` 和 `b` 都被限定为 `__restrict__`，但它们明显指向了同一块内存。

---

## 4. 常见应用场景

`restrict` 主要用于对性能有极致要求的底层代码中：

1.  **数值计算库**：如 BLAS、LAPACK 或其衍生库（如 Eigen、Armadillo）。矩阵和向量运算函数是使用 `restrict` 的绝佳场合。
2.  **图像/音频处理**：处理像素缓冲区或音频采样时，不同的缓冲区（如 RGB 通道）通常是不重叠的。
3.  **编译器自身和标准库实现**：在实现 `memcpy`、`memmove` 等函数时，`memcpy` 的源和目的指针被假定为不重叠（所以可以用 `restrict` 来优化），而 `memmove` 则必须处理重叠情况。
4.  **游戏引擎和物理仿真**：大量的 3D 向量、四元数、矩阵运算。
5.  **任何处理大型数组且循环密集的算法**。

## 5. 标准库提供——[std::valarray](./numeric.md)

## 总结

| 特性             | 描述                                                         |
| :--------------- | :----------------------------------------------------------- |
| **本质**         | 一个向编译器做出的关于指针无别名的**承诺**，用于启用优化。   |
| **C++ 中的状态** | **非标准**。但所有主流编译器都通过扩展提供支持：GCC/Clang 的 `__restrict__`，MSVC 的 `__restrict`。 |
| **好处**         | 允许编译器进行激进的优化，如循环向量化、指令重排、寄存器缓存，从而大幅提升性能。 |
| **风险**         | 如果违背承诺（指针实际存在别名），会导致**未定义行为**，是程序中的一个严重错误。 |
| **适用场景**     | 性能至关重要的底层计算库、数据处理、媒体处理等，处理大型非重叠数据块的循环。 |

**使用建议**：
*   只在性能分析（Profiling）确定瓶颈后再考虑使用。
*   仅在你能 100% 确定指针绝无别名时使用。
*   在函数注释中明确写明指针不能重叠的约定。
*   注意其编译器相关的特性，如果追求可移植性，可能需要用宏来包装不同编译器的关键字。

# (2) [`inline`](https://cppreference.cn/w/cpp/language/inline)

## 1. 内联命名空间（C++20）

在C++中，`inline`关键字用于命名空间是C++11引入的特性，它允许将内联命名空间中的内容视为其父命名空间的一部分。这主要用于版本控制和ABI兼容性。

## 作用与用途

1. **版本控制**：允许库开发者提供多个版本API，同时保持向后兼容
2. **透明嵌套**：内联命名空间中的成员可以直接被父命名空间访问
3. **ABI兼容性**：帮助管理不同版本的二进制接口

## 示例代码

```cpp
#include <iostream>
#include <string>

// 模拟一个反射库的不同版本
namespace reflect::inline v1_2_5 {
    void serialize(const std::string& data) {
        std::cout << "使用v1.2.5序列化: " << data << std::endl;
    }
    
    std::string deserialize() {
        return "v1.2.5反序列化数据";
    }
}

namespace reflect::v1_2_4 {
    void serialize(const std::string& data) {
        std::cout << "使用v1.2.4序列化: " << data << std::endl;
    }
    
    std::string deserialize() {
        return "v1.2.4反序列化数据";
    }
}

int main() {
    // 可以直接使用 reflect:: 访问内联命名空间中的内容
    reflect::serialize("测试数据");
    std::cout << reflect::deserialize() << std::endl;
    
    // 如果需要使用旧版本，需要明确指定版本
    reflect::v1_2_4::serialize("测试数据");
    std::cout << reflect::v1_2_4::deserialize() << std::endl;
    
    return 0;
}
```

## 更完整的示例

```cpp
#include <iostream>
#include <string>

// 主命名空间
namespace reflect {
    // 内联命名空间 - 当前默认版本
    inline namespace v1_2_5 {
        class Serializer {
        public:
            virtual void serialize(const std::string& data) {
                std::cout << "v1.2.5序列化: " << data << std::endl;
            }
            
            virtual std::string deserialize() {
                return "v1.2.5反序列化数据";
            }
        };
    }
    
    // 旧版本命名空间
    namespace v1_2_4 {
        class Serializer {
        public:
            void serialize(const std::string& data) {
                std::cout << "v1.2.4序列化: " << data << std::endl;
            }
            
            std::string deserialize() {
                return "v1.2.4反序列化数据";
            }
        };
    }
    
    // 新版本命名空间（尚未设为内联）
    namespace v2_0_0 {
        class Serializer {
        public:
            virtual void serialize(const std::string& data, int format = 0) {
                std::cout << "v2.0.0序列化 (格式" << format << "): " << data << std::endl;
            }
            
            virtual std::string deserialize(int format = 0) {
                return "v2.0.0反序列化数据 (格式" + std::to_string(format) + ")";
            }
        };
    }
}

int main() {
    // 使用当前默认版本（内联命名空间）
    reflect::Serializer current;
    current.serialize("默认数据");
    std::cout << current.deserialize() << std::endl;
    
    // 使用旧版本
    reflect::v1_2_4::Serializer old;
    old.serialize("旧版本数据");
    std::cout << old.deserialize() << std::endl;
    
    // 使用新版本（尚未设为默认）
    reflect::v2_0_0::Serializer newer;
    newer.serialize("新版本数据", 1);
    std::cout << newer.deserialize(1) << std::endl;
    
    return 0;
}
```

## 使用场景说明

1. **库版本升级**：当更新库时，可以将新版本设为内联命名空间，旧代码无需修改即可使用新实现
2. **ABI兼容性**：保持二进制兼容性，同时提供新功能
3. **实验性功能**：可以将实验性API放在非内联命名空间中，稳定后再移至内联命名空间

当使用`namespace reflect::inline v1_2_5`语法时，表示`v1_2_5`是`reflect`命名空间的内联命名空间，其中的内容可以直接通过`reflect::`访问，而不需要指定`v1_2_5`子命名空间。

# (3) [`explicit`](https://cppreference.cn/w/cpp/language/explicit)

## 1. explicit(bool) （C++20）

在编译时有条件地选择构造函数是否为 `explicit`。`explicit(true)` 与指定 `explicit` 相同。

```C
struct foo {
  // 指定非整数类型（字符串、浮点数等）需要显式构造。
  template <typename T>
  explicit(!std::is_integral_v<T>) foo(T) {}
};

foo a = 123; // OK
foo b = "123"; // 错误：显式构造函数不是候选（explicit 指定符评估为 true）
foo c {"123"}; // OK
```



# `constexpr`、`consteval`(C++20)和 `constinit`(C++20)

在 C++20 中，编译期计算能力得到了显著增强，引入了 `consteval` 和 `constinit` 关键字来补充现有的 `constexpr`。这三个关键字共同构成了 C++ 编译期计算的核心机制。

## [1. `constexpr` - 常量表达式](https://cppreference.cn/w/cpp/language/constexpr)

### 功能说明
`constexpr` 用于声明可以在编译时求值的表达式、变量或函数。它既可以用于编译期上下文，也可以用于运行期上下文。

### 主要用途
- 编译期计算和优化
- 替代宏定义常量
- 在模板元编程中提供更清晰的语法

### 示例代码

```cpp
#include <iostream>
#include <array>

// 1. constexpr 变量
constexpr int max_size = 100; // 编译期常量

// 2. constexpr 函数 - 可以在编译期或运行期调用
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

// 3. constexpr 构造函数和类
class Point {
public:
    constexpr Point(double x, double y) : x_(x), y_(y) {}
    
    constexpr double x() const { return x_; }
    constexpr double y() const { return y_; }
    
    constexpr void set_x(double x) { x_ = x; } // C++14 起可以修改成员
    
private:
    double x_, y_;
};

int main() {
    // 编译期计算
    constexpr int fact_5 = factorial(5); // 在编译时计算
    std::cout << "5! = " << fact_5 << std::endl;
    
    // 编译期创建的数组大小
    std::array<int, factorial(5)> arr; // 使用编译期计算的值作为模板参数
    
    // 编译期创建的对象
    constexpr Point p(1.0, 2.0);
    std::cout << "Point: (" << p.x() << ", " << p.y() << ")" << std::endl;
    
    // 运行期调用 (仍然有效)
    int runtime_value = 6;
    std::cout << "Runtime factorial: " << factorial(runtime_value) << std::endl;
    
    return 0;
}
```

## [2. `consteval` - 立即函数 (C++20)](https://cppreference.cn/w/cpp/language/consteval)

### 功能说明
`consteval` 用于声明**必须在编译时执行**的函数（立即函数）。如果 `consteval` 函数不能在编译时求值，会导致编译错误。

### 与 `constexpr` 的区别
- `constexpr` 函数：可以在编译期或运行期调用
- `consteval` 函数：必须在编译期调用

### 主要用途
- 确保某些计算绝对在编译期完成
- 防止运行时代码膨胀
- 强制编译期验证

### 示例代码

```cpp
#include <iostream>
#include <type_traits>

// consteval 函数 - 必须在编译期执行
consteval int compile_time_square(int n) {
    return n * n;
}

// 编译期类型特性检查
consteval bool is_integral_constant(auto value) {
    return requires { typename std::remove_cvref_t<decltype(value)>::value_type; };
}

// 编译期字符串操作 (简单示例)
consteval size_t string_length(const char* str) {
    size_t length = 0;
    while (str[length] != '\0') {
        ++length;
    }
    return length;
}

int main() {
    // 正确使用：编译期调用
    constexpr int result = compile_time_square(5);
    std::cout << "5 squared = " << result << std::endl;
    
    // 编译期字符串长度计算
    constexpr size_t len = string_length("Hello");
    std::cout << "String length: " << len << std::endl;
    
    // 编译期类型检查
    constexpr bool check1 = is_integral_constant(std::integral_constant<int, 42>{});
    constexpr bool check2 = is_integral_constant(42); // 普通整数，不是integral_constant
    std::cout << "Check1: " << check1 << ", Check2: " << check2 << std::endl;
    
    // 错误示例（取消注释会导致编译错误）：
    // int runtime_value = 10;
    // int bad_result = compile_time_square(runtime_value); // 错误：runtime_value不是编译期常量
    
    return 0;
}
```

## 3. [`constinit` - 编译期初始化 (C++20)](https://cppreference.cn/w/cpp/language/constinit)

### 功能说明
`constinit` 确保变量**在编译时进行初始化**，但不保证变量的不可变性（不像 `const` 或 `constexpr`）。

### 主要用途
- 解决静态初始化顺序问题（Static Initialization Order Fiasco）
- 确保全局和静态变量在编译期初始化
- 提高程序启动性能

### 示例代码

```cpp
#include <iostream>
#include <array>

// 1. constinit 全局变量
constinit int global_initialized = 42; // 编译期初始化

// 2. 使用 constexpr 函数初始化
constexpr int compute_value() {
    return 10 * 10;
}

constinit int computed_value = compute_value(); // 编译期初始化

// 3. 解决静态初始化顺序问题
struct Config {
    int value;
    const char* name;
};

// 使用 constinit 确保在编译期初始化
constinit Config global_config = {100, "default"};

// 4. constinit 用于静态局部变量
void process_data() {
    static constinit int call_count = 0; // 编译期初始化，避免运行时开销
    ++call_count;
    std::cout << "Called " << call_count << " times" << std::endl;
}

// 5. 注意：constinit 不意味着常量
constinit int mutable_value = 100; // 可以修改

int main() {
    std::cout << "Global initialized: " << global_initialized << std::endl;
    std::cout << "Computed value: " << computed_value << std::endl;
    std::cout << "Config: " << global_config.value << ", " << global_config.name << std::endl;
    
    // 可以修改 constinit 变量（除非同时声明为 const）
    mutable_value = 200;
    std::cout << "Modified value: " << mutable_value << std::endl;
    
    // 多次调用演示静态局部变量
    process_data();
    process_data();
    process_data();
    
    return 0;
}
```

## 三者的区别与联系

| 特性           | `constexpr`                | `consteval`              | `constinit`                |
| -------------- | -------------------------- | ------------------------ | -------------------------- |
| **用途**       | 编译期可求值的表达式       | 必须在编译期执行的函数   | 编译期初始化的变量         |
| **可变性**     | 默认不可变（可加 mutable） | 函数特性，不涉及可变性   | 变量可修改（除非加 const） |
| **应用对象**   | 变量、函数、构造函数       | 仅函数                   | 仅变量                     |
| **运行期使用** | 可以                       | 不可以                   | 可以（变量可在运行期修改） |
| **主要优势**   | 灵活，兼容编译期和运行期   | 强制编译期执行，确保优化 | 解决静态初始化顺序问题     |

## 综合应用示例

```cpp
#include <iostream>
#include <array>

// consteval 函数：强制编译期计算
consteval auto create_lookup_table() {
    std::array<int, 10> table{};
    for (int i = 0; i < 10; ++i) {
        table[i] = i * i; // 平方表
    }
    return table;
}

// constinit 确保编译期初始化
constinit auto square_table = create_lookup_table();

// constexpr 函数：可在编译期或运行期使用
constexpr int get_square(int index) {
    if (index >= 0 && index < 10) {
        return square_table[index];
    }
    return -1;
}

int main() {
    // 编译期使用
    constexpr int square_5 = get_square(5);
    std::cout << "5 squared = " << square_5 << std::endl;
    
    // 运行期使用
    for (int i = 0; i < 10; ++i) {
        std::cout << i << "² = " << get_square(i) << std::endl;
    }
    
    // 修改 constinit 变量（演示可变性）
    square_table[0] = 999; // 允许修改
    std::cout << "Modified first element: " << square_table[0] << std::endl;
    
    return 0;
}
```

## 最佳实践建议

1. **优先使用 `constexpr`**：对于大多数编译期计算需求
2. **需要强制编译期执行时使用 `consteval`**：当必须确保计算在编译期完成时
3. **解决初始化顺序问题时使用 `constinit`**：对于全局和静态变量
4. **组合使用**：`consteval` 函数可以返回 `constexpr` 值，`constinit` 变量可以用 `consteval` 函数初始化
5. **注意兼容性**：`consteval` 和 `constinit` 是 C++20 特性，确保你的编译器支持

这三个关键字共同提供了强大的编译期计算和初始化控制能力，是现代 C++ 高性能编程的重要组成部分。

------

# (4) [`static`](https://cppreference.cn/w/cpp/language/static)

> 
>
> 见 二、语言支持——`ODR`[声明和定义](https://cppreference.cn/w/cpp/language/definition#ODR-use)
>
> 



<u>**请时刻记住一点静态初始化变量的顺序是`无序的`**</u>



### 语法

* 静态成员的声明是一个[成员声明](https://cppreference.cn/w/cpp/language/class#Member_specification)，其声明说明符包含关键词 static。关键词 static 通常出现在其他说明符之前（这就是为什么语法常被非正式地描述为 static 数据成员 或 static 成员函数），但可以出现在说明符序列中的任何位置。

* <u>任何静态数据成员和静态成员函数的名称必须与包含该类的名称不同。</u>

###  解释

**类的静态成员不与类的对象关联**：它们是具有静态或线程(C++11 起)[存储期](https://cppreference.cn/w/cpp/language/storage_duration)的独立变量，或者是常规函数。

关键词 static **仅**用于在类定义内**声明**静态成员，而**不**用于**定义**该静态成员。

```c
class X { static int n; }; // declaration (uses 'static')
int X::n = 1;              // definition (does not use 'static')
```

类体内的声明不是定义，并且可以声明成员为[不完整类型](https://cppreference.cn/w/cpp/language/incomplete_type)（除了 void），包括声明该成员的类型。

```c
struct Foo;
 
struct S
{
    static int a[]; // declaration, incomplete type
    static Foo x;   // declaration, incomplete type
    static S s;     // declaration, incomplete type (inside its own definition)
};
 
int S::a[10]; // definition, complete type
struct Foo {};
Foo S::x;     // definition, complete type
S S::s;       // definition, complete type
```

**<u>然而，如果声明使用 [`constexpr`](https://cppreference.cn/w/cpp/language/constexpr)或 [`inline`](https://cppreference.cn/w/cpp/language/inline)(C++17 起) 说明符，则成员必须声明为完整类型。  (C++11 起)</u>**



要引用类 `T` 的静态成员 `m`，可以使用两种形式：限定名 `T::m` 或成员访问表达式 `E.m` 或 `E->m`，其中 `E` 是一个分别评估为 `T` 或 `T*` 的表达式。在同一类作用域内，无需限定。

```c
struct X
{
    static void f(); // declaration
    static int n;    // declaration
};
 
X g() { return X(); } // some function returning X
 
void f()
{
    X::f();  // X::f is a qualified name of static member function
    g().f(); // g().f is member access expression referring to a static member function
}
 
int X::n = 7; // definition
 
void X::f() // definition
{
    n = 1; // X::n is accessible as just n in this scope
}
```



静态成员遵循[类成员访问规则（private, protected, public）](https://cppreference.cn/w/cpp/language/access)。

####  静态成员函数

* **静态成员函数不与任何对象关联**。调用时，它们**没有 this 指针**。

* 静态成员函数**不能是 virtual、const、volatile 或[引用限定](https://cppreference.cn/w/cpp/language/member_functions#ref-qualified_member_functions)的**。

* 静态成员函数的地址可以存储在常规的[函数指针](https://cppreference.cn/w/cpp/language/pointer#Pointers_to_functions)中，但不能存储在[成员函数指针](https://cppreference.cn/w/cpp/language/pointer#Pointers_to_member_functions)中。

####  静态数据成员

* 静态数据成员不与任何对象关联。即使没有定义类的任何对象，它们也存在。在整个程序中，只有一个具有静态[存储期](https://cppreference.cn/w/cpp/language/storage_duration)的静态数据成员实例，除非使用关键词 [`thread_local`](https://cppreference.cn/w/cpp/keyword/thread_local)，在这种情况下，每个线程有一个具有线程存储期的此类对象(C++11 起)。

* **静态数据成员不能是 mutable 的**。

* 如果类本身具有外部链接（不是[未命名命名空间](https://cppreference.cn/w/cpp/language/namespace#Unnamed_namespaces)的成员），则命名空间作用域中的类的静态数据成员具有[外部链接](https://cppreference.cn/w/cpp/language/storage_duration)。局部类（在函数内部定义的类）和未命名类，包括未命名类的成员类，不能拥有静态数据成员。
* **静态数据成员可以声明为 [`inline`](https://cppreference.cn/w/cpp/language/inline)。内联静态数据成员可以在类定义中定义，并可以指定初始化器。它不需要类外定义**（C++17 起）。

```c
struct X
{
    inline static int fully_usable = 1; // No out-of-class definition required, ODR-usable
    inline static const std::string class_name{"X"}; // Likewise
 
    static const int non_addressable = 1; // C.f. non-inline constants, usable
                                          // for its value, but not ODR-usable
    // static const std::string class_name{"X"}; // Non-integral declaration of this
                                                 // form is disallowed entirely
};
```



####  常量静态成员

如果一个<u>**整型或枚举类型**</u>的静态数据成员被声明为 const（而不是 volatile），它可以在类定义中直接用[初始化器](https://cppreference.cn/w/cpp/language/initialization)初始化，其中每个表达式都是[常量表达式](https://cppreference.cn/w/cpp/language/constexpr)。

```c
struct X
{
    const static int n = 1;
    const static int m{2}; // since C++11
    const static int k;
};
const int X::k = 3;
```



如果 [*LiteralType*](https://cppreference.cn/w/cpp/named_req/LiteralType) 的静态数据成员被声明为 constexpr，它必须在类定义中直接用初始化器初始化，其中每个表达式都是常量表达式。（C++17起）

```c
struct X
{
    constexpr static int arr[] = { 1, 2, 3 };        // OK
    constexpr static std::complex<double> n = {1,2}; // OK
    constexpr static int k; // Error: constexpr static requires an initializer
};
```



**如果 const 非 inline(C++17 起) 静态数据成员或 constexpr 静态数据成员(C++11 起)(C++17 前) 是[ODR-used](https://cppreference.cn/w/cpp/language/definition#ODR-use)，仍需要在命名空间作用域提供定义，但它不能带有初始化器。**

**constexpr 静态数据成员隐式地是 inline**，不需要在命名空间作用域重新声明。这种不带初始化器的重新声明（以前是必需的）仍然允许，但已弃用。(C++17 起)

```c
struct X
{
    static const int n = 1;
    static constexpr int m = 4;
};
 
const int *p = &X::n, *q = &X::m; // X::n and X::m are ODR-used
const int X::n;             // … so a definition is necessary
constexpr int X::m;         // … (except for X::m in C++17)
```

#### 静态重载(C++23起)

* 优势，减少了传入this指针的开销
* 对于lambda的定义友好

```c
#include <iostream>
struct X{
	static operator()(){ puts("static operator()"); }
};

int main(){
	X::operator(); //C++23 起
    X{}(); // 多this指针传入，X{}不会构造有开销
    auto func = [](int i) static { return i * 2; };
}
```



------

# (5) `decltype`

1) 如果参数是未加括号的[id-表达式](https://cppreference.cn/w/cpp/language/identifiers)或**<u>未加括号</u>**的[类成员访问](https://cppreference.cn/w/cpp/language/operator_member_access)表达式，则 decltype 产生该表达式所命名的实体的类型。如果没有这样的实体，或者如果参数命名了一组重载函数，则程序格式不正确。

| 如果参数是命名[结构化绑定](https://cppreference.cn/w/cpp/language/structured_binding)的未加括号的[id-表达式](https://cppreference.cn/w/cpp/language/identifiers)，则 decltype 产生*引用类型*（在结构化绑定声明的规范中描述）。 | (C++17 起) |
| ------------------------------------------------------------ | ---------- |
| 如果参数是命名[非类型模板参数](https://cppreference.cn/w/cpp/language/template_parameters#Non-type_template_parameter)的未加括号的[id-表达式](https://cppreference.cn/w/cpp/language/identifiers)，则 decltype 产生模板参数的类型（在模板参数声明了占位符类型的情况下，执行任何必要的类型推导之后）。即使实体是模板参数对象（一个 const 对象），该类型也是非 const 的。 | (C++20 起) |

2) 如果参数是类型为 `T` 的任何其他表达式，并且

​	**a) 如果表达式的[值类别](https://cppreference.cn/w/cpp/language/value_category)是[*xvalue*](https://cppreference.cn/w/cpp/language/value_category#xvalue)，则 decltype 产生 T&&；**

​	**b) 如果表达式的值类别是[*lvalue*](https://cppreference.cn/w/cpp/language/value_category#lvalue)，则 decltype 产生 T&；**

​	**c) 如果表达式的值类别是[*prvalue*](https://cppreference.cn/w/cpp/language/value_category#prvalue)，则 decltype 产生 T。**

| 如果表达式是返回类类型纯右值的函数调用，或是其右操作数是此类函数调用的[逗号表达式](https://cppreference.cn/w/cpp/language/operator_other)，则不为该纯右值引入临时对象。 | (C++17 前) |
| ------------------------------------------------------------ | ---------- |
| 如果表达式是纯右值（除了 (可能加括号的) [即时调用](https://cppreference.cn/w/cpp/language/consteval)）(C++20 起)，则不会从该纯右值[具体化](https://cppreference.cn/w/cpp/language/implicit_cast#Temporary_materialization)临时对象：这样的纯右值没有结果对象。 | (C++17 起) |

由于不创建临时对象，因此类型无需[完整](https://cppreference.cn/w/cpp/language/incomplete_type)或具有可用的[析构函数](https://cppreference.cn/w/cpp/language/destructor)，并且可以是[抽象的](https://cppreference.cn/w/cpp/language/abstract_class)。此规则不适用于子表达式：在 `decltype(f(g()))` 中，`g()` 必须具有完整类型，但 `f()` 则不必。

**<u>请注意，如果对象的名称被括号括起来，它将被视为普通的左值表达式，因此 decltype(x) 和 decltype((x)) 通常是不同的类型。</u>**

`decltype` 在声明难以或不可能使用标准符号声明的类型时非常有用，例如与 lambda 相关的类型或依赖于模板参数的类型。



```c
#include <type_traits>
decltype(auto) f1()
{
    static int n{};
    return (n);
}
decltype(auto) f2()
{
    static int n{};
    return n;
}
int main()
{
    auto&& x1 = f1(); // 类型提升
    auto&& x2 = f2();
    auto x11 = f1();
    auto x22 = f2();
    static_assert(
        !std::is_same_v<decltype(x1), decltype(x2)> && // int& != int &&
        std::is_same_v<decltype(x11), decltype(x22)> // int == int
        );

    decltype(auto) y1 = --x11; // 前置返回T&
    decltype(auto) y2 = ++x11;
    decltype(auto) y3 = x11++; // 后置返回T
    decltype(auto) y4 = x11--;
    static_assert(
        std::is_same_v<decltype(y1), decltype(y2)> && // int& == int &
        std::is_same_v<decltype(y3), decltype(y4)> // int == int
        );
}
```

------

# (6) virtual

## 多态析构

```c
#include <iostream>
struct Base {
    virtual void foo() const { std::puts("Base::foo"); }
    void operator delete(void* ptr) noexcept {
        std::free(ptr);
        std::puts("Base::operator delete");
    }
    virtual ~Base() = default;
};
struct Derived : Base {
    void foo() const override { std::puts("Derived::foo"); }
    void operator delete(void* ptr) noexcept {
        std::free(ptr);
        std::puts("Derived::operator delete");
    }
    ~Derived() override = default;
};
int main() {
    Base* b = new Derived;
    b->foo();
    delete b; // 如果不定义虚析构，这行代码是UB行为，原因virtual 影响重载决议，如果父类没有定义虚析构，那么delete b 仅调用父类的重载delete，不会调用子类Derived的delete
}
```



# 二、语言支持

# `lambda`

博客文章	https://zhuanlan.zhihu.com/p/583729920

1. `lambda`表达式是一个**非聚合体、非联合的类类型**，**可以被继承**

2. `lambda`是**含有`operator()`重载的类**，并且非捕获的`lambda`是**可以有转换函数，转换为函数指针**的

3. `lambda`默认 **值捕获** 由编译器 <u>生成的重载`operator()`方法是`const`不可以修改的</u>，如果想要修改需要加上`mutable`关键字，`[=]() mutable {};``

4. ``lambda`声明时，建议同时声明后置返回类型，否则程序非良构

5. C++20起，值捕获将不再隐式捕获this，需要显示指定this

6. 截至C++23中`lambda`可以被修饰为 **`模板`**、**`常量表达式`**、**`static`**、可以添加 **`属性[[]]`**、可以通过 **`显示对象参数特性递归`** 、可以 **`捕获模板参数包`**、**`无参时 可以省略 ()`**

7. 如果变量满足下列条件，那么 **lambda 表达式在使用它前不需要先捕获**：

   * 该变量是非局部变量，或具有**静态**或**线程局部[存储期](https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/storage_duration)**（此时无法捕获该变量），

   * 或者该变量是**以[常量表达式](https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/constant_expression%23.E5.B8.B8.E9.87.8F.E8.A1.A8.E8.BE.BE.E5.BC.8F)初始化的引用**。

8. 如果变量满足下列条件，那么 lambda 表达式在读取它的值前不需要先捕获：

   * 该变量**具有 const 而非 volatile 的整型或枚举类型，并已经用[常量表达式](https://link.zhihu.com/?target=https%3A//zh.cppreference.com/w/cpp/language/constant_expression%23.E5.B8.B8.E9.87.8F.E8.A1.A8.E8.BE.BE.E5.BC.8F)初始化**，

   * 该**变量是 `constexpr` 的且没有 mutable 成员**。

```c
struct P : decltype([]() -> void {std::cout << "\n";}) // 第一点
{
};

struct P : public __lambda_2_21
{
	struct P;
};

int main()
{
    // 第七点
    {
        static int a = 42;
        auto p = [=] { ++a; } ;
        std::cout << sizeof(p) << '\n';
        p();
        // 打印 1 	a 是43
	}
    // 第八点
    {
        const float a = 6;
        []() {
            std::cout << a << '\n';
        }(); // 无法通过编译
        
		const int N = 10;
        auto p = [=]() {
            int arr[N]{};
        };
        std::cout << sizeof(p) << '\n'; // 打印1
    }
    
    auto* p = +[]() -> int {return 42; }; // + 使得lambda被转换为函数指针
    
    // 可以被继承，调用operator()
	P{}();
    
    // 编译器可能生成
    class __lambda_2_21
    {
    public:
        inline /*constexpr */ void operator()() const
        {
            std::operator<<(std::cout, "\n");
        }

        using retType_2_21 = void (*)();
        inline constexpr operator retType_2_21 () const noexcept
        {
            return __invoke;
        };

    private:
        static inline /*constexpr */ void __invoke()
        {
            __lambda_2_21{}.operator()();
        }

    public:
        // /*constexpr */ __lambda_2_21() = default;

    } __lambda_2_21{};

    static_cast<const __lambda_2_21&>(P{ __lambda_2_21__lambda_2_21{} }).operator()();

////////////////////
    
    // lambda匿名类对象被转换为函数指针
    int(*p)(int) = [](int a) -> int { return a; };
    
    // 编译器可能生成
    class __lambda_5_20
    {
    public:
        inline /*constexpr */ int operator()(int a) const
        {
            return static_cast<int&&>(a);
        }

        using retType_5_20 = int (*)(int);
        inline constexpr operator retType_5_20 () const noexcept
        {
            return __invoke;
        }

    private:
        static inline /*constexpr */ int __invoke(int a)
        {
            return __lambda_5_20{}.operator()(a);
        }


    public:
        // /*constexpr */ __lambda_5_20() = default;

    };

    using FuncPtr_5 = int (*)(int);
    FuncPtr_5 p = __lambda_5_20{}.operator __lambda_5_20::retType_5_20();
    
////////////////////
    
    // lambda捕获
    /*const*/ int x{ 42 };
  	auto getX = [/*&*/x]() -> int { return x; };
    
    // 编译器可能生成
  	class __lambda_6_16
  	{
    public: 
    	inline /*constexpr */ int operator()() const // const 由 mutable 决定是否生成
    	{
      		return x;
    	}
    
    private: 
    	/*const*/ int/*&*/ x; // &由捕获决定，const由捕获的变量是否是const决定
    
    public:
    	__lambda_6_16(/*const*/ int & _x)
    	: x{_x}
    	{}
    
  	};
  
  	__lambda_6_16 getX = __lambda_6_16{x};
    
////////////////////
    
    // lambda 返回常量
    auto _42 = [](int a) -> int { return 42; };
    
    // 编译器可能生成
    class __lambda_6_15
	{
    public: 
    	inline /*constexpr */ int operator()(int a) const
    	{
      		return 42;
    	}
    
    	using retType_6_15 = int (*)(int);// 函数指针
    	inline constexpr operator retType_6_15 () const noexcept
    	{
      		return __invoke;
    	};
    
    private: 
    	static inline /*constexpr */ int __invoke(int a)
    	{
      		return __lambda_6_15{}.operator()(a);
    	}
    
    
    public:
    // /*constexpr */ __lambda_6_15() = default;
    
  	};
  
 	__lambda_6_15 _42 = __lambda_6_15{};

  	return 0;
}
```



# `ODR`[声明和定义](https://cppreference.cn/w/cpp/language/definition#ODR-use)

> `static`的使用见上述关键字说明—— 常量静态成员

```c
#include <iostream>
struct X
{
    static const int n = 1;
    static constexpr int m = 4;
};
 
const int *p = &X::n, *q = &X::m; // X::n and X::m are ODR-used
const int X::n;             // … so a definition is necessary
constexpr int X::m;         // … (except for X::m in C++17)

void foo(const int& v){}

int main() {
    std::cout << X::n << "\n"; // 不是ODR使用
    std::cout << &X::n << "\n"; // ODR 使用，必须定义，C++17起 constexpr 声明的时候会隐含 inline关键字，相当于声明定义了，无需在类外定义，而 static const int 必须要在类外定义，除非添加关键字inline
    
    f(X::n); // GCC/clang 是错误的，如果没有const int X::n;定义，但是MSVC没有遵守规范，编译器将它优化为了字面量，f(10)
    return 0;
}
```



# `显示对象参数特性(C++23)`

```c
struct X {

    //void f() {}
    //void f() const {}
    //void f() volatile {}
    //void f() const volatile {}

    // 4个决议细分为以下八个重载决议
#if __cplusplus > 202002L
    // C++23起
    void f(this X&) {}
    void f(this const X&) {}
    void f(this volatile X&) {}
    void f(this const volatile X&) {}

    void f(this X&&) {}
    void f(this const X&&) {}
    void f(this volatile X&&) {}
    void f(this const volatile X&&) {}
#else
    void f()& {}
    void f() const& {}
    void f() volatile& {}
    void f() const volatile& {}

    void f()&& {}
    void f() const&& {}
    void f() volatile&& {}
    void f() const volatile&& {}
#endif
};
```

# `初始化列表`

* 初始化列表初始化默认调用的是 `赋值构造函数operator=`
* 赋值初始化不会考虑explicit构造函数，所以初始化列表也不会考虑

```c
#include <iostream>
struct X
{
	X(int) { puts("int"); }
    explicit X(double) { puts("double"); }
};

int main()
{
	X x1 = 1;	// 输出int
    X x2 = 2.2;	// 输出int
    const X& x3{ 1 };	// 输出int
    const X& x4{ 1.2 }; //ERROR，不能编译
}
```

## 三五法则

* 弃置函数，删除了拷贝构造代表移动构造也被删除，仅删除一个即可

------



# 三、概念明确

很好的问题！这几个概念是C++核心且容易混淆的点。我们来逐一拆解和区分。

## 1. 地址是指针吗？二者可以等价吗？

**简短回答：** 地址是**值**，指针是**变量**。它们密切相关，但**不能完全等价**。

**详细解释：**

*   **地址 (Address)**： 内存中每个字节都有一个唯一的编号，这个编号就是地址。它是一个**常量值**，就像门牌号码一样，本身不占用存储空间（在源码层面表示一个值）。
*   **指针 (Pointer)**： 是一个**变量**，它的**值**是另一个变量的地址。因为它本身是一个变量，所以它在内存中有自己的存储空间，并且它的值（即它存储的地址）是可以改变的。

**一个很好的类比：**
假设有一栋房子（变量）在 `123 Main Street`（地址）。

*   **地址**就是 `123 Main Street` 这个值本身。
*   **指针**就是一张写着 `123 Main Street` 的纸条。你可以有好多张纸条（多个指针），都写着同一个地址。你也可以擦掉纸条上的字，改成另一个地址（改变指针的指向）。

**关键区别：**

| 特征         | 地址 (Address)                   | 指针 (Pointer)                        |
| :----------- | :------------------------------- | :------------------------------------ |
| **本质**     | 一个常量值                       | 一个变量                              |
| **内存占用** | 否（它是一个值）                 | 是（它需要空间来存储这个地址值）      |
| **可修改性** | 否（一个变量的地址是固定不变的） | 是（可以指向不同的地址）              |
| **操作**     | 可以赋值给指针                   | 可以被解引用(`*`)、赋值、进行算术运算 |

**结论：** 我们可以说 **“指针的值是一个地址”**，但不能说“地址就是指针”。它们的关系是“值”与“存储这个值的容器”的关系。

---

## 2. 数组是地址吗？二者可以等价吗？

**简短回答：** 在大多数情况下，数组名会被编译器**隐式转换**（退化）为指向其首元素的地址。但是，**数组和地址在C++类型系统中是完全不同的概念，不能等价**。

**详细解释：**

*   **数组 (Array)**： 是一片**连续的内存空间**，用于存储多个相同类型的元素。它是一个**复合数据类型**。
*   **地址**： 如上所述，是一个值。

**数组名的“退化” (Decay)规则：**
在大多数表达式中，当使用数组名时，它会自动转换为指向其第一个元素的指针。这个过程中，数组的长度信息就丢失了。

```cpp
int myArray[5] = {10, 20, 30, 40, 50};

// 在下面这个语句中，`myArray` 会发生“退化”
// 从类型 `int [5]` 退化为类型 `int*`
// 它的值就是 `&myArray[0]`（第一个元素的地址）
int* ptr = myArray; // 等价于 int* ptr = &myArray[0];

cout << *ptr; // 输出 10
```

**证明它们不等价的特殊情况：**

有两个重要的操作符可以区分数组和单纯的地址：

1.  **`sizeof` 操作符**
    *   `sizeof(数组名)` 返回的是**整个数组所占的字节大小**。
    *   `sizeof(指针)` 返回的是**指针变量本身所占的字节大小**（通常是4或8字节，取决于系统）。

    ```cpp
    int myArray[5];
    int* ptr = myArray;
    
    cout << sizeof(myArray); // 很可能输出 20 (5 * 4字节，假设int为4字节)
    cout << sizeof(ptr);     // 在64位系统上输出 8
    ```

2.  **取地址操作符 `&`**
    *   对指针 `ptr` 取地址 `&ptr`，得到的是**指针变量自身的地址**。
    *   对数组 `myArray` 取地址 `&myArray`，得到的虽然是**相同的地址值**，但**类型不同**。它的类型是 `int (*)[5]`（指向长度为5的整型数组的指针），而不是 `int*`。

    ```cpp
    // 地址值相同...
    cout << myArray;    // 输出: 0x7fff5d3f4a00 (例如)
    cout << &myArray;   // 输出: 0x7fff5d3f4a00 (相同的值)
    
    // ...但类型完全不同！
    int* p1 = myArray;  // 正确：int* = int*
    int* p2 = &myArray; // 错误！无法将 ‘int (*)[5]’ 赋值给 ‘int*’
    ```

**结论：** 数组名在大多数情况下可以当作一个常量指针（地址）来使用，这是因为语言设计上的“退化”规则带来的便利。但从语言类型的本质上看，**数组不是地址**。`int [5]` 和 `int*` 是两种不同的类型。

总结

| 概念     | 本质                                 | 与其他的关系                                     |
| :------- | :----------------------------------- | :----------------------------------------------- |
| **地址** | 一个**常量值**，表示内存位置。       | 是指针变量的**值**。                             |
| **指针** | 一个**变量**，其值是地址。           | **存储**着地址。                                 |
| **数组** | 一片**连续的内存空间**（复合类型）。 | 数组名在大多数表达式里会**退化为**首元素的地址。 |

**编程建议：**
理解这些区别对于避免底层错误至关重要。例如，在函数传参时，数组会退化为指针，从而丢失长度信息，这就是为什么通常需要另一个参数来传递数组大小的原因。在现代C++中，更推荐使用 `std::array` 或 `std::vector` 来避免这种“退化”问题。

非常好，你问到了C++现代语法中非常核心且精妙的部分。我们来彻底讲清楚这几个概念。

## 3. 引用是指针吗？概念和底层是否可以等价？

**简短回答：** **概念上不等价，底层实现上通常类似，但绝不能认为它们等价。** 将它们等价是初学者常见的误解，会导致对C++语义的错误理解。

**详细解释：**

| 特性         | 引用 (Reference)                                             | 指针 (Pointer)                                  | 说明                                                         |
| :----------- | :----------------------------------------------------------- | :---------------------------------------------- | :----------------------------------------------------------- |
| **本质**     | **别名 (Alias)**                                             | **地址变量**                                    | **核心区别**。引用不是一个对象，它只是另一个已存在对象的别名。指针本身是一个独立的对象。 |
| **空值**     | **不能为空**，必须初始化绑定到一个对象。                     | 可以为 `nullptr`。                              | 这是最关键的语义区别之一。使用引用不需要检查空，因为它必然代表一个有效对象（只要其宿主对象有效）。 |
| **重绑定**   | **不能** 在初始化后改变其绑定的对象。                        | **可以** 随时改变指向的对象。                   | `int& r = a; r = b;` 这行代码的意思是**把b的值赋值给a**，而不是让r引用b。 |
| **操作**     | 使用方式与原始对象**完全一样**。                             | 需要解引用(`*`)或成员访问(`->`)来操作所指对象。 | `r = 10;` vs `*p = 10;`                                      |
| **内存占用** | **概念上不占空间**，它只是另一个名字。                       | **占空间**（通常4或8字节），存储一个地址。      | **底层实现上**，编译器通常会用指针来实现引用（即存储目标的地址），所以它会有和指针一样大小的内存开销。但你无法获取这个“隐藏指针”的地址（`&r` 得到的是原对象的地址）。 |
| **多级**     | 没有“引用的引用”（直到C++11的引用折叠规则出现，但那是由模板/别名推导产生的，不能直接声明）。 | 可以有指针的指针（`int**`）。                   |                                                              |

**结论：**
你可以将引用想象成一个“**自动解引用的、不可为空、不可重绑定的常量指针**”。虽然在编译后的汇编代码中，引用和指针的操作可能非常相似（都是通过地址间接访问），但它们在**语言层面的语义和用法有天壤之别**。混淆二者会导致错误的代码设计和逻辑。

---

## 4. 各种引用的详解

### a) 左值引用 (Lvalue Reference) - `T&`
这是C++98就存在的传统引用。
*   **作用**： 为**左值**（有标识符、可取地址的表达式）创建一个别名。
*   **目的**： 主要用于函数参数的**按引用传递**，避免拷贝开销，并允许在函数内部修改传入的变量。
*   **例子**：
    ```cpp
    int a = 10;
    int& ref = a; // ref是a的别名
    ref = 20;     // 等同于 a = 20;
    
    void swap(int& x, int& y); // 经典用法：修改实参
    ```

### b) 右值引用 (Rvalue Reference) - `T&&` (C++11引入)
*   **作用**： 绑定到**右值**（字面量、临时对象、即将销毁的对象）。
*   **目的**： 两个核心用途：
    1.  **移动语义 (Move Semantics)**： “窃取”即将销毁的对象的资源，避免昂贵的深拷贝。
    2.  **完美转发 (Perfect Forwarding)**： 与万能引用配合，保持参数的值类别（左值性/右值性）不变地转发给其他函数。
*   **例子**：
    ```cpp
    std::string s1 = "Hello";
    std::string s2 = std::move(s1); // std::move(s1) 将s1转换为右值，
                                    // s2的构造函数“窃取”s1内部的字符数组所有权。
                                    // 此后s1处于有效但未定义的状态（通常为空）。
    ```

### c) 万能引用 (Universal Reference) / 转发引用 (Forwarding Reference) - `T&&` (在特定语境下)
这是C++中最容易令人困惑的概念之一。
*   **定义**： 并非一种新语法，而是指在**模板参数推导**或`auto`推导语境下出现的 `T&&`。它拥有“超能力”——可以根据传入的实参的值类别，自动推导为左值引用或右值引用。
*   **条件**：
    1.  必须涉及**类型推导**（在函数模板或`auto`中）。
    2.  形式必须**严格**是 `T&&` 或 `auto&&`。（注意：`const T&&` 不是万能引用，只是一个常量右值引用）。
*   **目的**： 实现**完美转发 (Perfect Forwarding)**。
*   **例子**：
    ```cpp
    template<typename T>
    void foo(T&& param) { // 这里是万能引用！T的类型和param的引用类型由实参决定
        // ... 可以使用std::forward<T>保持值类别并转发param
    }
    
    int x = 10;
    foo(x);  // x是左值，所以T被推导为int&，param的类型是int& （引用折叠发生）
    foo(10); // 10是右值，所以T被推导为int, param的类型是int&&
    ```

### d) 引用折叠 (Reference Collapsing) - 规则
这是支撑万能引用和`std::forward`实现的**底层规则**。编译器在特定语境（模板、`typedef`、`decltype`）下推导引用之引用时，会使用此规则将其“折叠”成单一引用。
*   **规则**：
    *   `& &` -> `&`
    *   `& &&` -> `&`
    *   `&& &` -> `&`
    *   `&& &&` -> `&&`
*   **与万能引用的关系**： 当你向万能引用函数传递一个左值时（如上一个例子中的`foo(x)`），发生的过程是：
    1.  `T` 被推导为 `int&`。
    2.  参数类型 `T&&` 变成了 `int& &&`。
    3.  编译器应用引用折叠规则：`int& &&` -> `int&`。
    4.  最终，`param` 是一个绑定到左值 `x` 的左值引用。

### 总结与关系图

| 引用类型     | 语法             | 主要用途               | 关键特性                           |
| :----------- | :--------------- | :--------------------- | :--------------------------------- |
| **左值引用** | `T&`             | 别名、按引用传参修改值 | 绑定左值，不可空，不可重绑定       |
| **右值引用** | `T&&`            | 移动语义、完美转发     | 绑定右值，用于资源转移             |
| **万能引用** | `T&&` (在模板中) | 完美转发               | **根据实参推导**，可绑定左值或右值 |
| **引用折叠** | (规则)           | 实现万能引用的底层机制 | 处理“引用的引用”                   |

**关系：**
**万能引用** 是语法形式 `T&&` 在模板推导语境下的特殊行为。它的实现依赖于 **引用折叠** 规则。而**右值引用**是 `T&&` 在非推导语境下的行为（如 `std::string&& s`，这里没有类型推导，就是一个明确的右值引用）。

**最终建议：**
*   **不要**在概念上将引用和指针等价。记住引用是别名。
*   使用 `const T&` 来传递不希望改变的大对象（只读借用）。
*   使用 `T&` 来传递需要在函数内部修改的对象（可写借用）。
*   使用 `T&&`（右值引用）来实现移动构造函数和移动赋值运算符，来管理资源。
*   在编写通用模板函数时，使用 `T&&`（万能引用）和 `std::forward<T>` 来实现完美转发，从而编写出高效且通用的代码。

## 5. [值类别](https://cppreference.cn/w/cpp/language/value_category)



## 6. [求值顺序](https://cppreference.cn/w/cpp/language/eval_order)



## 7. [表达式](https://cppreference.cn/w/cpp/language/expressions#Potentially-evaluated_expressions)





# 宏

博客 https://zhuanlan.zhihu.com/p/589466205
