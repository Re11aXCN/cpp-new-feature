# [C++ 标准库容器详解](https://cppreference.cn/w/cpp/container)

## 1. 概述

容器库是类模板和算法的通用集合，程序员可以轻松地实现常见的数据结构，如队列、列表和堆栈。容器分为两(直到 C++11)三(自 C++11 起)类

- 序列容器，
- 关联容器，
- 无序关联容器，  

每种容器都旨在支持一组不同的操作。

容器管理为其元素分配的存储空间，并提供成员函数，以直接或通过迭代器（具有与指针类似属性的对象）访问它们。

大多数容器至少有几个共同的成员函数，并共享功能。哪种容器最适合特定应用程序，不仅取决于所提供的功能，还取决于其在不同工作负载下的效率。

###  序列容器

序列容器实现可以按顺序访问的数据结构。

| [ array](https://cppreference.cn/w/cpp/container/array)(C++11) | 固定大小的原位连续数组  (类模板)           |
| ------------------------------------------------------------ | ------------------------------------------ |
| [ vector](https://cppreference.cn/w/cpp/container/vector)    | 可变大小的连续数组  (类模板)               |
| [ inplace_vector](https://cppreference.cn/w/cpp/container/inplace_vector)(C++26) | 可变大小、固定容量、原地连续数组  (类模板) |
| hive(C++26)                                                  | 重用已擦除元素的内存的集合  (类模板)       |
| [ deque](https://cppreference.cn/w/cpp/container/deque)      | 双端队列  (类模板)                         |
| [ forward_list](https://cppreference.cn/w/cpp/container/forward_list)(C++11) | 单向链表  (类模板)                         |
| [ list](https://cppreference.cn/w/cpp/container/list)        | 双向链表  (类模板)                         |

###  关联容器

关联容器实现可以快速搜索（O(log n) 复杂度）的排序数据结构。

| [ set](https://cppreference.cn/w/cpp/container/set)          | 唯一键的集合，按键排序  (类模板)       |
| ------------------------------------------------------------ | -------------------------------------- |
| [ map](https://cppreference.cn/w/cpp/container/map)          | 键值对集合，按键排序，键唯一  (类模板) |
| [ multiset](https://cppreference.cn/w/cpp/container/multiset) | 键的集合，按键排序  (类模板)           |
| [ multimap](https://cppreference.cn/w/cpp/container/multimap) | 键值对的集合，按键排序  (类模板)       |



###  无序关联容器 (自 C++11 起)

无序关联容器实现可以快速搜索（O(1) 平均，O(n) 最坏情况复杂度）的无序（哈希）数据结构。

| [ unordered_set](https://cppreference.cn/w/cpp/container/unordered_set)(C++11) | 由键哈希的唯一键集合  (类模板)               |
| ------------------------------------------------------------ | -------------------------------------------- |
| [ unordered_map](https://cppreference.cn/w/cpp/container/unordered_map)(C++11) | 键值对的集合，按键哈希，键是唯一的  (类模板) |
| [ unordered_multiset](https://cppreference.cn/w/cpp/container/unordered_multiset)(C++11) | 键的集合，按键哈希  (类模板)                 |
| [ unordered_multimap](https://cppreference.cn/w/cpp/container/unordered_multimap)(C++11) | 键值对集合，按键哈希  (类模板)               |

###  容器适配器

容器适配器为序列容器提供不同的接口。

| [ stack](https://cppreference.cn/w/cpp/container/stack)      | 适配容器以提供堆栈（LIFO 数据结构）  (类模板)        |
| ------------------------------------------------------------ | ---------------------------------------------------- |
| [ queue](https://cppreference.cn/w/cpp/container/queue)      | 将容器适配为提供队列（先进先出数据结构）  (类模板)   |
| [ priority_queue](https://cppreference.cn/w/cpp/container/priority_queue) | 适配容器以提供优先级队列  (类模板)                   |
| [ flat_set](https://cppreference.cn/w/cpp/container/flat_set)(C++23) | 适配容器以提供唯一键的集合，按键排序  (类模板)       |
| [ flat_map](https://cppreference.cn/w/cpp/container/flat_map)(C++23) | 适配两个容器以提供键值对集合，按唯一键排序  (类模板) |
| [ flat_multiset](https://cppreference.cn/w/cpp/container/flat_multiset)(C++23) | 适配容器以提供按键排序的键集合  (类模板)             |
| [ flat_multimap](https://cppreference.cn/w/cpp/container/flat_multimap)(C++23) | 适配两个容器以提供按键排序的键值对集合  (类模板)     |



###  视图 (自 C++20 起)

视图提供灵活的功能，用于与非拥有元素数组上的一维或多维视图进行交互。

| [ span](https://cppreference.cn/w/cpp/container/span)(C++20) | 一个连续对象序列的非拥有视图  (类模板) |
| ------------------------------------------------------------ | -------------------------------------- |
| [ mdspan](https://cppreference.cn/w/cpp/container/mdspan)(C++23) | 一个多维非拥有数组视图  (类模板)       |

###  伪容器

注意：[std::basic_string](https://cppreference.cn/w/cpp/string/basic_string) 不被标准视为容器，但由于其相似性，其行为很像容器。为方便起见，此处将其列为“伪容器”。

### 迭代器失效

只读方法从不使迭代器或引用[失效](https://cppreference.cn/w/cpp/iterator#Dereferceability_and_validity)。修改容器内容的方法可能会使迭代器和/或引用失效，总结如下表。

| 分类         | Container（容器）                                            | 在**插入**后，是否... |                | 在**擦除**后，是否... |                | 有条件地                                      |
| ------------ | ------------------------------------------------------------ | --------------------- | -------------- | --------------------- | -------------- | --------------------------------------------- |
|              |                                                              | **迭代器**有效？      | **引用**有效？ | **迭代器**有效？      | **引用**有效？ |                                               |
| 序列容器     | [`array`](https://cppreference.cn/w/cpp/container/array)     | 不适用                |                | 不适用                |                |                                               |
|              | [`vector`](https://cppreference.cn/w/cpp/container/vector)   | 否                    |                | 不适用                |                | 插入更改了容量                                |
|              |                                                              | 是                    |                | 是                    |                | 在修改元素之前 （仅当容量未更改时才进行插入） |
|              |                                                              | 否                    |                | 否                    |                | 在修改元素处或之后                            |
|              | [`deque`](https://cppreference.cn/w/cpp/container/deque)     | 否                    | 是             | 是，除了已擦除的元素  |                | 修改了第一个或最后一个元素                    |
|              |                                                              | 否                    |                | 否                    |                | 仅修改了中间元素                              |
|              | [`list`](https://cppreference.cn/w/cpp/container/list)       | 是                    |                | 是，除了已擦除的元素  |                |                                               |
|              | [`forward_list`](https://cppreference.cn/w/cpp/container/forward_list) | 是                    |                | 是，除了已擦除的元素  |                |                                               |
| 关联容器     | [`set`](https://cppreference.cn/w/cpp/container/set) [`multiset`](https://cppreference.cn/w/cpp/container/multiset) [`map`](https://cppreference.cn/w/cpp/container/map) [`multimap`](https://cppreference.cn/w/cpp/container/multimap) | 是                    |                | 是，除了已擦除的元素  |                |                                               |
| 无序关联容器 | [`unordered_set`](https://cppreference.cn/w/cpp/container/unordered_set) [`unordered_multiset`](https://cppreference.cn/w/cpp/container/unordered_multiset) [`unordered_map`](https://cppreference.cn/w/cpp/container/unordered_map) [`unordered_multimap`](https://cppreference.cn/w/cpp/container/unordered_multimap) | 否                    | 是             | 不适用                |                | 插入导致重新哈希                              |
|              |                                                              | 是                    |                | 是，除了已擦除的元素  |                | 未重新哈希                                    |

此处，**插入**指任何向容器添加一个或多个元素的方法，而**擦除**指任何从容器中删除一个或多个元素的方法。

- 插入方法的示例有 [std::set::insert](https://cppreference.cn/w/cpp/container/set/insert)、[std::map::emplace](https://cppreference.cn/w/cpp/container/map/emplace)、[std::vector::push_back](https://cppreference.cn/w/cpp/container/vector/push_back) 和 [std::deque::push_front](https://cppreference.cn/w/cpp/container/deque/push_front)。
  - ​        注意 std::unordered_map::operator[] 也算作插入，因为它可能会向映射中插入一个元素。
- 擦除方法的示例有 [std::set::erase](https://cppreference.cn/w/cpp/container/set/erase)、[std::vector::pop_back](https://cppreference.cn/w/cpp/container/vector/pop_back)、[std::deque::pop_front](https://cppreference.cn/w/cpp/container/deque/pop_front) 和 [std::map::clear](https://cppreference.cn/w/cpp/container/map/clear)。
  -  `clear` 使所有迭代器和引用失效。因为它擦除了所有元素，所以这在技术上符合上述规则。
- 除非另有说明（显式或通过定义基于其他函数的函数），否则将容器作为参数传递给库函数绝不会使容器内对象的迭代器失效或更改其值。
- 末尾迭代器值得特别提及。通常，此迭代器会像指向未擦除元素的普通迭代器一样失效。因此 [std::set::end](https://cppreference.cn/w/cpp/container/set/end) 绝不会失效，[std::unordered_set::end](https://cppreference.cn/w/cpp/container/unordered_set/end) 仅在重新哈希时失效(自 C++11 起)，[std::vector::end](https://cppreference.cn/w/cpp/container/vector/end) 总是失效（因为它总是在修改的元素之后），依此类推。
- 有一个例外：删除 [std::deque](https://cppreference.cn/w/cpp/container/deque) 的最后一个元素的擦除确实使末尾迭代器失效，即使它不是容器的已擦除元素（或根本不是元素）。结合 [std::deque](https://cppreference.cn/w/cpp/container/deque) 迭代器的一般规则，最终结果是唯一不使 [std::deque::end](https://cppreference.cn/w/cpp/container/deque/end) 失效的修改操作是删除第一个元素而不是最后一个元素的擦除。

### 线程安全

> 1. 所有容器函数都可以由不同线程在不同容器上并发调用。更一般地，C++ 标准库函数不会读取其他线程可访问的对象，除非这些对象通过函数参数（包括此指针）直接或间接可访问。
> 2. 所有 const 成员函数都可以由不同线程在同一容器上并发调用。此外，成员函数 `begin()`、`end()`、`rbegin()`、`rend()`、`front()`、`back()`、`data()`、`find()`、`lower_bound()`、`upper_bound()`、`equal_range()`、`at()`，以及除关联容器外的 `operator[]`，在线程安全方面表现为 const（即，它们也可以由不同线程在同一容器上并发调用）。更一般地，C++ 标准库函数不会修改对象，除非这些对象通过函数的非 const 参数（包括此指针）直接或间接可访问。
> 3. 同一容器中的不同元素可以由不同线程并发修改，但 std::vector<bool> 的元素除外（例如，一个 [std::future](https://cppreference.cn/w/cpp/thread/future) 对象的 vector 可以从多个线程接收值）。
> 4. 迭代器操作（例如，递增迭代器）读取但不修改底层容器，并且可以与同一容器上其他迭代器的操作、const 成员函数或元素的读取并发执行。使任何迭代器失效的容器操作会修改容器，并且不能与现有迭代器上的任何操作并发执行，即使这些迭代器未失效。
> 5. 同一容器的元素可以与未指定访问这些元素的成员函数并发修改。更一般地，C++ 标准库函数不会间接访问通过其参数（包括容器的其他元素）可访问的对象，除非其规范要求。
> 6. 在任何情况下，容器操作（以及算法或任何其他 C++ 标准库函数）都可以在内部并行化，只要这不会改变用户可见的结果（例如，[std::transform](https://cppreference.cn/w/cpp/algorithm/transform) 可以并行化，但 [std::for_each](https://cppreference.cn/w/cpp/algorithm/for_each) 不能，因为它被指定按顺序访问序列的每个元素）。

------



## 2. 容器分类总表

| 容器类型         | 容器名称             | 底层数据结构     | 特点                                                | 适用场景                   |
| ---------------- | -------------------- | ---------------- | --------------------------------------------------- | -------------------------- |
| **序列容器**     | `array`              | 固定大小数组     | 固定大小，快速随机访问                              | 需要固定大小数组时         |
|                  | `vector`             | 动态数组         | 动态扩容，快速随机访问                              | 需要动态数组，频繁随机访问 |
|                  | `deque`              | 双端队列         | 双端操作高效，随机访问较快                          | 需要双端操作的序列         |
|                  | `list`               | 双向链表         | 任意位置插入删除高效                                | 需要频繁在任意位置插入删除 |
|                  | `forward_list`       | 单向链表         | 更节省空间，单向遍历                                | 只需要单向遍历的链表       |
|                  | `bitset`             | 特化数组         | 存储位，支持位操作                                  | 需要高效位操作时           |
|                  | valarray             | 特化数组         | 数值高效运算，详细查看[第五章valarray](./数值库.md) | 需要快速数值运算时         |
| **关联容器**     | `set`                | 红黑树           | 键唯一，自动排序                                    | 需要有序唯一键集合         |
|                  | `multiset`           | 红黑树           | 键可重复，自动排序                                  | 需要有序可重复键集合       |
|                  | `map`                | 红黑树           | 键值对，键唯一，自动排序                            | 需要有序键值对映射         |
|                  | `multimap`           | 红黑树           | 键值对，键可重复，自动排序                          | 需要有序可重复键的映射     |
| **无序关联容器** | `unordered_set`      | 哈希表           | 键唯一，无序                                        | 需要快速查找的唯一键集合   |
|                  | `unordered_multiset` | 哈希表           | 键可重复，无序                                      | 需要快速查找的可重复键集合 |
|                  | `unordered_map`      | 哈希表           | 键值对，键唯一，无序                                | 需要快速查找的键值对映射   |
|                  | `unordered_multimap` | 哈希表           | 键值对，键可重复，无序                              | 需要快速查找的可重复键映射 |
| **容器适配器**   | `stack`              | 默认基于`deque`  | 后进先出(LIFO)                                      | 需要栈结构时               |
|                  | `queue`              | 默认基于`deque`  | 先进先出(FIFO)                                      | 需要队列结构时             |
|                  | `priority_queue`     | 默认基于`vector` | 优先级队列                                          | 需要按优先级处理元素时     |
| **伪容器**       | `string`             | 动态数组         | 专用于字符串操作                                    | 字符串处理                 |

------



## 3. 容器增删改查示例

## (1) 序列容器—增删改查操作—示例代码

### Ⅰ. vector

`vector` 是 C++ 标准库中最常用的动态数组容器，支持高效的随机访问和动态大小调整。以下是完整的 vector 增删改查操作示例：

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 用于find、sort等算法
using namespace std;

// 打印vector内容
template<typename T>
void printVector(const vector<T>& vec, const string& name = "vector") {
    cout << name << ": ";
    for (const auto& element : vec) {
        cout << element << " ";
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    vector<int> vec = {1, 2, 3, 4, 5};
    printVector(vec, "初始");
    
    // 2. 添加元素
    cout << "\n=== 添加元素 ===" << endl;
    vec.push_back(6); // 在末尾添加元素
    printVector(vec, "push_back(6)后");
    
    vec.insert(vec.begin() + 2, 99); // 在索引2位置插入元素
    printVector(vec, "在索引2插入99后");
    
    vector<int> additional = {100, 101, 102};
    vec.insert(vec.end(), additional.begin(), additional.end()); // 插入另一个vector的元素
    printVector(vec, "插入additional后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    cout << "第一个元素: " << vec.front() << endl;
    cout << "最后一个元素: " << vec.back() << endl;
    cout << "索引为3的元素: " << vec[3] << endl; // 不检查边界
    cout << "索引为3的元素: " << vec.at(3) << endl; // 检查边界，越界会抛出异常
    
    // 4. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    vec[1] = 20; // 修改第二个元素
    vec.at(2) = 30; // 修改第三个元素
    printVector(vec, "修改后");
    
    // 5. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    vec.pop_back(); // 删除最后一个元素
    printVector(vec, "pop_back()后");
    
    vec.erase(vec.begin() + 3); // 删除索引3的元素
    printVector(vec, "删除索引3后");
    
    vec.erase(vec.begin() + 1, vec.begin() + 3); // 删除范围[1, 3)的元素
    printVector(vec, "删除索引1到3后");
    
    // 删除所有值为100的元素
    vec.erase(remove(vec.begin(), vec.end(), 100), vec.end());
    printVector(vec, "删除所有100后");
    
    // 6. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int target = 5;
    auto it = find(vec.begin(), vec.end(), target);
    if (it != vec.end()) {
        cout << "找到元素 " << target << "，位置: " << distance(vec.begin(), it) << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 7. 容量操作
    cout << "\n=== 容量操作 ===" << endl;
    cout << "大小: " << vec.size() << endl;
    cout << "容量: " << vec.capacity() << endl;
    
    vec.shrink_to_fit(); // 减少容量以适应大小
    cout << "shrink_to_fit()后容量: " << vec.capacity() << endl;
    
    vec.reserve(20); // 预留容量
    cout << "reserve(20)后容量: " << vec.capacity() << endl;
    
    // 8. 清空vector
    cout << "\n=== 清空vector ===" << endl;
    vec.clear();
    cout << "清空后大小: " << vec.size() << endl;
    cout << "清空后容量: " << vec.capacity() << endl;
    
    // 9. 二维vector示例
    cout << "\n=== 二维vector示例 ===" << endl;
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    cout << "二维vector:" << endl;
    for (const auto& row : matrix) {
        for (const auto& element : row) {
            cout << element << " ";
        }
        cout << endl;
    }
    
    // 10. 使用迭代器遍历
    cout << "\n=== 使用迭代器遍历 ===" << endl;
    vector<int> nums = {10, 20, 30, 40, 50};
    cout << "使用迭代器: ";
    for (auto it = nums.begin(); it != nums.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 11. 排序和反转
    cout << "\n=== 排序和反转 ===" << endl;
    vector<int> unsorted = {5, 3, 8, 1, 9, 2};
    printVector(unsorted, "排序前");
    
    sort(unsorted.begin(), unsorted.end());
    printVector(unsorted, "排序后");
    
    reverse(unsorted.begin(), unsorted.end());
    printVector(unsorted, "反转后");
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `vector`

2. **添加元素**：
   - `push_back()`: 在末尾添加元素
   - `insert()`: 在指定位置插入元素或多个元素

3. **访问元素**：
   - `front()`/`back()`: 访问首尾元素
   - `[]` 运算符: 快速访问，不检查边界
   - `at()`: 安全访问，检查边界

4. **修改元素**：通过索引直接修改元素值

5. **删除元素**：
   - `pop_back()`: 删除末尾元素
   - `erase()`: 删除指定位置或范围的元素
   - `remove()` + `erase()`: 删除特定值的所有元素

6. **查找元素**：使用 `find()` 算法查找元素

7. **容量操作**：
   - `size()`: 获取元素数量
   - `capacity()`: 获取当前容量
   - `reserve()`: 预留容量
   - `shrink_to_fit()`: 减少容量以适应大小

8. **清空vector**：使用 `clear()` 清空所有元素

9. **二维vector**：展示如何创建和遍历二维vector

10. **迭代器遍历**：使用迭代器遍历vector

11. **排序和反转**：使用算法对vector进行排序和反转

#### vector 的特点

- **动态大小**：vector 可以动态增长和缩小
- **随机访问**：支持通过索引快速访问元素
- **内存连续**：元素在内存中连续存储，缓存友好
- **自动内存管理**：自动处理内存分配和释放

#### 性能考虑

- 在末尾添加/删除元素：O(1) 时间复杂度
- 在中间或开头添加/删除元素：O(n) 时间复杂度
- 随机访问元素：O(1) 时间复杂度
- 查找元素：O(n) 时间复杂度（除非已排序）

vector 是 C++ 中最通用和高效的容器之一，适用于大多数需要动态数组的场景。

### Ⅱ. array

`std::array` 是 C++11 引入的固定大小数组容器，提供了 STL 容器的接口，同时保持了传统数组的性能特性。由于是固定大小的，它不支持动态的添加和删除操作，但我们可以进行修改、查询和模拟相关操作。

```cpp
#include <iostream>
#include <array>
#include <algorithm> // 用于find、sort等算法
using namespace std;

// 打印array内容
template<typename T, size_t N>
void printArray(const array<T, N>& arr, const string& name = "array") {
    cout << name << ": ";
    for (const auto& element : arr) {
        cout << element << " ";
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    array<int, 5> arr = {1, 2, 3, 4, 5};
    printArray(arr, "初始");
    
    // 2. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    cout << "第一个元素: " << arr.front() << endl;
    cout << "最后一个元素: " << arr.back() << endl;
    cout << "索引为2的元素: " << arr[2] << endl; // 不检查边界
    cout << "索引为2的元素: " << arr.at(2) << endl; // 检查边界，越界会抛出异常
    
    // 使用get函数模板访问元素 (C++11起)
    cout << "索引为3的元素: " << get<3>(arr) << endl;
    
    // 3. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    arr[1] = 20; // 修改第二个元素
    arr.at(2) = 30; // 修改第三个元素
    get<3>(arr) = 40; // 修改第四个元素
    printArray(arr, "修改后");
    
    // 4. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "数组大小: " << arr.size() << endl;
    cout << "数组最大大小: " << arr.max_size() << endl; // 对于array，这与size()相同
    cout << "数组是否为空: " << (arr.empty() ? "是" : "否") << endl;
    
    // 5. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int target = 30;
    auto it = find(arr.begin(), arr.end(), target);
    if (it != arr.end()) {
        cout << "找到元素 " << target << "，位置: " << distance(arr.begin(), it) << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 6. 遍历array
    cout << "\n=== 遍历array ===" << endl;
    cout << "使用迭代器: ";
    for (auto it = arr.begin(); it != arr.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    cout << "使用反向迭代器: ";
    for (auto it = arr.rbegin(); it != arr.rend(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 7. 填充array
    cout << "\n=== 填充array ===" << endl;
    arr.fill(99); // 将所有元素设置为99
    printArray(arr, "填充后");
    
    // 8. 交换两个array的内容
    cout << "\n=== 交换array内容 ===" << endl;
    array<int, 5> arr1 = {1, 2, 3, 4, 5};
    array<int, 5> arr2 = {10, 20, 30, 40, 50};
    
    printArray(arr1, "arr1交换前");
    printArray(arr2, "arr2交换前");
    
    arr1.swap(arr2);
    
    printArray(arr1, "arr1交换后");
    printArray(arr2, "arr2交换后");
    
    // 9. 排序array
    cout << "\n=== 排序array ===" << endl;
    array<int, 7> unsorted = {5, 3, 8, 1, 9, 2, 7};
    printArray(unsorted, "排序前");
    
    sort(unsorted.begin(), unsorted.end());
    printArray(unsorted, "排序后");
    
    // 10. 多维array
    cout << "\n=== 多维array ===" << endl;
    array<array<int, 3>, 2> matrix = {{
        {1, 2, 3},
        {4, 5, 6}
    }};
    
    cout << "二维array:" << endl;
    for (const auto& row : matrix) {
        for (const auto& element : row) {
            cout << element << " ";
        }
        cout << endl;
    }
    
    // 11. 模拟"删除"操作 (通过移动元素并标记)
    cout << "\n=== 模拟删除操作 ===" << endl;
    array<int, 6> arrWithDelete = {1, 2, 3, 4, 5, 6};
    printArray(arrWithDelete, "原始数组");
    
    // 模拟删除索引2的元素
    size_t indexToRemove = 2;
    for (size_t i = indexToRemove; i < arrWithDelete.size() - 1; ++i) {
        arrWithDelete[i] = arrWithDelete[i + 1];
    }
    // 将最后一个元素设置为某个标记值（例如0）
    arrWithDelete[arrWithDelete.size() - 1] = 0;
    
    printArray(arrWithDelete, "模拟删除索引2后");
    
    // 12. 模拟"添加"操作 (需要有空位)
    cout << "\n=== 模拟添加操作 ===" << endl;
    array<int, 6> arrWithAdd = {1, 2, 3, 4, 0, 0}; // 最后两个位置为空
    printArray(arrWithAdd, "有空位的数组");
    
    // 在第一个空位添加元素
    for (size_t i = 0; i < arrWithAdd.size(); ++i) {
        if (arrWithAdd[i] == 0) { // 假设0表示空位
            arrWithAdd[i] = 99;
            break;
        }
    }
    
    printArray(arrWithAdd, "添加99后");
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `array`，必须指定大小

2. **访问元素**：
   - `front()`/`back()`: 访问首尾元素
   - `[]` 运算符: 快速访问，不检查边界
   - `at()`: 安全访问，检查边界
   - `get<N>()`: 模板函数访问特定位置的元素

3. **修改元素**：通过索引或迭代器修改元素值

4. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量（与size相同）
   - `empty()`: 检查是否为空

5. **查找元素**：使用 `find()` 算法查找元素

6. **遍历array**：
   - 使用正向迭代器
   - 使用反向迭代器

7. **填充array**：使用 `fill()` 方法将所有元素设置为指定值

8. **交换内容**：使用 `swap()` 方法交换两个相同大小array的内容

9. **排序array**：使用 `sort()` 算法对array进行排序

10. **多维array**：展示如何创建和遍历二维array

11. **模拟删除操作**：
    - 通过移动元素覆盖要删除的元素
    - 将最后一个位置设置为标记值

12. **模拟添加操作**：
    - 查找空位并添加新元素
    - 需要预先有空位

#### array 的特点

- **固定大小**：array 的大小在编译时确定，不能动态改变
- **内存连续**：元素在内存中连续存储，缓存友好
- **性能高效**：访问速度与原始数组相同
- **STL接口**：提供迭代器、size()等STL容器接口
- **安全性**：提供at()方法进行边界检查

#### 使用场景

- 当需要固定大小的容器时
- 当需要高性能的随机访问时
- 当需要STL容器接口但不想使用动态内存分配时
- 作为函数参数传递时（比原始数组更安全）

#### 注意事项

- array 不支持动态调整大小，所有操作都在固定容量内进行
- 模拟的"增删"操作实际上是通过移动元素实现的，不是真正的动态操作
- 对于需要动态大小的场景，应该使用 vector 或其他动态容器

array 是 C++11 中引入的一个有用的容器，它结合了原始数组的性能和 STL 容器的便利性。

### Ⅲ. deque

`std::deque`（双端队列）是 C++ 标准库中的一种序列容器，支持在两端高效地插入和删除元素，同时支持随机访问。以下是 deque 的增删改查操作示例：

```cpp
#include <iostream>
#include <deque>
#include <algorithm>
using namespace std;

// 打印deque内容
template<typename T>
void printDeque(const deque<T>& dq, const string& name = "deque") {
    cout << name << ": ";
    for (const auto& element : dq) {
        cout << element << " ";
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    deque<int> dq = {1, 2, 3, 4, 5};
    printDeque(dq, "初始");
    
    // 2. 在两端添加元素
    cout << "\n=== 在两端添加元素 ===" << endl;
    dq.push_front(0);  // 在开头添加元素
    dq.push_back(6);   // 在末尾添加元素
    printDeque(dq, "两端添加后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    cout << "第一个元素: " << dq.front() << endl;
    cout << "最后一个元素: " << dq.back() << endl;
    cout << "索引为3的元素: " << dq[3] << endl;        // 不检查边界
    cout << "索引为3的元素: " << dq.at(3) << endl;     // 检查边界，越界会抛出异常
    
    // 4. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    dq[1] = 20;        // 修改第二个元素
    dq.at(2) = 30;     // 修改第三个元素
    printDeque(dq, "修改后");
    
    // 5. 在任意位置插入元素
    cout << "\n=== 在任意位置插入元素 ===" << endl;
    auto it = dq.begin() + 3;
    dq.insert(it, 99);  // 在索引3位置插入元素
    printDeque(dq, "插入99后");
    
    dq.insert(dq.begin() + 2, 3, 88);  // 在索引2位置插入3个88
    printDeque(dq, "插入3个88后");
    
    vector<int> vec = {100, 101, 102};
    dq.insert(dq.end() - 1, vec.begin(), vec.end());  // 在倒数第二个位置插入vector的元素
    printDeque(dq, "插入vector后");
    
    // 6. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    dq.pop_front();     // 删除第一个元素
    dq.pop_back();      // 删除最后一个元素
    printDeque(dq, "删除首尾元素后");
    
    dq.erase(dq.begin() + 3);  // 删除索引3的元素
    printDeque(dq, "删除索引3后");
    
    dq.erase(dq.begin() + 2, dq.begin() + 5);  // 删除范围[2, 5)的元素
    printDeque(dq, "删除索引2到5后");
    
    // 删除所有值为88的元素
    dq.erase(remove(dq.begin(), dq.end(), 88), dq.end());
    printDeque(dq, "删除所有88后");
    
    // 7. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int target = 101;
    auto find_it = find(dq.begin(), dq.end(), target);
    if (find_it != dq.end()) {
        cout << "找到元素 " << target << "，位置: " << distance(dq.begin(), find_it) << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 8. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "deque大小: " << dq.size() << endl;
    cout << "deque最大大小: " << dq.max_size() << endl;
    cout << "deque是否为空: " << (dq.empty() ? "是" : "否") << endl;
    
    // 9. 清空deque
    cout << "\n=== 清空deque ===" << endl;
    dq.clear();
    cout << "清空后大小: " << dq.size() << endl;
    cout << "清空后是否为空: " << (dq.empty() ? "是" : "否") << endl;
    
    // 10. 重新填充并排序
    cout << "\n=== 重新填充并排序 ===" << endl;
    dq = {5, 3, 8, 1, 9, 2, 7};
    printDeque(dq, "排序前");
    
    sort(dq.begin(), dq.end());
    printDeque(dq, "排序后");
    
    // 11. 使用迭代器遍历
    cout << "\n=== 使用迭代器遍历 ===" << endl;
    cout << "正向遍历: ";
    for (auto it = dq.begin(); it != dq.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    cout << "反向遍历: ";
    for (auto it = dq.rbegin(); it != dq.rend(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 12. 交换两个deque的内容
    cout << "\n=== 交换deque内容 ===" << endl;
    deque<int> dq1 = {1, 2, 3};
    deque<int> dq2 = {10, 20, 30, 40};
    
    printDeque(dq1, "dq1交换前");
    printDeque(dq2, "dq2交换前");
    
    dq1.swap(dq2);
    
    printDeque(dq1, "dq1交换后");
    printDeque(dq2, "dq2交换后");
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `deque`

2. **在两端添加元素**：
   - `push_front()`: 在开头添加元素
   - `push_back()`: 在末尾添加元素

3. **访问元素**：
   - `front()`/`back()`: 访问首尾元素
   - `[]` 运算符: 快速访问，不检查边界
   - `at()`: 安全访问，检查边界

4. **修改元素**：通过索引或迭代器修改元素值

5. **在任意位置插入元素**：
   - `insert()`: 在指定位置插入单个元素、多个相同元素或其他容器的元素

6. **删除元素**：
   - `pop_front()`: 删除第一个元素
   - `pop_back()`: 删除最后一个元素
   - `erase()`: 删除指定位置或范围的元素
   - `remove()` + `erase()`: 删除特定值的所有元素

7. **查找元素**：使用 `find()` 算法查找元素

8. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空

9. **清空deque**：使用 `clear()` 清空所有元素

10. **排序deque**：使用 `sort()` 算法对deque进行排序

11. **使用迭代器遍历**：
    - 使用正向迭代器
    - 使用反向迭代器

12. **交换内容**：使用 `swap()` 方法交换两个deque的内容

#### deque 的特点

- **双端操作**：支持在两端高效地插入和删除元素
- **随机访问**：支持通过索引快速访问元素
- **动态大小**：可以动态增长和缩小
- **内存非连续**：元素在内存中可能不连续存储，但提供了类似连续存储的接口

#### 性能考虑

- 在开头和末尾添加/删除元素：O(1) 时间复杂度
- 在中间插入/删除元素：O(n) 时间复杂度
- 随机访问元素：O(1) 时间复杂度
- 查找元素：O(n) 时间复杂度（除非已排序）

#### 使用场景

- 需要频繁在序列两端添加或删除元素的场景
- 需要随机访问但又需要在开头高效插入的场景（vector只能在末尾高效插入）
- 作为队列和栈的基础数据结构（比queue和stack更灵活）

deque 是 C++ 中一个非常实用的容器，特别适合需要在序列两端进行操作的情况。它提供了 vector 的随机访问能力和 list 的双端操作能力，是一个很好的折中选择。

### Ⅳ. list

`std::list` 是 C++ 标准库中的双向链表容器，支持在任何位置高效地插入和删除元素，但不支持随机访问。以下是 list 的增删改查操作示例：

```cpp
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

// 打印list内容
template<typename T>
void printList(const list<T>& lst, const string& name = "list") {
    cout << name << ": ";
    for (const auto& element : lst) {
        cout << element << " ";
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    list<int> lst = {1, 2, 3, 4, 5};
    printList(lst, "初始");
    
    // 2. 在两端添加元素
    cout << "\n=== 在两端添加元素 ===" << endl;
    lst.push_front(0);  // 在开头添加元素
    lst.push_back(6);   // 在末尾添加元素
    printList(lst, "两端添加后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    cout << "第一个元素: " << lst.front() << endl;
    cout << "最后一个元素: " << lst.back() << endl;
    
    // 注意：list不支持随机访问，不能使用[]或at()
    // cout << "索引为3的元素: " << lst[3] << endl; // 错误！
    
    // 4. 在任意位置插入元素
    cout << "\n=== 在任意位置插入元素 ===" << endl;
    auto it = next(lst.begin(), 3); // 获取指向第4个元素的迭代器
    lst.insert(it, 99);  // 在指定位置插入元素
    printList(lst, "插入99后");
    
    lst.insert(lst.begin(), 3, 88);  // 在开头插入3个88
    printList(lst, "插入3个88后");
    
    vector<int> vec = {100, 101, 102};
    it = next(lst.begin(), 5);
    lst.insert(it, vec.begin(), vec.end());  // 在指定位置插入vector的元素
    printList(lst, "插入vector后");
    
    // 5. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    it = next(lst.begin(), 2);
    *it = 77;  // 修改第三个元素
    printList(lst, "修改第三个元素后");
    
    // 6. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    lst.pop_front();     // 删除第一个元素
    lst.pop_back();      // 删除最后一个元素
    printList(lst, "删除首尾元素后");
    
    it = next(lst.begin(), 3);
    lst.erase(it);  // 删除指定位置的元素
    printList(lst, "删除第四个元素后");
    
    it = next(lst.begin(), 2);
    auto it2 = next(lst.begin(), 5);
    lst.erase(it, it2);  // 删除范围[2, 5)的元素
    printList(lst, "删除范围元素后");
    
    // 删除所有值为88的元素
    lst.remove(88);
    printList(lst, "删除所有88后");
    
    // 7. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int target = 101;
    auto find_it = find(lst.begin(), lst.end(), target);
    if (find_it != lst.end()) {
        cout << "找到元素 " << target << endl;
        // 由于list不支持随机访问，不能直接计算位置
        // 但可以计算距离（需要遍历，效率较低）
        int pos = distance(lst.begin(), find_it);
        cout << "位置: " << pos << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 8. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "list大小: " << lst.size() << endl;
    cout << "list最大大小: " << lst.max_size() << endl;
    cout << "list是否为空: " << (lst.empty() ? "是" : "否") << endl;
    
    // 9. 清空list
    cout << "\n=== 清空list ===" << endl;
    lst.clear();
    cout << "清空后大小: " << lst.size() << endl;
    cout << "清空后是否为空: " << (lst.empty() ? "是" : "否") << endl;
    
    // 10. 重新填充并排序
    cout << "\n=== 重新填充并排序 ===" << endl;
    lst = {5, 3, 8, 1, 9, 2, 7};
    printList(lst, "排序前");
    
    lst.sort();  // list有自己的sort方法
    printList(lst, "排序后");
    
    // 11. 使用迭代器遍历
    cout << "\n=== 使用迭代器遍历 ===" << endl;
    cout << "正向遍历: ";
    for (auto it = lst.begin(); it != lst.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    cout << "反向遍历: ";
    for (auto it = lst.rbegin(); it != lst.rend(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 12. 交换两个list的内容
    cout << "\n=== 交换list内容 ===" << endl;
    list<int> lst1 = {1, 2, 3};
    list<int> lst2 = {10, 20, 30, 40};
    
    printList(lst1, "lst1交换前");
    printList(lst2, "lst2交换前");
    
    lst1.swap(lst2);
    
    printList(lst1, "lst1交换后");
    printList(lst2, "lst2交换后");
    
    // 13. 合并两个排序的list
    cout << "\n=== 合并两个排序的list ===" << endl;
    list<int> listA = {1, 3, 5, 7};
    list<int> listB = {2, 4, 6, 8};
    
    printList(listA, "listA");
    printList(listB, "listB");
    
    listA.merge(listB);  // 合并后listB为空
    printList(listA, "合并后listA");
    printList(listB, "合并后listB");
    
    // 14. 去重操作
    cout << "\n=== 去重操作 ===" << endl;
    list<int> dupList = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
    printList(dupList, "去重前");
    
    dupList.unique();  // 删除连续重复的元素
    printList(dupList, "去重后");
    
    // 15. 反转list
    cout << "\n=== 反转list ===" << endl;
    list<int> reverseList = {1, 2, 3, 4, 5};
    printList(reverseList, "反转前");
    
    reverseList.reverse();
    printList(reverseList, "反转后");
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `list`

2. **在两端添加元素**：
   - `push_front()`: 在开头添加元素
   - `push_back()`: 在末尾添加元素

3. **访问元素**：
   - `front()`: 访问第一个元素
   - `back()`: 访问最后一个元素
   - 注意：list 不支持随机访问，不能使用 `[]` 或 `at()`

4. **在任意位置插入元素**：
   - `insert()`: 在指定位置插入单个元素、多个相同元素或其他容器的元素

5. **修改元素**：通过迭代器修改元素值

6. **删除元素**：
   - `pop_front()`: 删除第一个元素
   - `pop_back()`: 删除最后一个元素
   - `erase()`: 删除指定位置或范围的元素
   - `remove()`: 删除所有等于特定值的元素

7. **查找元素**：使用 `find()` 算法查找元素

8. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空

9. **清空list**：使用 `clear()` 清空所有元素

10. **排序list**：使用 `sort()` 方法对list进行排序

11. **使用迭代器遍历**：
    - 使用正向迭代器
    - 使用反向迭代器

12. **交换内容**：使用 `swap()` 方法交换两个list的内容

13. **合并list**：使用 `merge()` 方法合并两个已排序的list

14. **去重操作**：使用 `unique()` 方法删除连续重复的元素

15. **反转list**：使用 `reverse()` 方法反转list中的元素顺序

#### list 的特点

- **双向链表**：每个元素包含指向前后元素的指针
- **高效插入删除**：在任何位置插入和删除元素的时间复杂度都是 O(1)
- **不支持随机访问**：不能通过索引直接访问元素，需要遍历
- **内存非连续**：元素在内存中非连续存储
- **额外内存开销**：每个元素需要额外的指针空间

#### 性能考虑

- 在任何位置插入/删除元素：O(1) 时间复杂度
- 访问元素：O(n) 时间复杂度（需要遍历）
- 查找元素：O(n) 时间复杂度
- 排序：O(n log n) 时间复杂度（使用自己的sort方法）

#### 使用场景

- 需要频繁在序列中间插入或删除元素的场景
- 不需要随机访问元素的场景
- 需要实现队列、栈或双向队列的场景
- 当元素较大且移动成本高时（list只需修改指针）

list 是 C++ 中一个非常有用的容器，特别适合需要在序列中间频繁操作的情况。虽然它不支持随机访问，但在插入和删除操作上具有极高的效率。

### Ⅴ. forward_list

`std::forward_list` 是 C++11 引入的单向链表容器，只支持前向遍历，比 `std::list` 更节省内存，但功能相对较少。以下是 forward_list 的增删改查操作示例：

```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>
using namespace std;

// 打印forward_list内容
template<typename T>
void printForwardList(const forward_list<T>& flst, const string& name = "forward_list") {
    cout << name << ": ";
    for (const auto& element : flst) {
        cout << element << " ";
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    forward_list<int> flst = {1, 2, 3, 4, 5};
    printForwardList(flst, "初始");
    
    // 2. 在开头添加元素
    cout << "\n=== 在开头添加元素 ===" << endl;
    flst.push_front(0);  // 在开头添加元素
    printForwardList(flst, "添加0后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    cout << "第一个元素: " << flst.front() << endl;
    
    // 注意：forward_list只支持访问第一个元素，不支持直接访问其他元素
    // 也没有back()方法，因为无法高效获取最后一个元素
    
    // 4. 在指定位置后插入元素
    cout << "\n=== 在指定位置后插入元素 ===" << endl;
    auto it = flst.begin();
    advance(it, 2); // 移动到第三个位置
    flst.insert_after(it, 99);  // 在第三个元素后插入99
    printForwardList(flst, "插入99后");
    
    flst.insert_after(flst.before_begin(), 3, 88);  // 在开头插入3个88
    printForwardList(flst, "插入3个88后");
    
    vector<int> vec = {100, 101, 102};
    it = flst.begin();
    advance(it, 4);
    flst.insert_after(it, vec.begin(), vec.end());  // 在指定位置后插入vector的元素
    printForwardList(flst, "插入vector后");
    
    // 5. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    it = flst.begin();
    advance(it, 3);
    *it = 77;  // 修改第四个元素
    printForwardList(flst, "修改第四个元素后");
    
    // 6. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    flst.pop_front();     // 删除第一个元素
    printForwardList(flst, "删除第一个元素后");
    
    it = flst.begin();
    advance(it, 2);
    flst.erase_after(it);  // 删除指定位置后的元素
    printForwardList(flst, "删除第三个元素后的元素");
    
    it = flst.begin();
    auto it2 = flst.begin();
    advance(it2, 4);
    flst.erase_after(it, it2);  // 删除范围(it, it2)的元素
    printForwardList(flst, "删除范围元素后");
    
    // 删除所有值为88的元素
    flst.remove(88);
    printForwardList(flst, "删除所有88后");
    
    // 7. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int target = 101;
    auto find_it = find(flst.begin(), flst.end(), target);
    if (find_it != flst.end()) {
        cout << "找到元素 " << target << endl;
        // 计算位置（需要遍历，效率较低）
        int pos = distance(flst.begin(), find_it);
        cout << "位置: " << pos << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 8. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "forward_list是否为空: " << (flst.empty() ? "是" : "否") << endl;
    
    // forward_list没有size()方法，因为计算大小需要O(n)时间
    // 但我们可以手动计算
    int size = distance(flst.begin(), flst.end());
    cout << "forward_list大小: " << size << endl;
    
    // 9. 清空forward_list
    cout << "\n=== 清空forward_list ===" << endl;
    flst.clear();
    cout << "清空后是否为空: " << (flst.empty() ? "是" : "否") << endl;
    
    // 10. 重新填充并排序
    cout << "\n=== 重新填充并排序 ===" << endl;
    flst = {5, 3, 8, 1, 9, 2, 7};
    printForwardList(flst, "排序前");
    
    flst.sort();  // forward_list有自己的sort方法
    printForwardList(flst, "排序后");
    
    // 11. 使用迭代器遍历
    cout << "\n=== 使用迭代器遍历 ===" << endl;
    cout << "正向遍历: ";
    for (auto it = flst.begin(); it != flst.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 注意：forward_list不支持反向遍历，因为没有反向迭代器
    
    // 12. 交换两个forward_list的内容
    cout << "\n=== 交换forward_list内容 ===" << endl;
    forward_list<int> flst1 = {1, 2, 3};
    forward_list<int> flst2 = {10, 20, 30, 40};
    
    printForwardList(flst1, "flst1交换前");
    printForwardList(flst2, "flst2交换前");
    
    flst1.swap(flst2);
    
    printForwardList(flst1, "flst1交换后");
    printForwardList(flst2, "flst2交换后");
    
    // 13. 合并两个排序的forward_list
    cout << "\n=== 合并两个排序的forward_list ===" << endl;
    forward_list<int> flstA = {1, 3, 5, 7};
    forward_list<int> flstB = {2, 4, 6, 8};
    
    printForwardList(flstA, "flstA");
    printForwardList(flstB, "flstB");
    
    flstA.merge(flstB);  // 合并后flstB为空
    printForwardList(flstA, "合并后flstA");
    printForwardList(flstB, "合并后flstB");
    
    // 14. 去重操作
    cout << "\n=== 去重操作 ===" << endl;
    forward_list<int> dupFlist = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
    printForwardList(dupFlist, "去重前");
    
    dupFlist.unique();  // 删除连续重复的元素
    printForwardList(dupFlist, "去重后");
    
    // 15. 在指定位置前插入元素（需要使用before_begin）
    cout << "\n=== 在指定位置前插入元素 ===" << endl;
    forward_list<int> customList = {10, 20, 30, 40};
    printForwardList(customList, "原始列表");
    
    // 在第一个元素前插入（即开头）
    customList.insert_after(customList.before_begin(), 5);
    printForwardList(customList, "在开头插入5后");
    
    // 在第二个元素后插入（即在第二个和第三个元素之间插入）
    auto pos = customList.begin();
    advance(pos, 1);
    customList.insert_after(pos, 25);
    printForwardList(customList, "在20后插入25后");
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `forward_list`

2. **在开头添加元素**：
   - `push_front()`: 在开头添加元素

3. **访问元素**：
   - `front()`: 访问第一个元素
   - 注意：forward_list 只支持访问第一个元素，不支持直接访问其他元素

4. **在指定位置后插入元素**：
   - `insert_after()`: 在指定位置后插入单个元素、多个相同元素或其他容器的元素

5. **修改元素**：通过迭代器修改元素值

6. **删除元素**：
   - `pop_front()`: 删除第一个元素
   - `erase_after()`: 删除指定位置后的元素或范围
   - `remove()`: 删除所有等于特定值的元素

7. **查找元素**：使用 `find()` 算法查找元素

8. **查询信息**：
   - `empty()`: 检查是否为空
   - 注意：forward_list 没有 `size()` 方法，因为计算大小需要 O(n) 时间

9. **清空forward_list**：使用 `clear()` 清空所有元素

10. **排序forward_list**：使用 `sort()` 方法对forward_list进行排序

11. **使用迭代器遍历**：只能使用正向迭代器遍历

12. **交换内容**：使用 `swap()` 方法交换两个forward_list的内容

13. **合并forward_list**：使用 `merge()` 方法合并两个已排序的forward_list

14. **去重操作**：使用 `unique()` 方法删除连续重复的元素

15. **在指定位置前插入元素**：使用 `before_begin()` 和 `insert_after()` 在指定位置前插入元素

#### forward_list 的特点

- **单向链表**：每个元素只包含指向下一个元素的指针
- **内存效率高**：比双向链表节省内存（每个节点少一个指针）
- **只支持前向遍历**：不能反向遍历
- **高效插入删除**：在已知位置插入和删除元素的时间复杂度是 O(1)
- **不支持随机访问**：不能通过索引直接访问元素，需要遍历
- **没有size()方法**：计算大小需要 O(n) 时间

#### 性能考虑

- 在开头插入/删除元素：O(1) 时间复杂度
- 在指定位置后插入/删除元素：O(1) 时间复杂度
- 访问元素：O(n) 时间复杂度（需要遍历）
- 查找元素：O(n) 时间复杂度
- 排序：O(n log n) 时间复杂度（使用自己的sort方法）

#### 使用场景

- 需要极简内存占用的场景
- 只需要前向遍历的场景
- 需要频繁在序列中插入或删除元素的场景
- 不需要知道容器大小的场景
- 实现栈或单链表的场景

forward_list 是 C++ 中一个轻量级的容器，特别适合对内存占用有严格要求的场景。虽然它的功能比 list 少，但在某些情况下可以提供更好的性能。

### Ⅵ. [valarray](./数值库.md)

`valarray` 是 C++ 标准库中用于高效数值计算的容器，但它不像 `vector` 那样支持动态的增删操作。不过我们可以通过一些技巧来模拟这些操作。

```cpp
#include <iostream>
#include <valarray>
#include <algorithm>
#include <vector>
using namespace std;

// 打印 valarray 内容
template<typename T>
void printValarray(const valarray<T>& va, const string& name = "valarray") {
    cout << name << ": ";
    for (size_t i = 0; i < va.size(); ++i) {
        cout << va[i] << " ";
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    valarray<int> va = {1, 2, 3, 4, 5};
    printValarray(va, "初始");
    
    // 2. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    va[1] = 20; // 修改第二个元素
    va[va.size()-1] = 50; // 修改最后一个元素
    printValarray(va, "修改后");
    
    // 3. 查询元素
    cout << "\n=== 查询元素 ===" << endl;
    cout << "第一个元素: " << va[0] << endl;
    cout << "第二个元素: " << va[1] << endl;
    cout << "最后一个元素: " << va[va.size()-1] << endl;
    
    // 4. 模拟"删除"操作 - 通过切片移除特定元素
    cout << "\n=== 模拟删除操作 ===" << endl;
    size_t indexToRemove = 2; // 要删除的索引
    if (indexToRemove < va.size()) {
        // 创建两个切片：删除点前和删除点后
        valarray<int> part1 = va[slice(0, indexToRemove, 1)];
        valarray<int> part2 = va[slice(indexToRemove + 1, va.size() - indexToRemove - 1, 1)];
        
        // 合并两部分
        valarray<int> newVa(part1.size() + part2.size());
        copy(begin(part1), end(part1), begin(newVa));
        copy(begin(part2), end(part2), begin(newVa) + part1.size());
        
        va = newVa;
        printValarray(va, "删除索引2后");
    }
    
    // 5. 模拟"添加"操作 - 在末尾添加元素
    cout << "\n=== 模拟添加操作 ===" << endl;
    int valueToAdd = 100;
    
    // 创建新数组，大小增加1
    valarray<int> temp(va.size() + 1);
    copy(begin(va), end(va), begin(temp));
    temp[temp.size() - 1] = valueToAdd;
    va = temp;
    
    printValarray(va, "添加100后");
    
    // 6. 使用切片进行批量操作
    cout << "\n=== 切片操作 ===" << endl;
    valarray<int> va2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    printValarray(va2, "原始数组");
    
    // 获取前5个元素
    valarray<int> firstHalf = va2[slice(0, 5, 1)];
    printValarray(firstHalf, "前5个元素");
    
    // 获取偶数索引元素
    valarray<int> evenIndices = va2[slice(0, 5, 2)];
    printValarray(evenIndices, "偶数索引元素");
    
    // 7. 条件查询
    cout << "\n=== 条件查询 ===" << endl;
    valarray<bool> condition = va2 > 5;
    cout << "大于5的元素: ";
    for (size_t i = 0; i < va2.size(); ++i) {
        if (condition[i]) {
            cout << va2[i] << " ";
        }
    }
    cout << endl;
    
    // 8. 数学运算
    cout << "\n=== 数学运算 ===" << endl;
    valarray<int> squared = va2 * va2;
    printValarray(squared, "平方值");
    
    va2 += 10; // 所有元素加10
    printValarray(va2, "所有元素加10后");
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `valarray`

2. **修改元素**：通过索引直接修改特定位置的元素

3. **查询元素**：使用索引访问特定位置的元素

4. **模拟删除操作**：
   - 使用 `slice` 创建不包含要删除元素的两个部分
   - 合并这两部分到新的 `valarray`

5. **模拟添加操作**：
   - 创建比原数组大1的新数组
   - 复制原数组内容并添加新元素

6. **切片操作**：使用 `slice(start, size, stride)` 进行批量操作

7. **条件查询**：使用条件表达式筛选元素

8. **数学运算**：`valarray` 支持向量化数学运算

#### 注意事项

- `valarray` 设计用于数值计算，不支持像 `vector` 那样的动态增删
- 上述"增删"操作是通过创建新数组实现的，有一定性能开销
- 对于需要频繁增删的场景，建议使用 `vector` 或其他容器

这个示例展示了如何在 `valarray` 上实现类似增删改查的操作，尽管这不是 `valarray` 的主要设计目的。

### Ⅶ. bitset

`std::bitset` 是 C++ 标准库中的固定大小位序列容器，它提供了一系列方法来操作位。bitset 的大小在编译时确定，因此不支持动态调整大小。以下是 bitset 的增删改查操作示例：

```cpp
#include <iostream>
#include <bitset>
#include <string>
using namespace std;

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    bitset<8> b1; // 8位的bitset，所有位初始化为0
    bitset<8> b2(0b10101010); // 从二进制字面量初始化
    bitset<8> b3(0xAA); // 从十六进制初始化
    bitset<8> b4(string("10101010")); // 从字符串初始化
    
    cout << "b1: " << b1 << endl;
    cout << "b2: " << b2 << endl;
    cout << "b3: " << b3 << endl;
    cout << "b4: " << b4 << endl;
    
    // 2. 设置位（增/改）
    cout << "\n=== 设置位（增/改） ===" << endl;
    b1.set(); // 将所有位设置为1
    cout << "b1.set(): " << b1 << endl;
    
    b1.reset(); // 将所有位设置为0
    cout << "b1.reset(): " << b1 << endl;
    
    b1.set(3); // 将第3位（从0开始）设置为1
    cout << "b1.set(3): " << b1 << endl;
    
    b1.set(5, true); // 将第5位设置为1
    cout << "b1.set(5, true): " << b1 << endl;
    
    b1.set(3, false); // 将第3位设置为0
    cout << "b1.set(3, false): " << b1 << endl;
    
    b1.flip(); // 翻转所有位
    cout << "b1.flip(): " << b1 << endl;
    
    b1.flip(5); // 翻转第5位
    cout << "b1.flip(5): " << b1 << endl;
    
    // 3. 访问位（查）
    cout << "\n=== 访问位（查） ===" << endl;
    bitset<8> b5(0b10101010);
    cout << "b5: " << b5 << endl;
    
    cout << "第0位: " << b5[0] << endl;
    cout << "第1位: " << b5[1] << endl;
    cout << "第2位: " << b5[2] << endl;
    
    cout << "使用test()方法:" << endl;
    for (size_t i = 0; i < b5.size(); ++i) {
        cout << "位" << i << ": " << b5.test(i) << endl;
    }
    
    cout << "所有位是否都为1: " << b5.all() << endl;
    cout << "是否有位为1: " << b5.any() << endl;
    cout << "是否所有位都为0: " << b5.none() << endl;
    
    // 4. 计数和大小
    cout << "\n=== 计数和大小 ===" << endl;
    cout << "b5中1的个数: " << b5.count() << endl;
    cout << "b5的大小: " << b5.size() << endl;
    
    // 5. 位运算
    cout << "\n=== 位运算 ===" << endl;
    bitset<8> b6(0b11001100);
    bitset<8> b7(0b10101010);
    
    cout << "b6: " << b6 << endl;
    cout << "b7: " << b7 << endl;
    
    cout << "b6 AND b7: " << (b6 & b7) << endl;
    cout << "b6 OR b7: " << (b6 | b7) << endl;
    cout << "b6 XOR b7: " << (b6 ^ b7) << endl;
    cout << "NOT b6: " << (~b6) << endl;
    
    // 6. 移位操作
    cout << "\n=== 移位操作 ===" << endl;
    bitset<8> b8(0b00001111);
    cout << "b8: " << b8 << endl;
    
    cout << "b8左移2位: " << (b8 << 2) << endl;
    cout << "b8右移2位: " << (b8 >> 2) << endl;
    
    // 7. 转换操作
    cout << "\n=== 转换操作 ===" << endl;
    bitset<8> b9(0b10101010);
    cout << "b9: " << b9 << endl;
    
    cout << "转换为unsigned long: " << b9.to_ulong() << endl;
    cout << "转换为unsigned long long: " << b9.to_ullong() << endl;
    cout << "转换为字符串: " << b9.to_string() << endl;
    
    // 添加前缀的字符串转换
    cout << "转换为带前缀的字符串: " << b9.to_string('0', '1') << endl;
    cout << "转换为带不同字符的字符串: " << b9.to_string('-', '*') << endl;
    
    // 8. 访问和修改特定位
    cout << "\n=== 访问和修改特定位 ===" << endl;
    bitset<8> b10;
    cout << "初始b10: " << b10 << endl;
    
    // 使用下标运算符访问和修改位
    b10[0] = 1;
    b10[2] = 1;
    b10[4] = 1;
    b10[6] = 1;
    cout << "修改后的b10: " << b10 << endl;
    
    // 9. 比较操作
    cout << "\n=== 比较操作 ===" << endl;
    bitset<8> b11(0b10101010);
    bitset<8> b12(0b10101010);
    bitset<8> b13(0b01010101);
    
    cout << "b11: " << b11 << endl;
    cout << "b12: " << b12 << endl;
    cout << "b13: " << b13 << endl;
    
    cout << "b11 == b12: " << (b11 == b12) << endl;
    cout << "b11 == b13: " << (b11 == b13) << endl;
    cout << "b11 != b13: " << (b11 != b13) << endl;
    
    // 10. 实用示例：权限管理系统
    cout << "\n=== 实用示例：权限管理系统 ===" << endl;
    enum Permissions {
        READ = 0,    // 第0位：读权限
        WRITE = 1,   // 第1位：写权限
        EXECUTE = 2, // 第2位：执行权限
        DELETE = 3   // 第3位：删除权限
    };
    
    bitset<4> userPermissions(0); // 4位bitset表示用户权限
    
    // 设置权限
    userPermissions.set(READ);
    userPermissions.set(WRITE);
    
    cout << "用户权限: " << userPermissions << endl;
    
    // 检查权限
    cout << "是否有读权限: " << userPermissions.test(READ) << endl;
    cout << "是否有写权限: " << userPermissions.test(WRITE) << endl;
    cout << "是否有执行权限: " << userPermissions.test(EXECUTE) << endl;
    cout << "是否有删除权限: " << userPermissions.test(DELETE) << endl;
    
    // 添加权限
    userPermissions.set(EXECUTE);
    cout << "添加执行权限后: " << userPermissions << endl;
    
    // 移除权限
    userPermissions.reset(WRITE);
    cout << "移除写权限后: " << userPermissions << endl;
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：
   - 使用默认构造函数创建全0的bitset
   - 从二进制、十六进制字面量初始化
   - 从字符串初始化

2. **设置位（增/改）**：
   - `set()`: 将所有位设置为1或指定位置设置为1/0
   - `reset()`: 将所有位设置为0或指定位置设置为0
   - `flip()`: 翻转所有位或指定位

3. **访问位（查）**：
   - 使用下标运算符 `[]` 访问特定位
   - 使用 `test()` 方法访问特定位（带边界检查）
   - 使用 `all()`, `any()`, `none()` 检查位状态

4. **计数和大小**：
   - `count()`: 统计设置为1的位的数量
   - `size()`: 获取bitset的大小

5. **位运算**：
   - 支持与(`&`)、或(`|`)、异或(`^`)、非(`~`)等位运算

6. **移位操作**：
   - 支持左移(`<<`)和右移(`>>`)操作

7. **转换操作**：
   - `to_ulong()`: 转换为unsigned long
   - `to_ullong()`: 转换为unsigned long long
   - `to_string()`: 转换为字符串，可以指定0和1的替代字符

8. **访问和修改特定位**：
   - 使用下标运算符访问和修改特定位

9. **比较操作**：
   - 支持相等(`==`)和不相等(`!=`)比较

10. **实用示例：权限管理系统**：
    - 使用bitset实现简单的权限管理系统

#### bitset 的特点

- **固定大小**：bitset的大小在编译时确定，不能动态调整
- **高效存储**：每个位只占1位存储空间，非常节省内存
- **位操作**：提供了丰富的位操作方法
- **类型安全**：比直接使用位运算符更安全
- **转换功能**：可以转换为数值类型和字符串

#### 性能考虑

- 位操作：所有位操作都是常数时间复杂度 O(1)
- 计数操作：`count()` 方法的实现可能使用查表法，效率很高
- 转换操作：转换到数值类型或字符串需要遍历所有位

#### 使用场景

- 权限管理系统
- 标志位集合
- 位掩码操作
- 状态机实现
- 压缩存储布尔值数组

#### 注意事项

- bitset的大小必须在编译时确定
- 访问位时使用 `test()` 方法比使用下标运算符更安全，因为会进行边界检查
- 转换为数值类型时，如果bitset的值太大无法表示，会抛出异常
- bitset不支持动态调整大小，如果需要动态位集合，可以考虑 `std::vector<bool>`

#### 与 vector<bool> 的比较

- `bitset` 是固定大小的，编译时确定大小
- `vector<bool>` 是动态大小的，运行时可以调整
- `bitset` 通常更节省内存，因为专门为位存储优化
- `vector<bool>` 提供更多的容器操作（如插入、删除）

bitset 是 C++ 中一个非常有用的类，特别适合需要高效存储和操作位集合的场景。它提供了丰富的API和类型安全性，是处理位操作的理想选择。

------



## (2) 关联容器—增删改查操作—示例代码

### Ⅰ. set

`std::set` 是 C++ 标准库中的关联容器，包含唯一键的排序集合。set 中的元素自动排序，并且每个元素都是唯一的。以下是 set 的增删改查操作示例：

```cpp
#include <iostream>
#include <set>
#include <algorithm>
using namespace std;

// 打印set内容
template<typename T>
void printSet(const set<T>& s, const string& name = "set") {
    cout << name << ": ";
    for (const auto& element : s) {
        cout << element << " ";
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    set<int> s = {5, 3, 8, 1, 9, 2, 7};
    printSet(s, "初始");
    
    // 2. 添加元素
    cout << "\n=== 添加元素 ===" << endl;
    s.insert(4);  // 插入单个元素
    printSet(s, "插入4后");
    
    s.insert(3);  // 尝试插入已存在的元素（不会重复插入）
    printSet(s, "再次插入3后");
    
    vector<int> vec = {10, 6, 11};
    s.insert(vec.begin(), vec.end());  // 插入范围元素
    printSet(s, "插入vector元素后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    // set不支持随机访问，但可以通过迭代器访问
    if (!s.empty()) {
        cout << "第一个元素: " << *s.begin() << endl;
        cout << "最后一个元素: " << *s.rbegin() << endl;
    }
    
    // 4. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int target = 7;
    auto it = s.find(target);
    if (it != s.end()) {
        cout << "找到元素 " << target << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 使用count方法检查元素是否存在
    target = 15;
    if (s.count(target) > 0) {
        cout << "找到元素 " << target << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 查找上下界
    cout << "大于等于6的第一个元素: " << *s.lower_bound(6) << endl;
    cout << "大于6的第一个元素: " << *s.upper_bound(6) << endl;
    
    // 5. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    s.erase(4);  // 删除值为4的元素
    printSet(s, "删除4后");
    
    it = s.find(6);
    if (it != s.end()) {
        s.erase(it);  // 通过迭代器删除元素
        printSet(s, "删除6后");
    }
    
    // 删除一定范围内的元素
    auto first = s.find(7);
    auto last = s.find(10);
    if (first != s.end() && last != s.end()) {
        s.erase(first, last);  // 删除[7, 10)范围的元素
        printSet(s, "删除7到10范围后");
    }
    
    // 6. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    // set中的元素是常量，不能直接修改
    // 需要先删除旧元素，再插入新元素
    int oldValue = 2;
    int newValue = 20;
    
    it = s.find(oldValue);
    if (it != s.end()) {
        s.erase(it);
        s.insert(newValue);
        printSet(s, "修改2为20后");
    }
    
    // 7. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "set大小: " << s.size() << endl;
    cout << "set最大大小: " << s.max_size() << endl;
    cout << "set是否为空: " << (s.empty() ? "是" : "否") << endl;
    
    // 8. 清空set
    cout << "\n=== 清空set ===" << endl;
    s.clear();
    cout << "清空后大小: " << s.size() << endl;
    cout << "清空后是否为空: " << (s.empty() ? "是" : "否") << endl;
    
    // 9. 重新填充并遍历
    cout << "\n=== 重新填充并遍历 ===" << endl;
    s = {15, 12, 18, 11, 19, 13, 17};
    printSet(s, "重新填充后");
    
    cout << "正向遍历: ";
    for (auto it = s.begin(); it != s.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    cout << "反向遍历: ";
    for (auto it = s.rbegin(); it != s.rend(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 10. 交换两个set的内容
    cout << "\n=== 交换set内容 ===" << endl;
    set<int> s1 = {1, 2, 3};
    set<int> s2 = {10, 20, 30, 40};
    
    printSet(s1, "s1交换前");
    printSet(s2, "s2交换前");
    
    s1.swap(s2);
    
    printSet(s1, "s1交换后");
    printSet(s2, "s2交换后");
    
    // 11. 自定义比较函数的set
    cout << "\n=== 自定义比较函数的set ===" << endl;
    // 降序排列的set
    set<int, greater<int>> descendingSet = {5, 3, 8, 1, 9, 2, 7};
    
    cout << "降序set: ";
    for (const auto& element : descendingSet) {
        cout << element << " ";
    }
    cout << endl;
    
    // 12. 使用emplace方法添加元素
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    set<pair<int, string>> pairSet;
    pairSet.emplace(1, "one");
    pairSet.emplace(2, "two");
    pairSet.emplace(3, "three");
    
    cout << "pair set: ";
    for (const auto& p : pairSet) {
        cout << "(" << p.first << ", " << p.second << ") ";
    }
    cout << endl;
    
    // 13. 合并集合
    std::set<int> src {1, 3, 5};
    std::set<int> dst {2, 4, 5};
    dst.merge(src);
    // src == { 5 }
    // dst == { 1, 2, 3, 4, 5 }
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `set`

2. **添加元素**：
   - `insert()`: 插入单个元素或范围元素
   - 尝试插入已存在的元素会被忽略（因为set元素必须唯一）

3. **访问元素**：
   - `begin()`: 获取指向第一个元素的迭代器
   - `rbegin()`: 获取指向最后一个元素的反向迭代器
   - 注意：set 不支持随机访问，不能使用 `[]` 或 `at()`

4. **查找元素**：
   - `find()`: 查找指定元素，返回迭代器
   - `count()`: 检查元素是否存在（返回0或1）
   - `lower_bound()`: 返回指向不小于给定值的第一个元素的迭代器
   - `upper_bound()`: 返回指向大于给定值的第一个元素的迭代器

5. **删除元素**：
   - `erase()`: 删除指定值、迭代器或范围的元素

6. **修改元素**：
   - set 中的元素是常量，不能直接修改
   - 需要先删除旧元素，再插入新元素

7. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空

8. **清空set**：使用 `clear()` 清空所有元素

9. **遍历set**：
   - 使用正向迭代器
   - 使用反向迭代器

10. **交换内容**：使用 `swap()` 方法交换两个set的内容

11. **自定义比较函数**：可以创建降序排列的set或其他自定义排序规则的set

12. **使用emplace方法**：使用 `emplace()` 方法直接构造并插入元素

13. **合并集合**：使用`merge()`方法合并集合

#### set 的特点

- **唯一键**：set 中的每个元素都是唯一的
- **自动排序**：元素按照键值自动排序
- **不可修改元素**：set 中的元素是常量，不能直接修改
- **高效查找**：基于红黑树实现，查找时间复杂度为 O(log n)
- **不支持随机访问**：不能通过索引直接访问元素

#### 性能考虑

- 插入元素：O(log n) 时间复杂度
- 删除元素：O(log n) 时间复杂度
- 查找元素：O(log n) 时间复杂度
- 遍历元素：O(n) 时间复杂度

#### 使用场景

- 需要存储唯一元素的集合
- 需要自动排序的集合
- 需要快速查找元素的场景
- 需要集合运算（并集、交集、差集）的场景

#### 注意事项

- set 中的元素是常量，不能直接修改
- 如果需要修改元素，需要先删除旧元素，再插入新元素
- set 的迭代器是双向迭代器，支持前向和后向遍历
- 自定义类型的 set 需要提供比较函数或重载比较运算符

set 是 C++ 中一个非常有用的容器，特别适合需要存储唯一元素并自动排序的场景。它提供了高效的查找、插入和删除操作，是处理有序唯一集合的理想选择。

### Ⅱ. multiset

`std::multiset` 是 C++ 标准库中的关联容器，包含键的排序集合，允许重复元素。multiset 中的元素自动排序，但不同于 set，它可以包含多个相同的元素。以下是 multiset 的增删改查操作示例：

```cpp
#include <iostream>
#include <set>
#include <algorithm>
using namespace std;

// 打印multiset内容
template<typename T>
void printMultiset(const multiset<T>& ms, const string& name = "multiset") {
    cout << name << ": ";
    for (const auto& element : ms) {
        cout << element << " ";
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    multiset<int> ms = {5, 3, 8, 1, 3, 9, 2, 7, 3, 5};
    printMultiset(ms, "初始");
    
    // 2. 添加元素
    cout << "\n=== 添加元素 ===" << endl;
    ms.insert(4);  // 插入单个元素
    printMultiset(ms, "插入4后");
    
    ms.insert(3);  // 插入重复元素
    printMultiset(ms, "再次插入3后");
    
    vector<int> vec = {10, 6, 11, 6};
    ms.insert(vec.begin(), vec.end());  // 插入范围元素
    printMultiset(ms, "插入vector元素后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    // multiset不支持随机访问，但可以通过迭代器访问
    if (!ms.empty()) {
        cout << "第一个元素: " << *ms.begin() << endl;
        cout << "最后一个元素: " << *ms.rbegin() << endl;
    }
    
    // 4. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int target = 3;
    auto it = ms.find(target);
    if (it != ms.end()) {
        cout << "找到元素 " << target << "，首次出现位置的值: " << *it << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 使用count方法检查元素出现次数
    target = 3;
    size_t count = ms.count(target);
    cout << "元素 " << target << " 出现次数: " << count << endl;
    
    // 查找所有等于某个值的元素
    cout << "所有等于3的元素: ";
    auto range = ms.equal_range(3);
    for (auto it = range.first; it != range.second; ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 查找上下界
    cout << "大于等于6的第一个元素: " << *ms.lower_bound(6) << endl;
    cout << "大于6的第一个元素: " << *ms.upper_bound(6) << endl;
    
    // 5. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    size_t removed = ms.erase(3);  // 删除所有值为3的元素
    cout << "删除了 " << removed << " 个值为3的元素" << endl;
    printMultiset(ms, "删除所有3后");
    
    it = ms.find(6);
    if (it != ms.end()) {
        ms.erase(it);  // 通过迭代器删除单个元素
        printMultiset(ms, "删除一个6后");
    }
    
    // 删除一定范围内的元素
    auto first = ms.lower_bound(7);
    auto last = ms.upper_bound(9);
    if (first != ms.end() && last != ms.end()) {
        ms.erase(first, last);  // 删除[7, 9]范围的元素
        printMultiset(ms, "删除7到9范围后");
    }
    
    // 6. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    // multiset中的元素是常量，不能直接修改
    // 需要先删除旧元素，再插入新元素
    int oldValue = 5;
    int newValue = 50;
    
    // 删除所有值为5的元素
    removed = ms.erase(oldValue);
    cout << "删除了 " << removed << " 个值为5的元素" << endl;
    
    // 插入新值
    ms.insert(newValue);
    printMultiset(ms, "修改5为50后");
    
    // 7. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "multiset大小: " << ms.size() << endl;
    cout << "multiset最大大小: " << ms.max_size() << endl;
    cout << "multiset是否为空: " << (ms.empty() ? "是" : "否") << endl;
    
    // 8. 清空multiset
    cout << "\n=== 清空multiset ===" << endl;
    ms.clear();
    cout << "清空后大小: " << ms.size() << endl;
    cout << "清空后是否为空: " << (ms.empty() ? "是" : "否") << endl;
    
    // 9. 重新填充并遍历
    cout << "\n=== 重新填充并遍历 ===" << endl;
    ms = {15, 12, 18, 12, 11, 19, 13, 17, 12, 15};
    printMultiset(ms, "重新填充后");
    
    cout << "正向遍历: ";
    for (auto it = ms.begin(); it != ms.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    cout << "反向遍历: ";
    for (auto it = ms.rbegin(); it != ms.rend(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 10. 交换两个multiset的内容
    cout << "\n=== 交换multiset内容 ===" << endl;
    multiset<int> ms1 = {1, 2, 2, 3};
    multiset<int> ms2 = {10, 20, 20, 30, 40};
    
    printMultiset(ms1, "ms1交换前");
    printMultiset(ms2, "ms2交换前");
    
    ms1.swap(ms2);
    
    printMultiset(ms1, "ms1交换后");
    printMultiset(ms2, "ms2交换后");
    
    // 11. 自定义比较函数的multiset
    cout << "\n=== 自定义比较函数的multiset ===" << endl;
    // 降序排列的multiset
    multiset<int, greater<int>> descendingMultiset = {5, 3, 8, 1, 3, 9, 2, 7, 3, 5};
    
    cout << "降序multiset: ";
    for (const auto& element : descendingMultiset) {
        cout << element << " ";
    }
    cout << endl;
    
    // 12. 使用emplace方法添加元素
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    multiset<pair<int, string>> pairMultiset;
    pairMultiset.emplace(1, "one");
    pairMultiset.emplace(2, "two");
    pairMultiset.emplace(2, "second two");
    pairMultiset.emplace(3, "three");
    
    cout << "pair multiset: ";
    for (const auto& p : pairMultiset) {
        cout << "(" << p.first << ", " << p.second << ") ";
    }
    cout << endl;
    
    // 13. 获取某个元素的出现次数
    cout << "\n=== 获取元素出现次数 ===" << endl;
    multiset<int> testMs = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
    printMultiset(testMs, "测试multiset");
    
    cout << "元素2出现次数: " << testMs.count(2) << endl;
    cout << "元素3出现次数: " << testMs.count(3) << endl;
    cout << "元素5出现次数: " << testMs.count(5) << endl;
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `multiset`

2. **添加元素**：
   - `insert()`: 插入单个元素或范围元素
   - 可以插入重复元素，multiset 会保持所有元素有序

3. **访问元素**：
   - `begin()`: 获取指向第一个元素的迭代器
   - `rbegin()`: 获取指向最后一个元素的反向迭代器
   - 注意：multiset 不支持随机访问，不能使用 `[]` 或 `at()`

4. **查找元素**：
   - `find()`: 查找指定元素，返回指向第一个匹配元素的迭代器
   - `count()`: 返回指定元素的出现次数
   - `equal_range()`: 返回匹配给定键的元素范围
   - `lower_bound()`: 返回指向不小于给定值的第一个元素的迭代器
   - `upper_bound()`: 返回指向大于给定值的第一个元素的迭代器

5. **删除元素**：
   - `erase()`: 删除指定值、迭代器或范围的元素
   - 删除指定值会删除所有匹配的元素

6. **修改元素**：
   - multiset 中的元素是常量，不能直接修改
   - 需要先删除旧元素，再插入新元素

7. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空

8. **清空multiset**：使用 `clear()` 清空所有元素

9. **遍历multiset**：
   - 使用正向迭代器
   - 使用反向迭代器

10. **交换内容**：使用 `swap()` 方法交换两个multiset的内容

11. **自定义比较函数**：可以创建降序排列的multiset或其他自定义排序规则的multiset

12. **使用emplace方法**：使用 `emplace()` 方法直接构造并插入元素

13. **获取元素出现次数**：使用 `count()` 方法获取特定元素的出现次数

#### multiset 的特点

- **允许重复键**：multiset 中可以包含多个相同的元素
- **自动排序**：元素按照键值自动排序
- **不可修改元素**：multiset 中的元素是常量，不能直接修改
- **高效查找**：基于红黑树实现，查找时间复杂度为 O(log n)
- **不支持随机访问**：不能通过索引直接访问元素

#### 性能考虑

- 插入元素：O(log n) 时间复杂度
- 删除元素：O(log n) 时间复杂度
- 查找元素：O(log n) 时间复杂度
- 遍历元素：O(n) 时间复杂度
- 计数元素：O(log n + k) 时间复杂度，其中 k 是匹配元素的数量

#### 使用场景

- 需要存储可能重复元素的排序集合
- 需要自动排序的集合，且允许重复
- 需要快速查找元素的场景
- 需要统计元素出现次数的场景

#### 注意事项

- multiset 中的元素是常量，不能直接修改
- 如果需要修改元素，需要先删除旧元素，再插入新元素
- multiset 的迭代器是双向迭代器，支持前向和后向遍历
- 自定义类型的 multiset 需要提供比较函数或重载比较运算符

multiset 是 C++ 中一个非常有用的容器，特别适合需要存储可能重复元素并自动排序的场景。它提供了高效的查找、插入和删除操作，是处理有序可重复集合的理想选择。

### Ⅲ. map

`std::map` 是 C++ 标准库中的关联容器，存储键值对，按键的升序自动排序。每个键在 map 中是唯一的。以下是 map 的增删改查操作示例：

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;

// 打印map内容
template<typename K, typename V>
void printMap(const map<K, V>& m, const string& name = "map") {
    cout << name << ": " << endl;
    for (const auto& pair : m) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    map<int, string> m = {
        {3, "three"},
        {1, "one"},
        {4, "four"},
        {2, "two"}
    };
    printMap(m, "初始");
    
    // 2. 添加元素
    cout << "=== 添加元素 ===" << endl;
    m.insert({5, "five"});  // 使用insert添加元素
    m[6] = "six";           // 使用下标运算符添加元素
    printMap(m, "添加元素后");
    
    // 使用insert返回值检查是否插入成功
    auto result = m.insert({3, "THREE"});  // 键3已存在，不会插入
    if (!result.second) {
        cout << "插入失败，键3已存在，对应的值为: " << result.first->second << endl;
    }
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    cout << "键1对应的值: " << m[1] << endl;
    cout << "键2对应的值: " << m.at(2) << endl;
    
    // 使用find方法安全访问
    auto it = m.find(4);
    if (it != m.end()) {
        cout << "找到键4，对应的值: " << it->second << endl;
    } else {
        cout << "未找到键4" << endl;
    }
    
    // 检查键是否存在
    if (m.count(5) > 0) {
        cout << "键5存在" << endl;
    } else {
        cout << "键5不存在" << endl;
    }
    
    // 4. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    m[2] = "TWO";  // 使用下标运算符修改值
    printMap(m, "修改键2的值后");
    
    it = m.find(3);
    if (it != m.end()) {
        it->second = "THREE";  // 通过迭代器修改值
    }
    printMap(m, "修改键3的值后");
    
    // 5. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    m.erase(4);  // 通过键删除元素
    printMap(m, "删除键4后");
    
    it = m.find(5);
    if (it != m.end()) {
        m.erase(it);  // 通过迭代器删除元素
    }
    printMap(m, "删除键5后");
    
    // 删除一定范围内的元素
    auto first = m.find(2);
    auto last = m.find(6);
    if (first != m.end() && last != m.end()) {
        m.erase(first, last);  // 删除[2, 6)范围的元素
    }
    printMap(m, "删除键2到6范围后");
    
    // 6. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int key = 3;
    it = m.find(key);
    if (it != m.end()) {
        cout << "找到键 " << key << "，对应的值: " << it->second << endl;
    } else {
        cout << "未找到键 " << key << endl;
    }
    
    // 使用lower_bound和upper_bound
    m = {{1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}, {5, "five"}};
    cout << "大于等于3的第一个键: " << m.lower_bound(3)->first << endl;
    cout << "大于3的第一个键: " << m.upper_bound(3)->first << endl;
    
    // 7. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "map大小: " << m.size() << endl;
    cout << "map最大大小: " << m.max_size() << endl;
    cout << "map是否为空: " << (m.empty() ? "是" : "否") << endl;
    
    // 8. 清空map
    cout << "\n=== 清空map ===" << endl;
    m.clear();
    cout << "清空后大小: " << m.size() << endl;
    cout << "清空后是否为空: " << (m.empty() ? "是" : "否") << endl;
    
    // 9. 重新填充并遍历
    cout << "\n=== 重新填充并遍历 ===" << endl;
    m = {
        {10, "ten"},
        {20, "twenty"},
        {30, "thirty"},
        {40, "forty"}
    };
    printMap(m, "重新填充后");
    
    cout << "正向遍历: " << endl;
    for (auto it = m.begin(); it != m.end(); ++it) {
        cout << "  " << it->first << " => " << it->second << endl;
    }
    
    cout << "反向遍历: " << endl;
    for (auto it = m.rbegin(); it != m.rend(); ++it) {
        cout << "  " << it->first << " => " << it->second << endl;
    }
    
    // 10. 交换两个map的内容
    cout << "\n=== 交换map内容 ===" << endl;
    map<int, string> m1 = {{1, "one"}, {2, "two"}};
    map<int, string> m2 = {{10, "ten"}, {20, "twenty"}, {30, "thirty"}};
    
    printMap(m1, "m1交换前");
    printMap(m2, "m2交换前");
    
    m1.swap(m2);
    
    printMap(m1, "m1交换后");
    printMap(m2, "m2交换后");
    
    // 11. 自定义比较函数的map
    cout << "\n=== 自定义比较函数的map ===" << endl;
    // 降序排列的map
    map<int, string, greater<int>> descendingMap = {
        {3, "three"},
        {1, "one"},
        {4, "four"},
        {2, "two"}
    };
    
    cout << "降序map: " << endl;
    for (const auto& pair : descendingMap) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    
    // 12. 使用emplace方法添加元素
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    map<string, int> wordCount;
    wordCount.emplace("apple", 5);
    wordCount.emplace("banana", 3);
    wordCount.emplace("cherry", 7);
    
    cout << "wordCount map: " << endl;
    for (const auto& pair : wordCount) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    
    // 13. 处理不存在的键
    cout << "\n=== 处理不存在的键 ===" << endl;
    map<int, string> testMap = {{1, "one"}, {2, "two"}};
    
    // 使用at方法访问不存在的键会抛出异常
    try {
        cout << testMap.at(3) << endl;
    } catch (const out_of_range& e) {
        cout << "异常: " << e.what() << endl;
    }
    
    // 使用find方法安全访问
    auto found = testMap.find(3);
    if (found != testMap.end()) {
        cout << found->second << endl;
    } else {
        cout << "键3不存在" << endl;
    }
    
    // 使用下标运算符访问不存在的键会创建新元素
    cout << "访问不存在的键4: " << testMap[4] << endl;
    printMap(testMap, "访问键4后的map");
    
    // 14. 从一个映射节点移动元素到另一个映射：
    std::map<int, string> src {{1, "one"}, {2, "two"}, {3, "buckle my shoe"}};
    std::map<int, string> dst {{3, "three"}};
    dst.insert(src.extract(src.find(1))); // 从 `src` 到 `dst` 廉价地移除并插入 { 1, "one" }
    dst.insert(src.extract(2)); // 从 `src` 到 `dst` 廉价地移除并插入 { 2, "two" }
    // dst == { { 1, "one" }, { 2, "two" }, { 3, "three" } };
    printMap(src, "访问交换的map");
    printMap(dst, "访问被交换的map");
    
    // 15. 修改键值
    std::map<int, string> m {{1, "one"}, {2, "two"}, {3, "three"}};
    printMap(m, "提取前的map");
    auto e = m.extract(2);
    printMap(m, "提取后的map");
    e.key() = 4;
    m.insert(std::move(e));
    // m == { { 1, "one" }, { 3, "three" }, { 4, "two" } }
    printMap(m, "访问被修改键值的map");

    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `map`
2. **添加元素**：
   - `insert()`: 插入键值对
   - `[]` 运算符: 通过键添加或访问值
   - `insert()` 返回一个 pair，包含迭代器和布尔值表示是否插入成功
3. **访问元素**：
   - `[]` 运算符: 通过键访问值，如果键不存在会创建新元素
   - `at()`: 通过键访问值，如果键不存在会抛出异常
   - `find()`: 查找键，返回迭代器
   - `count()`: 检查键是否存在
4. **修改元素**：
   - `[]` 运算符: 通过键修改值
   - 通过迭代器修改值
5. **删除元素**：
   - `erase()`: 通过键、迭代器或范围删除元素
6. **查找元素**：
   - `find()`: 查找指定键，返回迭代器
   - `lower_bound()`: 返回指向不小于给定键的第一个元素的迭代器
   - `upper_bound()`: 返回指向大于给定键的第一个元素的迭代器
7. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空
8. **清空map**：使用 `clear()` 清空所有元素
9. **遍历map**：
   - 使用正向迭代器
   - 使用反向迭代器
10. **交换内容**：使用 `swap()` 方法交换两个map的内容
11. **自定义比较函数**：可以创建降序排列的map或其他自定义排序规则的map
12. **使用emplace方法**：使用 `emplace()` 方法直接构造并插入键值对
13. **处理不存在的键**：
    - 使用 `at()` 方法访问不存在的键会抛出异常
    - 使用 `find()` 方法安全访问
    - 使用 `[]` 运算符访问不存在的键会创建新元素
14. **移动节点合并容器**：使用`extract()`方法，传入值或者迭代器，在没有昂贵的拷贝、移动或堆分配/释放开销的情况下，移动节点和合并容器。 
15. **修改键值**：使用`extract()`方法，将节点从红黑树总提取，操作单个节点修改键，然后使用`insert()`方法再插入该节点

#### map 的特点

- **键值对存储**：存储键值对，键是唯一的
- **自动排序**：按键的升序自动排序
- **高效查找**：基于红黑树实现，查找时间复杂度为 O(log n)
- **键不可修改**：map 中的键是常量，不能直接修改
- **值可修改**：map 中的值可以修改

#### 性能考虑

- 插入元素：O(log n) 时间复杂度
- 删除元素：O(log n) 时间复杂度
- 查找元素：O(log n) 时间复杂度
- 遍历元素：O(n) 时间复杂度

#### 使用场景

- 需要键值对存储并且按键排序的场景
- 需要快速通过键查找值的场景
- 需要存储配置、字典等数据的场景

#### 注意事项

- map 中的键是常量，不能直接修改
- 如果需要修改键，需要先删除旧键值对，再插入新键值对
- 使用 `[]` 运算符访问不存在的键会创建新元素
- 使用 `at()` 方法访问不存在的键会抛出异常
- 自定义类型的键需要提供比较函数或重载比较运算符

map 是 C++ 中一个非常有用的容器，特别适合需要键值对存储并按键排序的场景。它提供了高效的查找、插入和删除操作，是处理键值对数据的理想选择。

### Ⅳ. multimap

`std::multimap` 是 C++ 标准库中的关联容器，存储键值对，按键的升序自动排序，但允许键重复。以下是 multimap 的增删改查操作示例：

```cpp
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
using namespace std;

// 打印multimap内容
template<typename K, typename V>
void printMultimap(const multimap<K, V>& mm, const string& name = "multimap") {
    cout << name << ": " << endl;
    for (const auto& pair : mm) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    multimap<int, string> mm = {
        {3, "three"},
        {1, "one"},
        {4, "four"},
        {2, "two"},
        {3, "three again"},  // 重复的键
        {1, "one more"}      // 重复的键
    };
    printMultimap(mm, "初始");
    
    // 2. 添加元素
    cout << "=== 添加元素 ===" << endl;
    mm.insert({5, "five"});  // 使用insert添加元素
    mm.insert({3, "another three"});  // 添加重复键
    printMultimap(mm, "添加元素后");
    
    // 使用insert返回值获取插入位置
    auto result = mm.insert({2, "second two"});
    cout << "插入的键值对: " << result->first << " => " << result->second << endl;
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    // multimap不支持[]运算符，因为键可能不唯一
    
    // 使用find方法访问第一个匹配的键
    auto it = mm.find(3);
    if (it != mm.end()) {
        cout << "找到键3的第一个值: " << it->second << endl;
    }
    
    // 4. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int key = 3;
    
    // 使用count方法获取键的出现次数
    size_t count = mm.count(key);
    cout << "键 " << key << " 出现次数: " << count << endl;
    
    // 使用equal_range获取所有匹配的键值对
    auto range = mm.equal_range(key);
    cout << "所有键为 " << key << " 的值: ";
    for (auto it = range.first; it != range.second; ++it) {
        cout << it->second << " ";
    }
    cout << endl;
    
    // 使用lower_bound和upper_bound
    cout << "大于等于3的第一个键: " << mm.lower_bound(3)->first << endl;
    cout << "大于3的第一个键: " << mm.upper_bound(3)->first << endl;
    
    // 5. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    // multimap中的键是常量，不能直接修改
    // 但可以修改值（如果值不是常量）
    
    // 修改第一个键为3的值
    it = mm.find(3);
    if (it != mm.end()) {
        it->second = "modified three";
        cout << "修改后的值: " << it->second << endl;
    }
    
    // 如果要修改键，需要先删除再插入
    int oldKey = 2;
    int newKey = 20;
    string value = "twenty";
    
    // 查找所有键为2的元素
    range = mm.equal_range(oldKey);
    if (range.first != range.second) {
        // 先保存值
        vector<string> values;
        for (auto it = range.first; it != range.second; ++it) {
            values.push_back(it->second);
        }
        
        // 删除所有键为2的元素
        mm.erase(oldKey);
        
        // 插入新键值对
        for (const auto& val : values) {
            mm.insert({newKey, val});
        }
    }
    printMultimap(mm, "修改键2为20后");
    
    // 6. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    size_t removed = mm.erase(3);  // 删除所有键为3的元素
    cout << "删除了 " << removed << " 个键为3的元素" << endl;
    printMultimap(mm, "删除所有键3后");
    
    it = mm.find(1);
    if (it != mm.end()) {
        mm.erase(it);  // 通过迭代器删除单个元素
        printMultimap(mm, "删除一个键1后");
    }
    
    // 删除一定范围内的元素
    auto first = mm.lower_bound(4);
    auto last = mm.upper_bound(20);
    if (first != mm.end() && last != mm.end()) {
        mm.erase(first, last);  // 删除[4, 20]范围的元素
    }
    printMultimap(mm, "删除键4到20范围后");
    
    // 7. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "multimap大小: " << mm.size() << endl;
    cout << "multimap最大大小: " << mm.max_size() << endl;
    cout << "multimap是否为空: " << (mm.empty() ? "是" : "否") << endl;
    
    // 8. 清空multimap
    cout << "\n=== 清空multimap ===" << endl;
    mm.clear();
    cout << "清空后大小: " << mm.size() << endl;
    cout << "清空后是否为空: " << (mm.empty() ? "是" : "否") << endl;
    
    // 9. 重新填充并遍历
    cout << "\n=== 重新填充并遍历 ===" << endl;
    mm = {
        {10, "ten"},
        {20, "twenty"},
        {30, "thirty"},
        {20, "twenty again"},
        {10, "ten more"}
    };
    printMultimap(mm, "重新填充后");
    
    cout << "正向遍历: " << endl;
    for (auto it = mm.begin(); it != mm.end(); ++it) {
        cout << "  " << it->first << " => " << it->second << endl;
    }
    
    cout << "反向遍历: " << endl;
    for (auto it = mm.rbegin(); it != mm.rend(); ++it) {
        cout << "  " << it->first << " => " << it->second << endl;
    }
    
    // 10. 交换两个multimap的内容
    cout << "\n=== 交换multimap内容 ===" << endl;
    multimap<int, string> mm1 = {{1, "one"}, {2, "two"}, {2, "second two"}};
    multimap<int, string> mm2 = {{10, "ten"}, {20, "twenty"}, {20, "twenty again"}};
    
    printMultimap(mm1, "mm1交换前");
    printMultimap(mm2, "mm2交换前");
    
    mm1.swap(mm2);
    
    printMultimap(mm1, "mm1交换后");
    printMultimap(mm2, "mm2交换后");
    
    // 11. 自定义比较函数的multimap
    cout << "\n=== 自定义比较函数的multimap ===" << endl;
    // 降序排列的multimap
    multimap<int, string, greater<int>> descendingMultimap = {
        {3, "three"},
        {1, "one"},
        {4, "four"},
        {2, "two"},
        {3, "three again"}
    };
    
    cout << "降序multimap: " << endl;
    for (const auto& pair : descendingMultimap) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    
    // 12. 使用emplace方法添加元素
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    multimap<string, int> wordCount;
    wordCount.emplace("apple", 5);
    wordCount.emplace("banana", 3);
    wordCount.emplace("apple", 2);  // 重复键
    wordCount.emplace("cherry", 7);
    
    cout << "wordCount multimap: " << endl;
    for (const auto& pair : wordCount) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    
    // 13. 处理不存在的键
    cout << "\n=== 处理不存在的键 ===" << endl;
    multimap<int, string> testMultimap = {{1, "one"}, {2, "two"}, {2, "second two"}};
    
    // 使用find方法安全访问
    auto found = testMultimap.find(3);
    if (found != testMultimap.end()) {
        cout << found->second << endl;
    } else {
        cout << "键3不存在" << endl;
    }
    
    // 使用count方法检查键是否存在
    if (testMultimap.count(3) > 0) {
        cout << "键3存在" << endl;
    } else {
        cout << "键3不存在" << endl;
    }
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `multimap`，可以包含重复的键

2. **添加元素**：
   - `insert()`: 插入键值对
   - 可以插入重复键，multimap 会保持所有键值对有序

3. **访问元素**：
   - multimap 不支持 `[]` 运算符，因为键可能不唯一
   - 使用 `find()` 方法访问第一个匹配的键

4. **查找元素**：
   - `count()`: 返回指定键的出现次数
   - `equal_range()`: 返回匹配给定键的元素范围
   - `lower_bound()`: 返回指向不小于给定键的第一个元素的迭代器
   - `upper_bound()`: 返回指向大于给定键的第一个元素的迭代器

5. **修改元素**：
   - multimap 中的键是常量，不能直接修改
   - 可以修改值（如果值不是常量）
   - 要修改键，需要先删除再插入

6. **删除元素**：
   - `erase()`: 删除指定键、迭代器或范围的元素
   - 删除指定键会删除所有匹配的元素

7. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空

8. **清空multimap**：使用 `clear()` 清空所有元素

9. **遍历multimap**：
   - 使用正向迭代器
   - 使用反向迭代器

10. **交换内容**：使用 `swap()` 方法交换两个multimap的内容

11. **自定义比较函数**：可以创建降序排列的multimap或其他自定义排序规则的multimap

12. **使用emplace方法**：使用 `emplace()` 方法直接构造并插入键值对

13. **处理不存在的键**：
    - 使用 `find()` 方法安全访问
    - 使用 `count()` 方法检查键是否存在

#### multimap 的特点

- **键值对存储**：存储键值对，键可以重复
- **自动排序**：按键的升序自动排序
- **高效查找**：基于红黑树实现，查找时间复杂度为 O(log n)
- **键不可修改**：multimap 中的键是常量，不能直接修改
- **值可修改**：multimap 中的值可以修改

#### 性能考虑

- 插入元素：O(log n) 时间复杂度
- 删除元素：O(log n) 时间复杂度
- 查找元素：O(log n) 时间复杂度
- 遍历元素：O(n) 时间复杂度

#### 使用场景

- 需要键值对存储并且允许键重复的场景
- 需要按键排序的一对多关系
- 需要快速通过键查找多个值的场景

#### 注意事项

- multimap 中的键是常量，不能直接修改
- multimap 不支持 `[]` 运算符，因为键可能不唯一
- 使用 `equal_range()` 方法获取所有匹配的键值对
- 自定义类型的键需要提供比较函数或重载比较运算符

multimap 是 C++ 中一个非常有用的容器，特别适合需要键值对存储并允许键重复的场景。它提供了高效的查找、插入和删除操作，是处理一对多关系的理想选择。

------



## (3) 无序关联容器—增删改查操作—示例代码

### Ⅰ. unordered_set

`std::unordered_set` 是 C++ 标准库中的无序关联容器，包含唯一元素，基于哈希表实现。与 `set` 不同，`unordered_set` 不保持元素排序，但提供更快的平均访问速度。以下是 unordered_set 的增删改查操作示例：

```cpp
#include <iostream>
#include <unordered_set>
#include <string>
#include <algorithm>
using namespace std;

// 打印unordered_set内容
template<typename T>
void printUnorderedSet(const unordered_set<T>& us, const string& name = "unordered_set") {
    cout << name << ": ";
    for (const auto& element : us) {
        cout << element << " ";
    }
    cout << endl;
}

// 自定义哈希函数示例
struct Person {
    string name;
    int age;
    
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

namespace std {
    template<>
    struct hash<Person> {
        size_t operator()(const Person& p) const {
            return hash<string>()(p.name) ^ hash<int>()(p.age);
        }
    };
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    unordered_set<int> us = {5, 3, 8, 1, 9, 2, 7};
    printUnorderedSet(us, "初始");
    
    // 2. 添加元素
    cout << "\n=== 添加元素 ===" << endl;
    us.insert(4);  // 插入单个元素
    printUnorderedSet(us, "插入4后");
    
    us.insert(3);  // 尝试插入已存在的元素（不会重复插入）
    printUnorderedSet(us, "再次插入3后");
    
    vector<int> vec = {10, 6, 11};
    us.insert(vec.begin(), vec.end());  // 插入范围元素
    printUnorderedSet(us, "插入vector元素后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    // unordered_set不支持随机访问，但可以通过迭代器访问
    if (!us.empty()) {
        cout << "第一个元素: " << *us.begin() << endl;
    }
    
    // 4. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int target = 7;
    auto it = us.find(target);
    if (it != us.end()) {
        cout << "找到元素 " << target << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 使用count方法检查元素是否存在
    target = 15;
    if (us.count(target) > 0) {
        cout << "找到元素 " << target << endl;
    } else {
        cout << "未找到元素 " << target << endl;
    }
    
    // 5. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    size_t removed = us.erase(4);  // 删除值为4的元素
    cout << "删除了 " << removed << " 个元素" << endl;
    printUnorderedSet(us, "删除4后");
    
    it = us.find(6);
    if (it != us.end()) {
        us.erase(it);  // 通过迭代器删除元素
        printUnorderedSet(us, "删除6后");
    }
    
    // 删除一定范围内的元素
    auto first = us.find(7);
    auto last = us.find(10);
    if (first != us.end() && last != us.end()) {
        us.erase(first, last);  // 删除[7, 10)范围的元素
        printUnorderedSet(us, "删除7到10范围后");
    }
    
    // 6. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    // unordered_set中的元素是常量，不能直接修改
    // 需要先删除旧元素，再插入新元素
    int oldValue = 2;
    int newValue = 20;
    
    it = us.find(oldValue);
    if (it != us.end()) {
        us.erase(it);
        us.insert(newValue);
        printUnorderedSet(us, "修改2为20后");
    }
    
    // 7. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "unordered_set大小: " << us.size() << endl;
    cout << "unordered_set最大大小: " << us.max_size() << endl;
    cout << "unordered_set是否为空: " << (us.empty() ? "是" : "否") << endl;
    cout << "当前桶数量: " << us.bucket_count() << endl;
    cout << "负载因子: " << us.load_factor() << endl;
    cout << "最大负载因子: " << us.max_load_factor() << endl;
    
    // 8. 清空unordered_set
    cout << "\n=== 清空unordered_set ===" << endl;
    us.clear();
    cout << "清空后大小: " << us.size() << endl;
    cout << "清空后是否为空: " << (us.empty() ? "是" : "否") << endl;
    
    // 9. 重新填充并遍历
    cout << "\n=== 重新填充并遍历 ===" << endl;
    us = {15, 12, 18, 11, 19, 13, 17};
    printUnorderedSet(us, "重新填充后");
    
    cout << "遍历所有元素: ";
    for (auto it = us.begin(); it != us.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 10. 交换两个unordered_set的内容
    cout << "\n=== 交换unordered_set内容 ===" << endl;
    unordered_set<int> us1 = {1, 2, 3};
    unordered_set<int> us2 = {10, 20, 30, 40};
    
    printUnorderedSet(us1, "us1交换前");
    printUnorderedSet(us2, "us2交换前");
    
    us1.swap(us2);
    
    printUnorderedSet(us1, "us1交换后");
    printUnorderedSet(us2, "us2交换后");
    
    // 11. 使用emplace方法添加元素
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    unordered_set<string> stringSet;
    stringSet.emplace("apple");
    stringSet.emplace("banana");
    stringSet.emplace("cherry");
    
    printUnorderedSet(stringSet, "string set");
    
    // 12. 哈希策略管理
    cout << "\n=== 哈希策略管理 ===" << endl;
    unordered_set<int> hashSet = {1, 2, 3, 4, 5};
    cout << "当前桶数量: " << hashSet.bucket_count() << endl;
    cout << "当前负载因子: " << hashSet.load_factor() << endl;
    
    // 重新哈希以减少冲突
    hashSet.rehash(20);
    cout << "重新哈希后桶数量: " << hashSet.bucket_count() << endl;
    
    // 调整最大负载因子
    hashSet.max_load_factor(0.7f);
    cout << "新最大负载因子: " << hashSet.max_load_factor() << endl;
    
    // 13. 桶接口
    cout << "\n=== 桶接口 ===" << endl;
    unordered_set<int> bucketSet = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    cout << "桶数量: " << bucketSet.bucket_count() << endl;
    for (size_t i = 0; i < bucketSet.bucket_count(); ++i) {
        cout << "桶 " << i << " 有 " << bucketSet.bucket_size(i) << " 个元素: ";
        for (auto it = bucketSet.begin(i); it != bucketSet.end(i); ++it) {
            cout << *it << " ";
        }
        cout << endl;
    }
    
    // 14. 自定义类型的unordered_set
    cout << "\n=== 自定义类型的unordered_set ===" << endl;
    unordered_set<Person> personSet;
    personSet.insert({"Alice", 25});
    personSet.insert({"Bob", 30});
    personSet.insert({"Charlie", 35});
    
    cout << "Person set: ";
    for (const auto& p : personSet) {
        cout << p.name << "(" << p.age << ") ";
    }
    cout << endl;
    
    // 查找自定义类型元素
    Person searchPerson = {"Bob", 30};
    auto personIt = personSet.find(searchPerson);
    if (personIt != personSet.end()) {
        cout << "找到: " << personIt->name << "(" << personIt->age << ")" << endl;
    } else {
        cout << "未找到" << endl;
    }
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `unordered_set`

2. **添加元素**：
   - `insert()`: 插入单个元素或范围元素
   - 尝试插入已存在的元素会被忽略（因为unordered_set元素必须唯一）

3. **访问元素**：
   - `begin()`: 获取指向第一个元素的迭代器
   - 注意：unordered_set 不支持随机访问，不能使用 `[]` 或 `at()`

4. **查找元素**：
   - `find()`: 查找指定元素，返回迭代器
   - `count()`: 检查元素是否存在（返回0或1）

5. **删除元素**：
   - `erase()`: 删除指定值、迭代器或范围的元素

6. **修改元素**：
   - unordered_set 中的元素是常量，不能直接修改
   - 需要先删除旧元素，再插入新元素

7. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空
   - `bucket_count()`: 获取桶的数量
   - `load_factor()`: 获取当前负载因子
   - `max_load_factor()`: 获取或设置最大负载因子

8. **清空unordered_set**：使用 `clear()` 清空所有元素

9. **遍历unordered_set**：使用迭代器遍历所有元素

10. **交换内容**：使用 `swap()` 方法交换两个unordered_set的内容

11. **使用emplace方法**：使用 `emplace()` 方法直接构造并插入元素

12. **哈希策略管理**：
    - `rehash()`: 重新设置桶的数量
    - `max_load_factor()`: 设置最大负载因子

13. **桶接口**：
    - `bucket_count()`: 获取桶的数量
    - `bucket_size()`: 获取指定桶中的元素数量
    - `begin(bucket_index)` 和 `end(bucket_index)`: 访问指定桶中的元素

14. **自定义类型的unordered_set**：
    - 需要提供哈希函数和相等比较函数
    - 可以通过特化 `std::hash` 模板和重载 `operator==` 来实现

#### unordered_set 的特点

- **唯一键**：unordered_set 中的每个元素都是唯一的
- **无序存储**：元素不按特定顺序存储，而是根据哈希值组织
- **高效查找**：基于哈希表实现，平均查找时间复杂度为 O(1)
- **不可修改元素**：unordered_set 中的元素是常量，不能直接修改
- **不支持随机访问**：不能通过索引直接访问元素

#### 性能考虑

- 平均情况下：
  - 插入元素：O(1) 时间复杂度
  - 删除元素：O(1) 时间复杂度
  - 查找元素：O(1) 时间复杂度
- 最坏情况下（所有元素哈希到同一个桶）：
  - 所有操作：O(n) 时间复杂度

#### 使用场景

- 需要存储唯一元素的集合
- 不需要元素排序的场景
- 需要快速查找元素的场景
- 对内存使用不是特别敏感的场景（哈希表通常有额外开销）

#### 注意事项

- unordered_set 中的元素是常量，不能直接修改
- 如果需要修改元素，需要先删除旧元素，再插入新元素
- 自定义类型的 unordered_set 需要提供哈希函数和相等比较函数
- 哈希函数的质量直接影响性能，应尽量避免哈希冲突

unordered_set 是 C++ 中一个非常有用的容器，特别适合需要快速查找而不需要排序的场景。它提供了高效的查找、插入和删除操作，是处理无序唯一集合的理想选择。

### Ⅱ. unordered_multiset

`std::unordered_multiset` 是 C++ 标准库中的无序关联容器，基于哈希表实现，允许存储重复元素。与 `unordered_set` 不同，`unordered_multiset` 允许元素重复，但不保持元素的特定顺序。以下是 unordered_multiset 的增删改查操作示例：

```cpp
#include <iostream>
#include <unordered_set>
#include <string>
#include <algorithm>
using namespace std;

// 打印unordered_multiset内容
template<typename T>
void printUnorderedMultiset(const unordered_multiset<T>& ums, const string& name = "unordered_multiset") {
    cout << name << ": ";
    for (const auto& element : ums) {
        cout << element << " ";
    }
    cout << endl;
}

// 自定义哈希函数示例
struct Person {
    string name;
    int age;
    
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

namespace std {
    template<>
    struct hash<Person> {
        size_t operator()(const Person& p) const {
            return hash<string>()(p.name) ^ hash<int>()(p.age);
        }
    };
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    unordered_multiset<int> ums = {5, 3, 8, 1, 3, 9, 2, 7, 3, 5};
    printUnorderedMultiset(ums, "初始");
    
    // 2. 添加元素
    cout << "\n=== 添加元素 ===" << endl;
    ums.insert(4);  // 插入单个元素
    printUnorderedMultiset(ums, "插入4后");
    
    ums.insert(3);  // 插入重复元素
    printUnorderedMultiset(ums, "再次插入3后");
    
    vector<int> vec = {10, 6, 11, 6};
    ums.insert(vec.begin(), vec.end());  // 插入范围元素
    printUnorderedMultiset(ums, "插入vector元素后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    // unordered_multiset不支持随机访问，但可以通过迭代器访问
    if (!ums.empty()) {
        cout << "第一个元素: " << *ums.begin() << endl;
    }
    
    // 4. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int target = 3;
    
    // 使用find方法访问第一个匹配的元素
    auto it = ums.find(target);
    if (it != ums.end()) {
        cout << "找到元素 " << target << "，首次出现: " << *it << endl;
    }
    
    // 使用count方法获取元素的出现次数
    size_t count = ums.count(target);
    cout << "元素 " << target << " 出现次数: " << count << endl;
    
    // 查找所有等于某个值的元素
    cout << "所有等于3的元素: ";
    auto range = ums.equal_range(target);
    for (auto it = range.first; it != range.second; ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 5. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    size_t removed = ums.erase(3);  // 删除所有值为3的元素
    cout << "删除了 " << removed << " 个值为3的元素" << endl;
    printUnorderedMultiset(ums, "删除所有3后");
    
    it = ums.find(6);
    if (it != ums.end()) {
        ums.erase(it);  // 通过迭代器删除单个元素
        printUnorderedMultiset(ums, "删除一个6后");
    }
    
    // 删除一定范围内的元素
    auto first = ums.find(7);
    auto last = ums.find(10);
    if (first != ums.end() && last != ums.end()) {
        ums.erase(first, last);  // 删除[7, 10)范围的元素
        printUnorderedMultiset(ums, "删除7到10范围后");
    }
    
    // 6. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    // unordered_multiset中的元素是常量，不能直接修改
    // 需要先删除旧元素，再插入新元素
    int oldValue = 5;
    int newValue = 50;
    
    // 删除所有值为5的元素
    removed = ums.erase(oldValue);
    cout << "删除了 " << removed << " 个值为5的元素" << endl;
    
    // 插入新值
    ums.insert(newValue);
    printUnorderedMultiset(ums, "修改5为50后");
    
    // 7. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "unordered_multiset大小: " << ums.size() << endl;
    cout << "unordered_multiset最大大小: " << ums.max_size() << endl;
    cout << "unordered_multiset是否为空: " << (ums.empty() ? "是" : "否") << endl;
    cout << "当前桶数量: " << ums.bucket_count() << endl;
    cout << "负载因子: " << ums.load_factor() << endl;
    cout << "最大负载因子: " << ums.max_load_factor() << endl;
    
    // 8. 清空unordered_multiset
    cout << "\n=== 清空unordered_multiset ===" << endl;
    ums.clear();
    cout << "清空后大小: " << ums.size() << endl;
    cout << "清空后是否为空: " << (ums.empty() ? "是" : "否") << endl;
    
    // 9. 重新填充并遍历
    cout << "\n=== 重新填充并遍历 ===" << endl;
    ums = {15, 12, 18, 12, 11, 19, 13, 17, 12, 15};
    printUnorderedMultiset(ums, "重新填充后");
    
    cout << "遍历所有元素: ";
    for (auto it = ums.begin(); it != ums.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 10. 交换两个unordered_multiset的内容
    cout << "\n=== 交换unordered_multiset内容 ===" << endl;
    unordered_multiset<int> ums1 = {1, 2, 2, 3};
    unordered_multiset<int> ums2 = {10, 20, 20, 30, 40};
    
    printUnorderedMultiset(ums1, "ums1交换前");
    printUnorderedMultiset(ums2, "ums2交换前");
    
    ums1.swap(ums2);
    
    printUnorderedMultiset(ums1, "ums1交换后");
    printUnorderedMultiset(ums2, "ums2交换后");
    
    // 11. 使用emplace方法添加元素
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    unordered_multiset<string> stringMultiset;
    stringMultiset.emplace("apple");
    stringMultiset.emplace("banana");
    stringMultiset.emplace("apple");  // 重复元素
    stringMultiset.emplace("cherry");
    
    printUnorderedMultiset(stringMultiset, "string multiset");
    
    // 12. 哈希策略管理
    cout << "\n=== 哈希策略管理 ===" << endl;
    unordered_multiset<int> hashMultiset = {1, 2, 3, 4, 5, 2, 3};
    cout << "当前桶数量: " << hashMultiset.bucket_count() << endl;
    cout << "当前负载因子: " << hashMultiset.load_factor() << endl;
    
    // 重新哈希以减少冲突
    hashMultiset.rehash(20);
    cout << "重新哈希后桶数量: " << hashMultiset.bucket_count() << endl;
    
    // 调整最大负载因子
    hashMultiset.max_load_factor(0.7f);
    cout << "新最大负载因子: " << hashMultiset.max_load_factor() << endl;
    
    // 13. 桶接口
    cout << "\n=== 桶接口 ===" << endl;
    unordered_multiset<int> bucketMultiset = {1, 2, 3, 4, 5, 2, 3, 6, 7, 8, 9, 10};
    
    cout << "桶数量: " << bucketMultiset.bucket_count() << endl;
    for (size_t i = 0; i < bucketMultiset.bucket_count(); ++i) {
        cout << "桶 " << i << " 有 " << bucketMultiset.bucket_size(i) << " 个元素: ";
        for (auto it = bucketMultiset.begin(i); it != bucketMultiset.end(i); ++it) {
            cout << *it << " ";
        }
        cout << endl;
    }
    
    // 14. 自定义类型的unordered_multiset
    cout << "\n=== 自定义类型的unordered_multiset ===" << endl;
    unordered_multiset<Person> personMultiset;
    personMultiset.insert({"Alice", 25});
    personMultiset.insert({"Bob", 30});
    personMultiset.insert({"Alice", 25});  // 重复元素
    personMultiset.insert({"Charlie", 35});
    
    cout << "Person multiset: ";
    for (const auto& p : personMultiset) {
        cout << p.name << "(" << p.age << ") ";
    }
    cout << endl;
    
    // 查找自定义类型元素
    Person searchPerson = {"Alice", 25};
    auto personIt = personMultiset.find(searchPerson);
    if (personIt != personMultiset.end()) {
        cout << "找到: " << personIt->name << "(" << personIt->age << ")" << endl;
    } else {
        cout << "未找到" << endl;
    }
    
    // 获取自定义类型元素的出现次数
    size_t personCount = personMultiset.count(searchPerson);
    cout << "Person {\"Alice\", 25} 出现次数: " << personCount << endl;
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `unordered_multiset`，可以包含重复的元素

2. **添加元素**：
   - `insert()`: 插入单个元素或范围元素
   - 可以插入重复元素，unordered_multiset 会保持所有元素

3. **访问元素**：
   - `begin()`: 获取指向第一个元素的迭代器
   - 注意：unordered_multiset 不支持随机访问，不能使用 `[]` 或 `at()`

4. **查找元素**：
   - `find()`: 查找指定元素，返回指向第一个匹配元素的迭代器
   - `count()`: 返回指定元素的出现次数
   - `equal_range()`: 返回匹配给定值的元素范围

5. **删除元素**：
   - `erase()`: 删除指定值、迭代器或范围的元素
   - 删除指定值会删除所有匹配的元素

6. **修改元素**：
   - unordered_multiset 中的元素是常量，不能直接修改
   - 需要先删除旧元素，再插入新元素

7. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空
   - `bucket_count()`: 获取桶的数量
   - `load_factor()`: 获取当前负载因子
   - `max_load_factor()`: 获取或设置最大负载因子

8. **清空unordered_multiset**：使用 `clear()` 清空所有元素

9. **遍历unordered_multiset**：使用迭代器遍历所有元素

10. **交换内容**：使用 `swap()` 方法交换两个unordered_multiset的内容

11. **使用emplace方法**：使用 `emplace()` 方法直接构造并插入元素

12. **哈希策略管理**：
    - `rehash()`: 重新设置桶的数量
    - `max_load_factor()`: 设置最大负载因子

13. **桶接口**：
    - `bucket_count()`: 获取桶的数量
    - `bucket_size()`: 获取指定桶中的元素数量
    - `begin(bucket_index)` 和 `end(bucket_index)`: 访问指定桶中的元素

14. **自定义类型的unordered_multiset**：
    - 需要提供哈希函数和相等比较函数
    - 可以通过特化 `std::hash` 模板和重载 `operator==` 来实现

#### unordered_multiset 的特点

- **允许重复元素**：unordered_multiset 中可以包含多个相同的元素
- **无序存储**：元素不按特定顺序存储，而是根据哈希值组织
- **高效查找**：基于哈希表实现，平均查找时间复杂度为 O(1)
- **不可修改元素**：unordered_multiset 中的元素是常量，不能直接修改
- **不支持随机访问**：不能通过索引直接访问元素

#### 性能考虑

- 平均情况下：
  - 插入元素：O(1) 时间复杂度
  - 删除元素：O(1) 时间复杂度
  - 查找元素：O(1) 时间复杂度
- 最坏情况下（所有元素哈希到同一个桶）：
  - 所有操作：O(n) 时间复杂度

#### 使用场景

- 需要存储可能重复元素的集合
- 不需要元素排序的场景
- 需要快速查找元素的场景
- 需要统计元素出现次数的场景

#### 注意事项

- unordered_multiset 中的元素是常量，不能直接修改
- 如果需要修改元素，需要先删除旧元素，再插入新元素
- 自定义类型的 unordered_multiset 需要提供哈希函数和相等比较函数
- 哈希函数的质量直接影响性能，应尽量避免哈希冲突
- 使用 `equal_range()` 方法获取所有匹配的元素

unordered_multiset 是 C++ 中一个非常有用的容器，特别适合需要快速查找而不需要排序的场景，且允许元素重复。它提供了高效的查找、插入和删除操作，是处理无序可重复集合的理想选择。

### Ⅲ. unordered_map

`std::unordered_map` 是 C++ 标准库中的无序关联容器，基于哈希表实现，存储键值对。与 `map` 不同，`unordered_map` 不保持元素排序，但提供更快的平均访问速度。以下是 unordered_map 的增删改查操作示例：

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <algorithm>
using namespace std;

// 打印unordered_map内容
template<typename K, typename V>
void printUnorderedMap(const unordered_map<K, V>& um, const string& name = "unordered_map") {
    cout << name << ": " << endl;
    for (const auto& pair : um) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    cout << endl;
}

// 自定义哈希函数示例
struct Person {
    string name;
    int age;
    
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

namespace std {
    template<>
    struct hash<Person> {
        size_t operator()(const Person& p) const {
            return hash<string>()(p.name) ^ hash<int>()(p.age);
        }
    };
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    unordered_map<int, string> um = {
        {3, "three"},
        {1, "one"},
        {4, "four"},
        {2, "two"}
    };
    printUnorderedMap(um, "初始");
    
    // 2. 添加元素
    cout << "=== 添加元素 ===" << endl;
    um.insert({5, "five"});  // 使用insert添加元素
    um[6] = "six";           // 使用下标运算符添加元素
    printUnorderedMap(um, "添加元素后");
    
    // 使用insert返回值检查是否插入成功
    auto result = um.insert({3, "THREE"});  // 键3已存在，不会插入
    if (!result.second) {
        cout << "插入失败，键3已存在，对应的值为: " << result.first->second << endl;
    }
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    cout << "键1对应的值: " << um[1] << endl;
    cout << "键2对应的值: " << um.at(2) << endl;
    
    // 使用find方法安全访问
    auto it = um.find(4);
    if (it != um.end()) {
        cout << "找到键4，对应的值: " << it->second << endl;
    } else {
        cout << "未找到键4" << endl;
    }
    
    // 检查键是否存在
    if (um.count(5) > 0) {
        cout << "键5存在" << endl;
    } else {
        cout << "键5不存在" << endl;
    }
    
    // 4. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    um[2] = "TWO";  // 使用下标运算符修改值
    printUnorderedMap(um, "修改键2的值后");
    
    it = um.find(3);
    if (it != um.end()) {
        it->second = "THREE";  // 通过迭代器修改值
    }
    printUnorderedMap(um, "修改键3的值后");
    
    // 5. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    um.erase(4);  // 通过键删除元素
    printUnorderedMap(um, "删除键4后");
    
    it = um.find(5);
    if (it != um.end()) {
        um.erase(it);  // 通过迭代器删除元素
    }
    printUnorderedMap(um, "删除键5后");
    
    // 删除一定范围内的元素
    auto first = um.find(2);
    auto last = um.find(6);
    if (first != um.end() && last != um.end()) {
        um.erase(first, last);  // 删除[2, 6)范围的元素
    }
    printUnorderedMap(um, "删除键2到6范围后");
    
    // 6. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int key = 3;
    it = um.find(key);
    if (it != um.end()) {
        cout << "找到键 " << key << "，对应的值: " << it->second << endl;
    } else {
        cout << "未找到键 " << key << endl;
    }
    
    // 7. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "unordered_map大小: " << um.size() << endl;
    cout << "unordered_map最大大小: " << um.max_size() << endl;
    cout << "unordered_map是否为空: " << (um.empty() ? "是" : "否") << endl;
    cout << "当前桶数量: " << um.bucket_count() << endl;
    cout << "负载因子: " << um.load_factor() << endl;
    cout << "最大负载因子: " << um.max_load_factor() << endl;
    
    // 8. 清空unordered_map
    cout << "\n=== 清空unordered_map ===" << endl;
    um.clear();
    cout << "清空后大小: " << um.size() << endl;
    cout << "清空后是否为空: " << (um.empty() ? "是" : "否") << endl;
    
    // 9. 重新填充并遍历
    cout << "\n=== 重新填充并遍历 ===" << endl;
    um = {
        {10, "ten"},
        {20, "twenty"},
        {30, "thirty"},
        {40, "forty"}
    };
    printUnorderedMap(um, "重新填充后");
    
    cout << "正向遍历: " << endl;
    for (auto it = um.begin(); it != um.end(); ++it) {
        cout << "  " << it->first << " => " << it->second << endl;
    }
    
    // 10. 交换两个unordered_map的内容
    cout << "\n=== 交换unordered_map内容 ===" << endl;
    unordered_map<int, string> um1 = {{1, "one"}, {2, "two"}};
    unordered_map<int, string> um2 = {{10, "ten"}, {20, "twenty"}, {30, "thirty"}};
    
    printUnorderedMap(um1, "um1交换前");
    printUnorderedMap(um2, "um2交换前");
    
    um1.swap(um2);
    
    printUnorderedMap(um1, "um1交换后");
    printUnorderedMap(um2, "um2交换后");
    
    // 11. 自定义比较函数的unordered_map
    cout << "\n=== 自定义哈希函数的unordered_map ===" << endl;
    // 使用自定义哈希函数的unordered_map
    unordered_map<string, int> wordCount;
    wordCount["apple"] = 5;
    wordCount["banana"] = 3;
    wordCount["cherry"] = 7;
    
    cout << "wordCount unordered_map: " << endl;
    for (const auto& pair : wordCount) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    
    // 12. 使用emplace方法添加元素
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    unordered_map<string, int> emplaceMap;
    emplaceMap.emplace("apple", 5);
    emplaceMap.emplace("banana", 3);
    emplaceMap.emplace("cherry", 7);
    
    cout << "emplaceMap: " << endl;
    for (const auto& pair : emplaceMap) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    
    // 13. 哈希策略管理
    cout << "\n=== 哈希策略管理 ===" << endl;
    unordered_map<int, string> hashMap = {{1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}, {5, "five"}};
    cout << "当前桶数量: " << hashMap.bucket_count() << endl;
    cout << "当前负载因子: " << hashMap.load_factor() << endl;
    
    // 重新哈希以减少冲突
    hashMap.rehash(20);
    cout << "重新哈希后桶数量: " << hashMap.bucket_count() << endl;
    
    // 调整最大负载因子
    hashMap.max_load_factor(0.7f);
    cout << "新最大负载因子: " << hashMap.max_load_factor() << endl;
    
    // 14. 桶接口
    cout << "\n=== 桶接口 ===" << endl;
    unordered_map<int, string> bucketMap = {{1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}, {5, "five"}, 
                                           {6, "six"}, {7, "seven"}, {8, "eight"}, {9, "nine"}, {10, "ten"}};
    
    cout << "桶数量: " << bucketMap.bucket_count() << endl;
    for (size_t i = 0; i < bucketMap.bucket_count(); ++i) {
        cout << "桶 " << i << " 有 " << bucketMap.bucket_size(i) << " 个元素: ";
        for (auto it = bucketMap.begin(i); it != bucketMap.end(i); ++it) {
            cout << it->first << "=>" << it->second << " ";
        }
        cout << endl;
    }
    
    // 15. 自定义类型的unordered_map
    cout << "\n=== 自定义类型的unordered_map ===" << endl;
    unordered_map<Person, string> personMap;
    personMap[{"Alice", 25}] = "Engineer";
    personMap[{"Bob", 30}] = "Doctor";
    personMap[{"Charlie", 35}] = "Teacher";
    
    cout << "Person map: " << endl;
    for (const auto& pair : personMap) {
        cout << "  " << pair.first.name << "(" << pair.first.age << ") => " << pair.second << endl;
    }
    
    // 查找自定义类型元素
    Person searchPerson = {"Bob", 30};
    auto personIt = personMap.find(searchPerson);
    if (personIt != personMap.end()) {
        cout << "找到: " << personIt->first.name << "(" << personIt->first.age << ") => " << personIt->second << endl;
    } else {
        cout << "未找到" << endl;
    }
    
    // 16. 处理不存在的键
    cout << "\n=== 处理不存在的键 ===" << endl;
    unordered_map<int, string> testMap = {{1, "one"}, {2, "two"}};
    
    // 使用at方法访问不存在的键会抛出异常
    try {
        cout << testMap.at(3) << endl;
    } catch (const out_of_range& e) {
        cout << "异常: " << e.what() << endl;
    }
    
    // 使用find方法安全访问
    auto found = testMap.find(3);
    if (found != testMap.end()) {
        cout << found->second << endl;
    } else {
        cout << "键3不存在" << endl;
    }
    
    // 使用下标运算符访问不存在的键会创建新元素
    cout << "访问不存在的键4: " << testMap[4] << endl;
    printUnorderedMap(testMap, "访问键4后的unordered_map");
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `unordered_map`

2. **添加元素**：
   - `insert()`: 插入键值对
   - `[]` 运算符: 通过键添加或访问值
   - `insert()` 返回一个 pair，包含迭代器和布尔值表示是否插入成功

3. **访问元素**：
   - `[]` 运算符: 通过键访问值，如果键不存在会创建新元素
   - `at()`: 通过键访问值，如果键不存在会抛出异常
   - `find()`: 查找键，返回迭代器
   - `count()`: 检查键是否存在

4. **修改元素**：
   - `[]` 运算符: 通过键修改值
   - 通过迭代器修改值

5. **删除元素**：
   - `erase()`: 通过键、迭代器或范围删除元素

6. **查找元素**：
   - `find()`: 查找指定键，返回迭代器

7. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空
   - `bucket_count()`: 获取桶的数量
   - `load_factor()`: 获取当前负载因子
   - `max_load_factor()`: 获取或设置最大负载因子

8. **清空unordered_map**：使用 `clear()` 清空所有元素

9. **遍历unordered_map**：使用迭代器遍历所有元素

10. **交换内容**：使用 `swap()` 方法交换两个unordered_map的内容

11. **自定义哈希函数**：可以使用自定义哈希函数的unordered_map

12. **使用emplace方法**：使用 `emplace()` 方法直接构造并插入键值对

13. **哈希策略管理**：
    - `rehash()`: 重新设置桶的数量
    - `max_load_factor()`: 设置最大负载因子

14. **桶接口**：
    - `bucket_count()`: 获取桶的数量
    - `bucket_size()`: 获取指定桶中的元素数量
    - `begin(bucket_index)` 和 `end(bucket_index)`: 访问指定桶中的元素

15. **自定义类型的unordered_map**：
    - 需要提供哈希函数和相等比较函数
    - 可以通过特化 `std::hash` 模板和重载 `operator==` 来实现

16. **处理不存在的键**：
    - 使用 `at()` 方法访问不存在的键会抛出异常
    - 使用 `find()` 方法安全访问
    - 使用 `[]` 运算符访问不存在的键会创建新元素

#### unordered_map 的特点

- **键值对存储**：存储键值对，键是唯一的
- **无序存储**：元素不按特定顺序存储，而是根据哈希值组织
- **高效查找**：基于哈希表实现，平均查找时间复杂度为 O(1)
- **键不可修改**：unordered_map 中的键是常量，不能直接修改
- **值可修改**：unordered_map 中的值可以修改

#### 性能考虑

- 平均情况下：
  - 插入元素：O(1) 时间复杂度
  - 删除元素：O(1) 时间复杂度
  - 查找元素：O(1) 时间复杂度
- 最坏情况下（所有元素哈希到同一个桶）：
  - 所有操作：O(n) 时间复杂度

#### 使用场景

- 需要键值对存储并且不需要排序的场景
- 需要快速通过键查找值的场景
- 对内存使用不是特别敏感的场景（哈希表通常有额外开销）

#### 注意事项

- unordered_map 中的键是常量，不能直接修改
- 使用 `[]` 运算符访问不存在的键会创建新元素
- 使用 `at()` 方法访问不存在的键会抛出异常
- 自定义类型的键需要提供哈希函数和相等比较函数
- 哈希函数的质量直接影响性能，应尽量避免哈希冲突

unordered_map 是 C++ 中一个非常有用的容器，特别适合需要快速查找而不需要排序的场景。它提供了高效的查找、插入和删除操作，是处理键值对数据的理想选择。

### Ⅳ. unordered_multimap

`std::unordered_multimap` 是 C++ 标准库中的无序关联容器，基于哈希表实现，存储键值对，允许键重复。与 `unordered_map` 不同，`unordered_multimap` 允许键重复，但不保持元素的特定顺序。以下是 unordered_multimap 的增删改查操作示例：

```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <algorithm>
using namespace std;

// 打印unordered_multimap内容
template<typename K, typename V>
void printUnorderedMultimap(const unordered_multimap<K, V>& umm, const string& name = "unordered_multimap") {
    cout << name << ": " << endl;
    for (const auto& pair : umm) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    cout << endl;
}

// 自定义哈希函数示例
struct Person {
    string name;
    int age;
    
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

namespace std {
    template<>
    struct hash<Person> {
        size_t operator()(const Person& p) const {
            return hash<string>()(p.name) ^ hash<int>()(p.age);
        }
    };
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    unordered_multimap<int, string> umm = {
        {3, "three"},
        {1, "one"},
        {4, "four"},
        {2, "two"},
        {3, "three again"},  // 重复的键
        {1, "one more"}      // 重复的键
    };
    printUnorderedMultimap(umm, "初始");
    
    // 2. 添加元素
    cout << "=== 添加元素 ===" << endl;
    umm.insert({5, "five"});  // 使用insert添加元素
    umm.insert({3, "another three"});  // 添加重复键
    printUnorderedMultimap(umm, "添加元素后");
    
    // 使用insert返回值获取插入位置
    auto result = umm.insert({2, "second two"});
    cout << "插入的键值对: " << result->first << " => " << result->second << endl;
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    // unordered_multimap不支持[]运算符，因为键可能不唯一
    
    // 使用find方法访问第一个匹配的键
    auto it = umm.find(3);
    if (it != umm.end()) {
        cout << "找到键3的第一个值: " << it->second << endl;
    }
    
    // 4. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    int key = 3;
    
    // 使用count方法获取键的出现次数
    size_t count = umm.count(key);
    cout << "键 " << key << " 出现次数: " << count << endl;
    
    // 使用equal_range获取所有匹配的键值对
    auto range = umm.equal_range(key);
    cout << "所有键为 " << key << " 的值: ";
    for (auto it = range.first; it != range.second; ++it) {
        cout << it->second << " ";
    }
    cout << endl;
    
    // 5. 修改元素
    cout << "\n=== 修改元素 ===" << endl;
    // unordered_multimap中的键是常量，不能直接修改
    // 但可以修改值（如果值不是常量）
    
    // 修改第一个键为3的值
    it = umm.find(3);
    if (it != umm.end()) {
        it->second = "modified three";
        cout << "修改后的值: " << it->second << endl;
    }
    
    // 如果要修改键，需要先删除再插入
    int oldKey = 2;
    int newKey = 20;
    string value = "twenty";
    
    // 查找所有键为2的元素
    range = umm.equal_range(oldKey);
    if (range.first != range.second) {
        // 先保存值
        vector<string> values;
        for (auto it = range.first; it != range.second; ++it) {
            values.push_back(it->second);
        }
        
        // 删除所有键为2的元素
        umm.erase(oldKey);
        
        // 插入新键值对
        for (const auto& val : values) {
            umm.insert({newKey, val});
        }
    }
    printUnorderedMultimap(umm, "修改键2为20后");
    
    // 6. 删除元素
    cout << "\n=== 删除元素 ===" << endl;
    size_t removed = umm.erase(3);  // 删除所有键为3的元素
    cout << "删除了 " << removed << " 个键为3的元素" << endl;
    printUnorderedMultimap(umm, "删除所有键3后");
    
    it = umm.find(1);
    if (it != umm.end()) {
        umm.erase(it);  // 通过迭代器删除单个元素
        printUnorderedMultimap(umm, "删除一个键1后");
    }
    
    // 删除一定范围内的元素
    auto first = umm.lower_bound(4);
    auto last = umm.upper_bound(20);
    if (first != umm.end() && last != umm.end()) {
        umm.erase(first, last);  // 删除[4, 20]范围的元素
    }
    printUnorderedMultimap(umm, "删除键4到20范围后");
    
    // 7. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "unordered_multimap大小: " << umm.size() << endl;
    cout << "unordered_multimap最大大小: " << umm.max_size() << endl;
    cout << "unordered_multimap是否为空: " << (umm.empty() ? "是" : "否") << endl;
    cout << "当前桶数量: " << umm.bucket_count() << endl;
    cout << "负载因子: " << umm.load_factor() << endl;
    cout << "最大负载因子: " << umm.max_load_factor() << endl;
    
    // 8. 清空unordered_multimap
    cout << "\n=== 清空unordered_multimap ===" << endl;
    umm.clear();
    cout << "清空后大小: " << umm.size() << endl;
    cout << "清空后是否为空: " << (umm.empty() ? "是" : "否") << endl;
    
    // 9. 重新填充并遍历
    cout << "\n=== 重新填充并遍历 ===" << endl;
    umm = {
        {10, "ten"},
        {20, "twenty"},
        {30, "thirty"},
        {20, "twenty again"},
        {10, "ten more"}
    };
    printUnorderedMultimap(umm, "重新填充后");
    
    cout << "正向遍历: " << endl;
    for (auto it = umm.begin(); it != umm.end(); ++it) {
        cout << "  " << it->first << " => " << it->second << endl;
    }
    
    // 10. 交换两个unordered_multimap的内容
    cout << "\n=== 交换unordered_multimap内容 ===" << endl;
    unordered_multimap<int, string> umm1 = {{1, "one"}, {2, "two"}, {2, "second two"}};
    unordered_multimap<int, string> umm2 = {{10, "ten"}, {20, "twenty"}, {20, "twenty again"}};
    
    printUnorderedMultimap(umm1, "umm1交换前");
    printUnorderedMultimap(umm2, "umm2交换前");
    
    umm1.swap(umm2);
    
    printUnorderedMultimap(umm1, "umm1交换后");
    printUnorderedMultimap(umm2, "umm2交换后");
    
    // 11. 使用emplace方法添加元素
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    unordered_multimap<string, int> wordCount;
    wordCount.emplace("apple", 5);
    wordCount.emplace("banana", 3);
    wordCount.emplace("apple", 2);  // 重复键
    wordCount.emplace("cherry", 7);
    
    cout << "wordCount unordered_multimap: " << endl;
    for (const auto& pair : wordCount) {
        cout << "  " << pair.first << " => " << pair.second << endl;
    }
    
    // 12. 哈希策略管理
    cout << "\n=== 哈希策略管理 ===" << endl;
    unordered_multimap<int, string> hashMultimap = {{1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}, {5, "five"}, {2, "second two"}};
    cout << "当前桶数量: " << hashMultimap.bucket_count() << endl;
    cout << "当前负载因子: " << hashMultimap.load_factor() << endl;
    
    // 重新哈希以减少冲突
    hashMultimap.rehash(20);
    cout << "重新哈希后桶数量: " << hashMultimap.bucket_count() << endl;
    
    // 调整最大负载因子
    hashMultimap.max_load_factor(0.7f);
    cout << "新最大负载因子: " << hashMultimap.max_load_factor() << endl;
    
    // 13. 桶接口
    cout << "\n=== 桶接口 ===" << endl;
    unordered_multimap<int, string> bucketMultimap = {{1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}, {5, "five"}, 
                                                     {2, "second two"}, {3, "second three"}, {6, "six"}, {7, "seven"}};
    
    cout << "桶数量: " << bucketMultimap.bucket_count() << endl;
    for (size_t i = 0; i < bucketMultimap.bucket_count(); ++i) {
        cout << "桶 " << i << " 有 " << bucketMultimap.bucket_size(i) << " 个元素: ";
        for (auto it = bucketMultimap.begin(i); it != bucketMultimap.end(i); ++it) {
            cout << it->first << "=>" << it->second << " ";
        }
        cout << endl;
    }
    
    // 14. 自定义类型的unordered_multimap
    cout << "\n=== 自定义类型的unordered_multimap ===" << endl;
    unordered_multimap<Person, string> personMultimap;
    personMultimap.insert({{"Alice", 25}, "Engineer"});
    personMultimap.insert({{"Bob", 30}, "Doctor"});
    personMultimap.insert({{"Alice", 25}, "Senior Engineer"});  // 重复键
    personMultimap.insert({{"Charlie", 35}, "Teacher"});
    
    cout << "Person multimap: " << endl;
    for (const auto& pair : personMultimap) {
        cout << "  " << pair.first.name << "(" << pair.first.age << ") => " << pair.second << endl;
    }
    
    // 查找自定义类型元素
    Person searchPerson = {"Alice", 25};
    auto personRange = personMultimap.equal_range(searchPerson);
    cout << "所有 {\"Alice\", 25} 的值: ";
    for (auto it = personRange.first; it != personRange.second; ++it) {
        cout << it->second << " ";
    }
    cout << endl;
    
    // 获取自定义类型元素的出现次数
    size_t personCount = personMultimap.count(searchPerson);
    cout << "Person {\"Alice\", 25} 出现次数: " << personCount << endl;
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：使用初始化列表创建 `unordered_multimap`，可以包含重复的键

2. **添加元素**：
   - `insert()`: 插入键值对
   - 可以插入重复键，unordered_multimap 会保持所有键值对

3. **访问元素**：
   - unordered_multimap 不支持 `[]` 运算符，因为键可能不唯一
   - 使用 `find()` 方法访问第一个匹配的键

4. **查找元素**：
   - `count()`: 返回指定键的出现次数
   - `equal_range()`: 返回匹配给定键的元素范围

5. **修改元素**：
   - unordered_multimap 中的键是常量，不能直接修改
   - 可以修改值（如果值不是常量）
   - 要修改键，需要先删除再插入

6. **删除元素**：
   - `erase()`: 删除指定键、迭代器或范围的元素
   - 删除指定键会删除所有匹配的元素

7. **查询信息**：
   - `size()`: 获取元素数量
   - `max_size()`: 获取最大容量
   - `empty()`: 检查是否为空
   - `bucket_count()`: 获取桶的数量
   - `load_factor()`: 获取当前负载因子
   - `max_load_factor()`: 获取或设置最大负载因子

8. **清空unordered_multimap**：使用 `clear()` 清空所有元素

9. **遍历unordered_multimap**：使用迭代器遍历所有元素

10. **交换内容**：使用 `swap()` 方法交换两个unordered_multimap的内容

11. **使用emplace方法**：使用 `emplace()` 方法直接构造并插入键值对

12. **哈希策略管理**：
    - `rehash()`: 重新设置桶的数量
    - `max_load_factor()`: 设置最大负载因子

13. **桶接口**：
    - `bucket_count()`: 获取桶的数量
    - `bucket_size()`: 获取指定桶中的元素数量
    - `begin(bucket_index)` 和 `end(bucket_index)`: 访问指定桶中的元素

14. **自定义类型的unordered_multimap**：
    - 需要提供哈希函数和相等比较函数
    - 可以通过特化 `std::hash` 模板和重载 `operator==` 来实现

#### unordered_multimap 的特点

- **允许重复键**：unordered_multimap 中可以包含多个相同的键
- **无序存储**：元素不按特定顺序存储，而是根据哈希值组织
- **高效查找**：基于哈希表实现，平均查找时间复杂度为 O(1)
- **键不可修改**：unordered_multimap 中的键是常量，不能直接修改
- **值可修改**：unordered_multimap 中的值可以修改

#### 性能考虑

- 平均情况下：
  - 插入元素：O(1) 时间复杂度
  - 删除元素：O(1) 时间复杂度
  - 查找元素：O(1) 时间复杂度
- 最坏情况下（所有元素哈希到同一个桶）：
  - 所有操作：O(n) 时间复杂度

#### 使用场景

- 需要键值对存储并且允许键重复的场景
- 不需要元素排序的场景
- 需要快速查找元素的场景
- 需要一对多关系的场景

#### 注意事项

- unordered_multimap 中的键是常量，不能直接修改
- unordered_multimap 不支持 `[]` 运算符，因为键可能不唯一
- 使用 `equal_range()` 方法获取所有匹配的键值对
- 自定义类型的键需要提供哈希函数和相等比较函数
- 哈希函数的质量直接影响性能，应尽量避免哈希冲突

unordered_multimap 是 C++ 中一个非常有用的容器，特别适合需要快速查找而不需要排序的场景，且允许键重复。它提供了高效的查找、插入和删除操作，是处理无序可重复键值对的理想选择。

------



## (4) 容器适配器—增删改查操作—示例代码

### Ⅰ. stack

`std::stack` 是 C++ 标准库中的容器适配器，它提供了栈的功能（后进先出，LIFO）。stack 基于其他容器（如 deque、vector 或 list）实现，默认使用 deque 作为底层容器。以下是 stack 的增删改查操作示例：

```cpp
#include <iostream>
#include <stack>
#include <vector>
#include <list>
using namespace std;

// 打印stack内容（注意：stack不支持直接遍历，需要复制）
template<typename T>
void printStack(stack<T> s, const string& name = "stack") {
    cout << name << ": ";
    while (!s.empty()) {
        cout << s.top() << " ";
        s.pop();
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    stack<int> s1; // 默认使用deque作为底层容器
    stack<int, vector<int>> s2; // 使用vector作为底层容器
    stack<int, list<int>> s3; // 使用list作为底层容器
    
    // 2. 添加元素（压栈）
    cout << "\n=== 添加元素（压栈） ===" << endl;
    s1.push(1);
    s1.push(2);
    s1.push(3);
    s1.push(4);
    s1.push(5);
    
    printStack(s1, "s1压栈后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    if (!s1.empty()) {
        cout << "栈顶元素: " << s1.top() << endl;
    }
    
    // 4. 删除元素（出栈）
    cout << "\n=== 删除元素（出栈） ===" << endl;
    s1.pop();
    cout << "出栈后栈顶元素: " << s1.top() << endl;
    
    s1.pop();
    cout << "再次出栈后栈顶元素: " << s1.top() << endl;
    
    // 5. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "栈大小: " << s1.size() << endl;
    cout << "栈是否为空: " << (s1.empty() ? "是" : "否") << endl;
    
    // 6. 清空栈
    cout << "\n=== 清空栈 ===" << endl;
    while (!s1.empty()) {
        s1.pop();
    }
    cout << "清空后栈大小: " << s1.size() << endl;
    cout << "清空后栈是否为空: " << (s1.empty() ? "是" : "否") << endl;
    
    // 7. 重新填充
    cout << "\n=== 重新填充 ===" << endl;
    for (int i = 1; i <= 5; ++i) {
        s1.push(i * 10);
    }
    printStack(s1, "重新填充后");
    
    // 8. 交换两个栈的内容
    cout << "\n=== 交换两个栈的内容 ===" << endl;
    stack<int> s4;
    for (int i = 1; i <= 3; ++i) {
        s4.push(i * 100);
    }
    
    cout << "交换前:" << endl;
    printStack(s1, "s1");
    printStack(s4, "s4");
    
    s1.swap(s4);
    
    cout << "交换后:" << endl;
    printStack(s1, "s1");
    printStack(s4, "s4");
    
    // 9. 使用emplace方法添加元素（C++11）
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    stack<pair<int, string>> s5;
    s5.emplace(1, "one");
    s5.emplace(2, "two");
    s5.emplace(3, "three");
    
    cout << "pair栈: ";
    while (!s5.empty()) {
        auto top = s5.top();
        cout << "(" << top.first << ", " << top.second << ") ";
        s5.pop();
    }
    cout << endl;
    
    // 10. 栈的应用示例：括号匹配
    cout << "\n=== 栈的应用示例：括号匹配 ===" << endl;
    string expression = "({[]})";
    stack<char> bracketStack;
    bool valid = true;
    
    for (char c : expression) {
        if (c == '(' || c == '{' || c == '[') {
            bracketStack.push(c);
        } else {
            if (bracketStack.empty()) {
                valid = false;
                break;
            }
            
            char top = bracketStack.top();
            bracketStack.pop();
            
            if ((c == ')' && top != '(') ||
                (c == '}' && top != '{') ||
                (c == ']' && top != '[')) {
                valid = false;
                break;
            }
        }
    }
    
    if (!bracketStack.empty()) {
        valid = false;
    }
    
    cout << "表达式 \"" << expression << "\" 的括号匹配: " << (valid ? "有效" : "无效") << endl;
    
    // 11. 栈的应用示例：十进制转二进制
    cout << "\n=== 栈的应用示例：十进制转二进制 ===" << endl;
    int decimal = 42;
    stack<int> binaryStack;
    
    int temp = decimal;
    while (temp > 0) {
        binaryStack.push(temp % 2);
        temp /= 2;
    }
    
    cout << decimal << " 的二进制表示: ";
    while (!binaryStack.empty()) {
        cout << binaryStack.top();
        binaryStack.pop();
    }
    cout << endl;
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：
   - 默认使用 deque 作为底层容器
   - 可以指定其他容器（如 vector 或 list）作为底层容器

2. **添加元素（压栈）**：
   - `push()`: 将元素压入栈顶

3. **访问元素**：
   - `top()`: 访问栈顶元素（不删除）
   - 注意：stack 只允许访问栈顶元素

4. **删除元素（出栈）**：
   - `pop()`: 删除栈顶元素

5. **查询信息**：
   - `size()`: 获取元素数量
   - `empty()`: 检查栈是否为空

6. **清空栈**：通过循环调用 `pop()` 方法清空栈

7. **重新填充**：使用循环和 `push()` 方法重新填充栈

8. **交换内容**：使用 `swap()` 方法交换两个栈的内容

9. **使用emplace方法**：使用 `emplace()` 方法直接构造并压入元素（C++11）

10. **栈的应用示例：括号匹配**：
    - 使用栈检查表达式中的括号是否匹配

11. **栈的应用示例：十进制转二进制**：
    - 使用栈将十进制数转换为二进制表示

#### stack 的特点

- **后进先出（LIFO）**：最后压入的元素最先弹出
- **受限访问**：只能访问栈顶元素
- **基于其他容器**：stack 是容器适配器，基于其他容器实现
- **不支持遍历**：不能直接遍历 stack 中的所有元素
- **高效操作**：压栈和出栈操作的时间复杂度为 O(1)

#### 性能考虑

- 压栈操作：O(1) 时间复杂度
- 出栈操作：O(1) 时间复杂度
- 访问栈顶元素：O(1) 时间复杂度

#### 使用场景

- 需要后进先出（LIFO）行为的场景
- 算法中需要临时存储和恢复状态的场景
- 括号匹配、表达式求值等算法
- 深度优先搜索（DFS）算法
- 撤销/重做功能实现

#### 注意事项

- stack 不支持直接遍历，需要复制栈或使用其他方法访问所有元素
- 调用 `top()` 或 `pop()` 前应确保栈不为空，否则会导致未定义行为
- stack 是容器适配器，不是完整的容器，功能相对有限
- 可以选择不同的底层容器来优化特定用例的性能

#### 底层容器选择

- **deque**（默认）：平衡了性能和功能，适合大多数情况
- **vector**：可能提供更好的缓存性能，但增长时需要重新分配内存
- **list**：每次操作都需要分配/释放内存，但不会发生重新分配

stack 是 C++ 中一个简单但强大的容器适配器，特别适合需要后进先出行为的场景。它提供了高效的压栈和出栈操作，是许多算法和数据结构的基础。

### Ⅱ. queue

`std::queue` 是 C++ 标准库中的容器适配器，它提供了队列的功能（先进先出，FIFO）。queue 基于其他容器（如 deque 或 list）实现，默认使用 deque 作为底层容器。以下是 queue 的增删改查操作示例：

```cpp
#include <iostream>
#include <queue>
#include <list>
#include <vector>
using namespace std;

// 打印queue内容（注意：queue不支持直接遍历，需要复制）
template<typename T>
void printQueue(queue<T> q, const string& name = "queue") {
    cout << name << ": ";
    while (!q.empty()) {
        cout << q.front() << " ";
        q.pop();
    }
    cout << endl;
}

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    queue<int> q1; // 默认使用deque作为底层容器
    queue<int, list<int>> q2; // 使用list作为底层容器
    queue<int, vector<int>> q3; // 使用vector作为底层容器（注意：vector不支持pop_front）
    
    // 2. 添加元素（入队）
    cout << "\n=== 添加元素（入队） ===" << endl;
    q1.push(1);
    q1.push(2);
    q1.push(3);
    q1.push(4);
    q1.push(5);
    
    printQueue(q1, "q1入队后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    if (!q1.empty()) {
        cout << "队首元素: " << q1.front() << endl;
        cout << "队尾元素: " << q1.back() << endl;
    }
    
    // 4. 删除元素（出队）
    cout << "\n=== 删除元素（出队） ===" << endl;
    q1.pop();
    cout << "出队后队首元素: " << q1.front() << endl;
    cout << "出队后队尾元素: " << q1.back() << endl;
    
    q1.pop();
    cout << "再次出队后队首元素: " << q1.front() << endl;
    
    // 5. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "队列大小: " << q1.size() << endl;
    cout << "队列是否为空: " << (q1.empty() ? "是" : "否") << endl;
    
    // 6. 清空队列
    cout << "\n=== 清空队列 ===" << endl;
    while (!q1.empty()) {
        q1.pop();
    }
    cout << "清空后队列大小: " << q1.size() << endl;
    cout << "清空后队列是否为空: " << (q1.empty() ? "是" : "否") << endl;
    
    // 7. 重新填充
    cout << "\n=== 重新填充 ===" << endl;
    for (int i = 1; i <= 5; ++i) {
        q1.push(i * 10);
    }
    printQueue(q1, "重新填充后");
    
    // 8. 交换两个队列的内容
    cout << "\n=== 交换两个队列的内容 ===" << endl;
    queue<int> q4;
    for (int i = 1; i <= 3; ++i) {
        q4.push(i * 100);
    }
    
    cout << "交换前:" << endl;
    printQueue(q1, "q1");
    printQueue(q4, "q4");
    
    q1.swap(q4);
    
    cout << "交换后:" << endl;
    printQueue(q1, "q1");
    printQueue(q4, "q4");
    
    // 9. 使用emplace方法添加元素（C++11）
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    queue<pair<int, string>> q5;
    q5.emplace(1, "one");
    q5.emplace(2, "two");
    q5.emplace(3, "three");
    
    cout << "pair队列: ";
    while (!q5.empty()) {
        auto front = q5.front();
        cout << "(" << front.first << ", " << front.second << ") ";
        q5.pop();
    }
    cout << endl;
    
    // 10. 队列的应用示例：广度优先搜索模拟
    cout << "\n=== 队列的应用示例：广度优先搜索模拟 ===" << endl;
    queue<int> bfsQueue;
    vector<bool> visited(6, false);
    
    // 模拟图的邻接表
    vector<vector<int>> graph = {
        {1, 2},     // 节点0的邻居
        {0, 3, 4},  // 节点1的邻居
        {0, 5},     // 节点2的邻居
        {1},        // 节点3的邻居
        {1},        // 节点4的邻居
        {2}         // 节点5的邻居
    };
    
    // 从节点0开始BFS
    bfsQueue.push(0);
    visited[0] = true;
    
    cout << "BFS遍历顺序: ";
    while (!bfsQueue.empty()) {
        int current = bfsQueue.front();
        bfsQueue.pop();
        cout << current << " ";
        
        // 访问所有未访问的邻居
        for (int neighbor : graph[current]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                bfsQueue.push(neighbor);
            }
        }
    }
    cout << endl;
    
    // 11. 队列的应用示例：任务调度
    cout << "\n=== 队列的应用示例：任务调度 ===" << endl;
    queue<string> taskQueue;
    
    // 添加任务
    taskQueue.push("任务1: 处理用户输入");
    taskQueue.push("任务2: 更新界面");
    taskQueue.push("任务3: 保存数据");
    taskQueue.push("任务4: 发送网络请求");
    
    cout << "任务执行顺序:" << endl;
    int taskCount = 1;
    while (!taskQueue.empty()) {
        cout << "执行 " << taskQueue.front() << endl;
        taskQueue.pop();
        taskCount++;
    }
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：
   - 默认使用 deque 作为底层容器
   - 可以指定其他容器（如 list 或 vector）作为底层容器
   - 注意：vector 不支持 `pop_front()`，因此使用 vector 作为底层容器时需要谨慎

2. **添加元素（入队）**：
   - `push()`: 将元素添加到队尾

3. **访问元素**：
   - `front()`: 访问队首元素（不删除）
   - `back()`: 访问队尾元素（不删除）

4. **删除元素（出队）**：
   - `pop()`: 删除队首元素

5. **查询信息**：
   - `size()`: 获取元素数量
   - `empty()`: 检查队列是否为空

6. **清空队列**：通过循环调用 `pop()` 方法清空队列

7. **重新填充**：使用循环和 `push()` 方法重新填充队列

8. **交换内容**：使用 `swap()` 方法交换两个队列的内容

9. **使用emplace方法**：使用 `emplace()` 方法直接构造并添加元素（C++11）

10. **队列的应用示例：广度优先搜索模拟**：
    - 使用队列实现广度优先搜索（BFS）算法

11. **队列的应用示例：任务调度**：
    - 使用队列实现简单的任务调度系统

#### queue 的特点

- **先进先出（FIFO）**：最先添加的元素最先被移除
- **受限访问**：只能访问队首和队尾元素
- **基于其他容器**：queue 是容器适配器，基于其他容器实现
- **不支持遍历**：不能直接遍历 queue 中的所有元素
- **高效操作**：入队和出队操作的时间复杂度为 O(1)

#### 性能考虑

- 入队操作：O(1) 时间复杂度
- 出队操作：O(1) 时间复杂度
- 访问队首和队尾元素：O(1) 时间复杂度

#### 使用场景

- 需要先进先出（FIFO）行为的场景
- 广度优先搜索（BFS）算法
- 任务调度系统
- 消息队列实现
- 缓冲区管理

#### 注意事项

- queue 不支持直接遍历，需要复制队列或使用其他方法访问所有元素
- 调用 `front()`、`back()` 或 `pop()` 前应确保队列不为空，否则会导致未定义行为
- queue 是容器适配器，不是完整的容器，功能相对有限
- 可以选择不同的底层容器来优化特定用例的性能

#### 底层容器选择

- **deque**（默认）：平衡了性能和功能，适合大多数情况
- **list**：每次操作都需要分配/释放内存，但不会发生重新分配
- **vector**：可能提供更好的缓存性能，但需要自定义实现来支持队列操作（因为 vector 没有 `pop_front()`）

queue 是 C++ 中一个简单但强大的容器适配器，特别适合需要先进先出行为的场景。它提供了高效的入队和出队操作，是许多算法和系统设计的基础。

### Ⅲ. priority_queue

`std::priority_queue` 是 C++ 标准库中的容器适配器，它提供了优先队列的功能（元素按优先级排序，优先级最高的元素始终在队首）。priority_queue 基于其他容器（如 vector 或 deque）实现，默认使用 vector 作为底层容器。以下是 priority_queue 的增删改查操作示例：

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <functional> // 用于std::greater
using namespace std;

// 打印priority_queue内容（注意：priority_queue不支持直接遍历，需要复制）
template<typename T>
void printPriorityQueue(priority_queue<T> pq, const string& name = "priority_queue") {
    cout << name << ": ";
    while (!pq.empty()) {
        cout << pq.top() << " ";
        pq.pop();
    }
    cout << endl;
}

// 自定义比较函数，用于创建最小堆
struct Compare {
    bool operator()(int a, int b) {
        return a > b; // 最小堆
    }
};

// 自定义数据类型
struct Task {
    int priority;
    string description;
    
    // 重载<运算符，用于默认比较
    bool operator<(const Task& other) const {
        return priority < other.priority; // 数字越大优先级越高
    }
    
    // 重载输出运算符，方便打印
    friend ostream& operator<<(ostream& os, const Task& task) {
        os << "[" << task.priority << ": " << task.description << "]";
        return os;
    }
};

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    priority_queue<int> pq1; // 默认最大堆，使用vector作为底层容器
    
    // 2. 添加元素（入队）
    cout << "\n=== 添加元素（入队） ===" << endl;
    pq1.push(30);
    pq1.push(10);
    pq1.push(50);
    pq1.push(20);
    pq1.push(40);
    
    printPriorityQueue(pq1, "pq1入队后");
    
    // 3. 访问元素
    cout << "\n=== 访问元素 ===" << endl;
    if (!pq1.empty()) {
        cout << "队首元素（最高优先级）: " << pq1.top() << endl;
    }
    
    // 4. 删除元素（出队）
    cout << "\n=== 删除元素（出队） ===" << endl;
    pq1.pop();
    cout << "出队后队首元素: " << pq1.top() << endl;
    
    pq1.pop();
    cout << "再次出队后队首元素: " << pq1.top() << endl;
    
    // 5. 查询信息
    cout << "\n=== 查询信息 ===" << endl;
    cout << "优先队列大小: " << pq1.size() << endl;
    cout << "优先队列是否为空: " << (pq1.empty() ? "是" : "否") << endl;
    
    // 6. 清空优先队列
    cout << "\n=== 清空优先队列 ===" << endl;
    while (!pq1.empty()) {
        pq1.pop();
    }
    cout << "清空后优先队列大小: " << pq1.size() << endl;
    cout << "清空后优先队列是否为空: " << (pq1.empty() ? "是" : "否") << endl;
    
    // 7. 重新填充
    cout << "\n=== 重新填充 ===" << endl;
    for (int i = 1; i <= 5; ++i) {
        pq1.push(i * 10);
    }
    printPriorityQueue(pq1, "重新填充后");
    
    // 8. 创建最小堆
    cout << "\n=== 创建最小堆 ===" << endl;
    // 方法1：使用std::greater
    priority_queue<int, vector<int>, greater<int>> minHeap1;
    minHeap1.push(30);
    minHeap1.push(10);
    minHeap1.push(50);
    minHeap1.push(20);
    minHeap1.push(40);
    
    cout << "最小堆1: ";
    while (!minHeap1.empty()) {
        cout << minHeap1.top() << " ";
        minHeap1.pop();
    }
    cout << endl;
    
    // 方法2：使用自定义比较函数
    priority_queue<int, vector<int>, Compare> minHeap2;
    minHeap2.push(30);
    minHeap2.push(10);
    minHeap2.push(50);
    minHeap2.push(20);
    minHeap2.push(40);
    
    cout << "最小堆2: ";
    while (!minHeap2.empty()) {
        cout << minHeap2.top() << " ";
        minHeap2.pop();
    }
    cout << endl;
    
    // 9. 使用自定义数据类型
    cout << "\n=== 使用自定义数据类型 ===" << endl;
    priority_queue<Task> taskQueue;
    
    taskQueue.push({3, "低优先级任务"});
    taskQueue.push({1, "最低优先级任务"});
    taskQueue.push({5, "最高优先级任务"});
    taskQueue.push({2, "较低优先级任务"});
    taskQueue.push({4, "高优先级任务"});
    
    cout << "任务执行顺序:" << endl;
    while (!taskQueue.empty()) {
        cout << "执行 " << taskQueue.top() << endl;
        taskQueue.pop();
    }
    
    // 10. 使用emplace方法添加元素（C++11）
    cout << "\n=== 使用emplace方法添加元素 ===" << endl;
    priority_queue<Task> emplaceQueue;
    emplaceQueue.emplace(Task{3, "低优先级任务"});
    emplaceQueue.emplace(Task{1, "最低优先级任务"});
    emplaceQueue.emplace(Task{5, "最高优先级任务"});
    
    cout << "emplace队列: ";
    while (!emplaceQueue.empty()) {
        cout << emplaceQueue.top() << " ";
        emplaceQueue.pop();
    }
    cout << endl;
    
    // 11. 优先队列的应用示例：合并K个有序数组
    cout << "\n=== 优先队列的应用示例：合并K个有序数组 ===" << endl;
    vector<vector<int>> arrays = {
        {1, 4, 7},
        {2, 5, 8},
        {3, 6, 9}
    };
    
    // 使用最小堆合并数组
    priority_queue<pair<int, pair<int, int>>, 
                   vector<pair<int, pair<int, int>>>,
                   greater<pair<int, pair<int, int>>>> minHeap;
    
    // 将每个数组的第一个元素加入堆
    for (int i = 0; i < arrays.size(); i++) {
        if (!arrays[i].empty()) {
            minHeap.push({arrays[i][0], {i, 0}});
        }
    }
    
    vector<int> merged;
    while (!minHeap.empty()) {
        auto top = minHeap.top();
        minHeap.pop();
        
        int value = top.first;
        int arrayIndex = top.second.first;
        int elementIndex = top.second.second;
        
        merged.push_back(value);
        
        // 如果当前数组还有更多元素，将下一个元素加入堆
        if (elementIndex + 1 < arrays[arrayIndex].size()) {
            minHeap.push({arrays[arrayIndex][elementIndex + 1], {arrayIndex, elementIndex + 1}});
        }
    }
    
    cout << "合并后的数组: ";
    for (int num : merged) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：
   - 默认使用 vector 作为底层容器，创建最大堆
   - 可以指定其他容器（如 deque）作为底层容器

2. **添加元素（入队）**：
   - `push()`: 将元素添加到优先队列中，自动按优先级排序

3. **访问元素**：
   - `top()`: 访问队首元素（最高优先级元素，不删除）

4. **删除元素（出队）**：
   - `pop()`: 删除队首元素（最高优先级元素）

5. **查询信息**：
   - `size()`: 获取元素数量
   - `empty()`: 检查优先队列是否为空

6. **清空优先队列**：通过循环调用 `pop()` 方法清空优先队列

7. **重新填充**：使用循环和 `push()` 方法重新填充优先队列

8. **创建最小堆**：
   - 使用 `std::greater` 作为比较函数
   - 使用自定义比较函数

9. **使用自定义数据类型**：
   - 需要重载 `<` 运算符或提供自定义比较函数
   - 可以重载输出运算符以便打印

10. **使用emplace方法**：使用 `emplace()` 方法直接构造并添加元素（C++11）

11. **优先队列的应用示例：合并K个有序数组**：
    - 使用最小堆高效合并多个有序数组

#### priority_queue 的特点

- **按优先级排序**：元素按优先级排序，优先级最高的元素始终在队首
- **受限访问**：只能访问队首元素
- **基于其他容器**：priority_queue 是容器适配器，基于其他容器实现
- **不支持遍历**：不能直接遍历 priority_queue 中的所有元素
- **高效操作**：插入和删除操作的时间复杂度为 O(log n)

#### 性能考虑

- 插入操作：O(log n) 时间复杂度
- 删除操作：O(log n) 时间复杂度
- 访问队首元素：O(1) 时间复杂度

#### 使用场景

- 需要按优先级处理元素的场景
- 任务调度系统（高优先级任务优先执行）
- 寻找最大或最小的K个元素
- 合并多个有序序列
- 实现Dijkstra算法等图算法

#### 注意事项

- priority_queue 不支持直接遍历，需要复制队列或使用其他方法访问所有元素
- 调用 `top()` 或 `pop()` 前应确保队列不为空，否则会导致未定义行为
- priority_queue 是容器适配器，不是完整的容器，功能相对有限
- 自定义数据类型需要提供比较方法（重载 `<` 运算符或提供自定义比较函数）

#### 底层容器选择

- **vector**（默认）：提供良好的缓存性能，适合大多数情况
- **deque**：在某些情况下可能提供更好的性能

priority_queue 是 C++ 中一个强大的容器适配器，特别适合需要按优先级处理元素的场景。它提供了高效的插入和删除操作，是许多算法和系统设计的基础。

------



## (5) 伪容器—增删改查操作—示例代码

### Ⅰ. string

`std::string` 是 C++ 标准库中用于处理字符串的类，它提供了丰富的成员函数来操作字符串。以下是 string 的增删改查操作示例：

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype> // 用于字符处理函数
using namespace std;

int main() {
    // 1. 创建和初始化
    cout << "=== 创建和初始化 ===" << endl;
    string s1; // 空字符串
    string s2 = "Hello, World!"; // 从C风格字符串初始化
    string s3("C++ String"); // 构造函数初始化
    string s4(5, 'a'); // 包含5个'a'的字符串
    string s5(s2); // 拷贝构造
    string s6 = s2.substr(0, 5); // 从s2的子串初始化
    
    cout << "s1: " << s1 << endl;
    cout << "s2: " << s2 << endl;
    cout << "s3: " << s3 << endl;
    cout << "s4: " << s4 << endl;
    cout << "s5: " << s5 << endl;
    cout << "s6: " << s6 << endl;
    
    // 2. 添加元素（增）
    cout << "\n=== 添加元素（增） ===" << endl;
    s1 = "Hello";
    s1 += " World"; // 使用+=运算符添加
    cout << "s1 += \" World\": " << s1 << endl;
    
    s1.append("!!!"); // 使用append方法添加
    cout << "s1.append(\"!!!\"): " << s1 << endl;
    
    s1.push_back('?'); // 在末尾添加单个字符
    cout << "s1.push_back('?'): " << s1 << endl;
    
    s1.insert(5, ","); // 在指定位置插入
    cout << "s1.insert(5, \",\"): " << s1 << endl;
    
    // 3. 访问元素（查）
    cout << "\n=== 访问元素（查） ===" << endl;
    string s = "Hello, World!";
    cout << "字符串: " << s << endl;
    cout << "长度: " << s.length() << endl;
    cout << "是否为空: " << (s.empty() ? "是" : "否") << endl;
    cout << "第一个字符: " << s[0] << endl;
    cout << "第一个字符(使用at): " << s.at(0) << endl;
    cout << "最后一个字符: " << s.back() << endl;
    cout << "C风格字符串: " << s.c_str() << endl;
    
    // 4. 查找元素
    cout << "\n=== 查找元素 ===" << endl;
    size_t pos = s.find("World");
    if (pos != string::npos) {
        cout << "找到 'World' 在位置: " << pos << endl;
    } else {
        cout << "未找到 'World'" << endl;
    }
    
    pos = s.find('o');
    if (pos != string::npos) {
        cout << "找到 'o' 在位置: " << pos << endl;
    }
    
    pos = s.find('o', pos + 1); // 从下一个位置开始查找
    if (pos != string::npos) {
        cout << "找到第二个 'o' 在位置: " << pos << endl;
    }
    
    // 查找最后一次出现
    pos = s.rfind('o');
    if (pos != string::npos) {
        cout << "从后向前找到 'o' 在位置: " << pos << endl;
    }
    
    // 查找第一个匹配的字符
    pos = s.find_first_of("aeiou");
    if (pos != string::npos) {
        cout << "找到第一个元音字母在位置: " << pos << endl;
    }
    
    // 查找第一个不匹配的字符
    pos = s.find_first_not_of("Helo, Wrld!");
    if (pos != string::npos) {
        cout << "找到第一个不匹配的字符在位置: " << pos << endl;
    }
    
    // 5. 修改元素（改）
    cout << "\n=== 修改元素（改） ===" << endl;
    s = "Hello, World!";
    cout << "原始字符串: " << s << endl;
    
    s[7] = 'w'; // 使用下标修改
    cout << "s[7] = 'w': " << s << endl;
    
    s.at(7) = 'W'; // 使用at修改
    cout << "s.at(7) = 'W': " << s << endl;
    
    s.replace(7, 5, "C++"); // 替换子串
    cout << "s.replace(7, 5, \"C++\"): " << s << endl;
    
    // 6. 删除元素（删）
    cout << "\n=== 删除元素（删） ===" << endl;
    s = "Hello, World!";
    cout << "原始字符串: " << s << endl;
    
    s.pop_back(); // 删除最后一个字符
    cout << "s.pop_back(): " << s << endl;
    
    s.erase(5, 2); // 从位置5开始删除2个字符
    cout << "s.erase(5, 2): " << s << endl;
    
    s.erase(5); // 从位置5开始删除到末尾
    cout << "s.erase(5): " << s << endl;
    
    s.clear(); // 清空字符串
    cout << "s.clear(): " << s << " (空字符串)" << endl;
    
    // 7. 子串操作
    cout << "\n=== 子串操作 ===" << endl;
    s = "Hello, World!";
    string sub = s.substr(7, 5); // 从位置7开始，取5个字符
    cout << "s.substr(7, 5): " << sub << endl;
    
    sub = s.substr(7); // 从位置7开始到末尾
    cout << "s.substr(7): " << sub << endl;
    
    // 8. 比较操作
    cout << "\n=== 比较操作 ===" << endl;
    string a = "apple";
    string b = "banana";
    
    int result = a.compare(b);
    if (result < 0) {
        cout << a << " < " << b << endl;
    } else if (result > 0) {
        cout << a << " > " << b << endl;
    } else {
        cout << a << " == " << b << endl;
    }
    
    // 使用运算符比较
    if (a < b) {
        cout << a << " < " << b << endl;
    }
    
    // 9. 字符串转换
    cout << "\n=== 字符串转换 ===" << endl;
    s = "123";
    int num = stoi(s); // 字符串转整数
    cout << "stoi(\"" << s << "\") = " << num << endl;
    
    s = "3.14";
    double pi = stod(s); // 字符串转浮点数
    cout << "stod(\"" << s << "\") = " << pi << endl;
    
    num = 456;
    s = to_string(num); // 数字转字符串
    cout << "to_string(456) = " << s << endl;
    
    // 10. 字符串处理
    cout << "\n=== 字符串处理 ===" << endl;
    s = "   Hello, World!   ";
    cout << "原始字符串: \"" << s << "\"" << endl;
    
    // 去除前后空格
    size_t start = s.find_first_not_of(" ");
    size_t end = s.find_last_not_of(" ");
    if (start != string::npos && end != string::npos) {
        s = s.substr(start, end - start + 1);
    }
    cout << "去除空格后: \"" << s << "\"" << endl;
    
    // 转换为大写
    for (char &c : s) {
        c = toupper(c);
    }
    cout << "转换为大写: " << s << endl;
    
    // 转换为小写
    for (char &c : s) {
        c = tolower(c);
    }
    cout << "转换为小写: " << s << endl;
    
    // 11. 字符串拼接
    cout << "\n=== 字符串拼接 ===" << endl;
    string part1 = "Hello";
    string part2 = "World";
    string combined = part1 + ", " + part2 + "!";
    cout << "拼接结果: " << combined << endl;
    
    // 12. 使用迭代器
    cout << "\n=== 使用迭代器 ===" << endl;
    s = "Hello";
    cout << "使用迭代器遍历: ";
    for (auto it = s.begin(); it != s.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    cout << "使用反向迭代器遍历: ";
    for (auto it = s.rbegin(); it != s.rend(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 13. 字符串搜索和替换所有匹配项
    cout << "\n=== 字符串搜索和替换所有匹配项 ===" << endl;
    s = "I like cats. Cats are cute. I have a cat.";
    cout << "原始字符串: " << s << endl;
    
    string search = "cat";
    string replace = "dog";
    size_t pos = 0;
    
    while ((pos = s.find(search, pos)) != string::npos) {
        s.replace(pos, search.length(), replace);
        pos += replace.length();
    }
    
    cout << "替换所有 'cat' 为 'dog': " << s << endl;
    
    // 14. 字符串分割
    cout << "\n=== 字符串分割 ===" << endl;
    s = "apple,banana,cherry,date";
    cout << "原始字符串: " << s << endl;
    
    size_t start = 0;
    size_t end = s.find(',');
    
    cout << "分割结果: ";
    while (end != string::npos) {
        cout << s.substr(start, end - start) << " ";
        start = end + 1;
        end = s.find(',', start);
    }
    cout << s.substr(start) << endl;
    
    return 0;
}
```

#### 代码说明

1. **创建和初始化**：
   - 多种方式创建和初始化字符串
   - 使用构造函数、赋值运算符、substr等方法

2. **添加元素（增）**：
   - `+=` 运算符：追加字符串
   - `append()`：追加字符串
   - `push_back()`：在末尾添加单个字符
   - `insert()`：在指定位置插入字符串

3. **访问元素（查）**：
   - `length()` 或 `size()`：获取字符串长度
   - `empty()`：检查字符串是否为空
   - `[]` 运算符：通过索引访问字符
   - `at()`：通过索引访问字符（带边界检查）
   - `back()`：访问最后一个字符
   - `c_str()`：获取C风格字符串

4. **查找元素**：
   - `find()`：查找子字符串或字符
   - `rfind()`：从后向前查找
   - `find_first_of()`：查找第一个匹配的字符
   - `find_first_not_of()`：查找第一个不匹配的字符

5. **修改元素（改）**：
   - `[]` 运算符：通过索引修改字符
   - `at()`：通过索引修改字符（带边界检查）
   - `replace()`：替换子字符串

6. **删除元素（删）**：
   - `pop_back()`：删除最后一个字符
   - `erase()`：删除指定位置或范围的字符
   - `clear()`：清空整个字符串

7. **子串操作**：
   - `substr()`：获取子字符串

8. **比较操作**：
   - `compare()`：比较两个字符串
   - 使用比较运算符（==, !=, <, >, <=, >=）

9. **字符串转换**：
   - `stoi()`, `stol()`, `stoll()`：字符串转整数
   - `stof()`, `stod()`, `stold()`：字符串转浮点数
   - `to_string()`：数字转字符串

10. **字符串处理**：
    - 去除前后空格
    - 转换为大写或小写
    - 使用算法处理字符串

11. **字符串拼接**：
    - 使用 `+` 运算符拼接字符串

12. **使用迭代器**：
    - 使用正向和反向迭代器遍历字符串

13. **字符串搜索和替换所有匹配项**：
    - 使用循环查找和替换所有匹配的子字符串

14. **字符串分割**：
    - 使用 `find()` 和 `substr()` 实现字符串分割

#### string 的特点

- **动态大小**：string 可以动态增长和缩小
- **丰富的API**：提供了大量的成员函数来操作字符串
- **内存管理**：自动处理内存分配和释放
- **兼容性**：可以与C风格字符串互操作
- **安全性**：提供了带边界检查的访问方法（如at()）

#### 性能考虑

- 字符串拼接：使用 `+=` 或 `append()` 通常比使用 `+` 运算符更高效
- 字符串查找：查找操作的时间复杂度取决于算法实现
- 内存分配：频繁的字符串操作可能导致多次内存重新分配

#### 使用场景

- 文本处理和解析
- 用户输入处理
- 文件内容处理
- 数据格式转换
- 字符串匹配和搜索

#### 注意事项

- 使用 `at()` 方法访问字符时会进行边界检查，越界会抛出异常
- 使用 `[]` 运算符访问字符时不进行边界检查，越界会导致未定义行为
- 字符串操作可能涉及内存重新分配，需要注意性能
- 与C风格字符串互操作时，需要注意字符串结束符('\0')

string 是 C++ 中一个非常强大和灵活的类，提供了丰富的功能来处理文本数据。掌握 string 的各种操作对于C++编程非常重要。

------



## 4. 容器选择指南

#### a. 选择序列容器的考虑因素：
1. **需要随机访问**：选择 `vector` 或 `array`
2. **需要频繁在两端插入删除**：选择 `deque`
3. **需要频繁在中间插入删除**：选择 `list` 或 `forward_list`
4. **需要固定大小**：选择 `array`
5. **需要位级操作**：选择 `bitset`
6. **需要高效数值运算**：选择`valarray`

#### b. 选择关联容器的考虑因素：
1. **需要元素自动排序**：选择 `set`、`multiset`、`map` 或 `multimap`
2. **需要快速查找**：选择 `unordered_set`、`unordered_multiset`、`unordered_map` 或 `unordered_multimap`
3. **需要键值对**：选择 `map`、`multimap`、`unordered_map` 或 `unordered_multimap`
4. **允许重复键**：选择 `multiset`、`multimap`、`unordered_multiset` 或 `unordered_multimap`

#### c. 选择容器适配器的考虑因素：
1. **需要后进先出(LIFO)**：选择 `stack`
2. **需要先进先出(FIFO)**：选择 `queue`
3. **需要按优先级处理**：选择 `priority_queue`

#### d. 性能特点总结

1. **随机访问**：`array`、`vector`、`deque` 提供 O(1) 随机访问
2. **插入删除**：
   - 末尾：`vector`、`deque` 为 O(1)
   - 开头：`deque` 为 O(1)，`vector` 为 O(n)
   - 中间：`list`、`forward_list` 为 O(1)（已知位置）
3. **查找**：
   - 关联容器：O(log n)
   - 无序关联容器：平均 O(1)，最坏 O(n)
   - 序列容器：O(n)

#### e. 注意事项

1. **迭代器失效**：不同容器的插入删除操作可能导致迭代器失效，需特别注意
2. **内存管理**：`vector` 的动态扩容可能导致内存重新分配
3. **哈希冲突**：无序容器的性能取决于哈希函数质量和负载因子
4. **自定义比较器**：关联容器和无序容器支持自定义比较器和哈希函数

   ------

   

## 5. 容器视图

### (1) 概述

#### `string_view`：适配“字符串”伪容器

- **适配对象**： `std::string`、C风格字符串（`const char*`）、字符数组（`char array[N]`）等。
- **核心要求**： 存储连续分布的字符序列，并以空终止符`'\0'`结尾（尽管`string_view`本身不依赖空终止符来计算长度，但它通常表示一个来自以空字符结尾的字符串的一部分）。
- **特性**： `std::string` 在标准库中被归类为“伪容器”，它具备序列容器的许多特性（如连续存储、随机访问迭代器等），但它的API是专门为字符串操作设计的。因此，`string_view`是一个专门化的字符串视图。

- **用途**：提供对字符串数据的只读视图
- **优势**：避免字符串拷贝，提高性能
- **注意**：不拥有数据，需要确保原数据的生命周期

#### `span`：一维连续序列视图

- **适配对象**： 任何提供**连续内存布局**的对象。
- **这主要包括**：
  1. **C风格数组**： `int arr[10];`
  2. **标准库【序列容器】**：
     - `std::array<T, N>`
     - `std::vector<T>`
     - `std::string` (本质上也是一个`vector<char>`)
  3. **内置的 `std::initializer_list`**
  4. 另一个 `span` 的子集
  5. 任何自定义的、能提供`data()`和`size()`成员函数且数据是连续存储的对象。

- **用途**：提供对连续数据序列的安全访问
- **优势**：替代指针和长度参数，更安全且提供边界检查
- **注意**：**可以是只读 (`span<const T>`) 或可变 (`span<T>`)**（`std::span` 不传播 `const`，因此要构造一个只读的 `std::span`，请使用 `std::span<const T>`。）

#### `mdspan`：多维连续序列视图

- **适配对象**： `mdspan` 是 `span` 的多维扩展。它适配的是**连续存储的多维数据**。
- **这主要包括**：
  1. **“平坦”的一维数组（模拟多维）**： 这是最常见的情况。例如，一个 `std::vector<double>` 可以被 `mdspan` 解释为一个 5x5 的二维矩阵（25个元素）、一个 3x3x3 的三维张量等。`mdspan` 通过**映射（Layout）** 来定义一维索引到多维索引的转换关系。
  2. **真正的多维数组**： 如 `double buffer[8][8][8];`。
  3. 任何能提供访问其连续存储数据的对象。
- **同样的限制**： 它也无法适配内存不连续的关联容器和接口不暴露底层数据的容器适配器。

- **用途**：提供对多维数据的安全访问
- **优势**：提供多维数组视图，支持不同布局策略
- **注意**：C++23 特性，可能需要最新编译器支持



`span/mdspan`**为什么不适配关联/无序关联容器？**

- **内存布局**： 关联容器（如 `std::map`, `std::set`）和无序关联容器（如 `std::unordered_map`, `std::unordered_set`）的元素在内存中是**不连续**的。它们通常由节点（Node）通过指针链接而成，无法用一个指针（起始地址）和一个长度来表示一段连续的内存。
- **访问模式**： `span` 提供对元素的快速、随机访问（`O(1)`），这正符合序列容器的特性。而关联容器的查找效率是 `O(log n)`，无序关联容器是平均 `O(1)`，最差 `O(n)`，与 `span` 的访问模式不匹配。

`span/mdspan`**为什么不适配容器适配器？**

- 容器适配器（如 `std::stack`, `std::queue`, `std::priority_queue`）是对底层序列容器（默认是 `std::deque`）的接口封装。
- 它们**没有提供直接访问底层数据的接口**（如 `data()`, `size()`， 或者直接暴露迭代器的方式也受限制）。你无法从 `std::stack` 直接获取一个指向其所有元素连续内存的指针。



#### 总结与对比

| 视图类型               | 引入标准 | 维度 | 主要适配的容器/数据类型                                      | 核心要求                                       |
| ---------------------- | -------- | ---- | ------------------------------------------------------------ | ---------------------------------------------- |
| **`std::string_view`** | C++17    | 一维 | `std::string`, C风格字符串                                   | 连续字符序列，通常以`\0`结尾                   |
| **`std::span`**        | C++20    | 一维 | **序列容器**（`vector`, `array`, `string`）、C风格数组、自定义连续容器 | **连续内存存储**，可提供 `data()`/`size()`     |
| **`std::mdspan`**      | C++23    | 多维 | **“平坦”的序列容器**（如`vector`）、多维C风格数组、自定义连续容器 | **连续内存存储**，并通过布局映射来解释多维结构 |

**结论：**

`span` 和 `mdspan` 并不严格限定于某一种**命名上**的容器类别（如序列容器）。它们适配的是一种**概念（Concept）**：即“**一段连续的内存序列**”。

因此，它们能完美地适配标准库中的**序列容器**（如 `vector`, `array`, `string`），因为它们都满足连续存储的要求。而**关联容器**、**无序关联容器**和**容器适配器**由于其内在的内存布局或接口设计，无法与 `span`/`mdspan` 配合使用。

------



### (2) 使用示例

#### Ⅰ. string_view 示例

`std::string_view` 是 C++17 引入的轻量级非拥有字符串视图，提供对字符串数据的只读访问。

```cpp
#include <iostream>
#include <string>
#include <string_view>
#include <vector>
#include <algorithm>

using namespace std;

// 使用 string_view 作为函数参数，避免不必要的字符串拷贝
void process_text(string_view text) {
    cout << "处理文本: " << text << endl;
    cout << "长度: " << text.length() << endl;
    cout << "是否为空: " << text.empty() << endl;
    
    // 查找操作
    size_t pos = text.find("world");
    if (pos != string_view::npos) {
        cout << "找到 'world' 在位置: " << pos << endl;
    }
    
    // 获取子视图
    string_view sub = text.substr(0, 5);
    cout << "前5个字符: " << sub << endl;
    
    // 比较操作
    if (text.starts_with("Hello")) {
        cout << "以 'Hello' 开头" << endl;
    }
    
    if (text.ends_with("!")) {
        cout << "以 '!' 结尾" << endl;
    }
    
    // 遍历字符
    cout << "字符: ";
    for (char c : text) {
        cout << c << " ";
    }
    cout << endl;
}

int main() {
    cout << "=== string_view 示例 ===" << endl;
    
    // 从各种字符串类型创建 string_view
    string str = "Hello, world!";
    const char* cstr = "Hello, C-style string!";
    char arr[] = "Hello, array!";
    
    string_view sv1(str);              // 从 std::string
    string_view sv2(cstr);             // 从 C 风格字符串
    string_view sv3(arr);              // 从字符数组
    string_view sv4("Hello, literal!"); // 从字符串字面量
    
    process_text(sv1);
    process_text(sv2);
    process_text(sv3);
    process_text(sv4);
    
    // string_view 可以用于算法
    vector<string_view> views = {sv1, sv2, sv3, sv4};
    cout << "\n所有视图:" << endl;
    for (const auto& view : views) {
        cout << "- " << view << endl;
    }
    
    // 注意：string_view 不拥有数据，需要确保原字符串的生命周期
    string_view dangerous_view;
    {
        string temp = "临时字符串";
        dangerous_view = temp; // 危险！temp 将被销毁
        cout << "\n危险视图（在作用域内）: " << dangerous_view << endl;
    }
    // 这里访问 dangerous_view 是未定义行为！
    // cout << "危险视图（在作用域外）: " << dangerous_view << endl; // 不要这样做！
    
    return 0;
}
```

#### Ⅱ. span 示例

`std::span` 是 C++20 引入的轻量级非拥有序列视图，提供对连续内存序列的安全访问。

```cpp
#include <iostream>
#include <span>
#include <vector>
#include <array>
#include <algorithm>

using namespace std;

// 使用 span 作为函数参数，避免不必要的容器拷贝
void process_data(span<const int> data) {
    cout << "处理数据: ";
    for (int value : data) {
        cout << value << " ";
    }
    cout << endl;
    
    cout << "大小: " << data.size() << endl;
    cout << "是否为空: " << data.empty() << endl;
    cout << "第一个元素: " << data.front() << endl;
    cout << "最后一个元素: " << data.back() << endl;
    
    // 使用下标访问
    if (data.size() > 2) {
        cout << "第三个元素: " << data[2] << endl;
    }
    
    // 获取子视图
    if (data.size() >= 3) {
        span<const int> sub = data.subspan(1, 3);
        cout << "子序列: ";
        for (int value : sub) {
            cout << value << " ";
        }
        cout << endl;
    }
}

// 可变的 span
void modify_data(span<int> data) {
    for (int& value : data) {
        value *= 2; // 修改数据
    }
}

int main() {
    cout << "\n=== span 示例 ===" << endl;
    
    // 从各种容器创建 span
    vector<int> vec = {1, 2, 3, 4, 5};
    array<int, 6> arr = {10, 20, 30, 40, 50, 60};
    int c_array[] = {100, 200, 300, 400, 500};
    
    span<int> sp1(vec);              // 从 vector
    span<int> sp2(arr);              // 从 array
    span<int> sp3(c_array);          // 从 C 风格数组
    
    process_data(sp1);
    process_data(sp2);
    process_data(sp3);
    
    // 修改数据
    cout << "\n修改前的向量: ";
    for (int value : vec) {
        cout << value << " ";
    }
    cout << endl;
    
    modify_data(span<int>(vec));
    
    cout << "修改后的向量: ";
    for (int value : vec) {
        cout << value << " ";
    }
    cout << endl;
    
    // 固定大小的 span
    span<int, 5> fixed_span(c_array); // 编译时已知大小
    cout << "\n固定大小 span: ";
    for (int value : fixed_span) {
        cout << value << " ";
    }
    cout << endl;
    
    // span 可以用于算法
    vector<span<int>> spans = {sp1, sp2, sp3};
    cout << "\n所有 span 的第一个元素:" << endl;
    for (const auto& sp : spans) {
        if (!sp.empty()) {
            cout << "- " << sp.front() << endl;
        }
    }
    
    // 示例：静态大小的 std::span 如果容器不匹配 std::span 的范围，则无法编译。
    auto print_three_ints = [](std::span<const int, 3> ints) {
        for (const auto n : ints) {
            std::cout << n << std::endl;
        }
    };

    print_three_ints(std::vector{ 1, 2, 3 }); // 错误
    print_three_ints(std::array<int, 5>{ 1, 2, 3, 4, 5 }); // 错误
    int a[10] = { 0 };
    print_three_ints(a); // 错误

    std::array<int, 3> b = { 1, 2, 3 };
    print_three_ints(b); // OK

    // 如果需要，可以手动构造一个 span：
    std::vector c{ 1, 2, 3 };
    print_three_ints(std::span<const int, 3>{ c.data(), 3 }); // OK：设置指针和长度字段。
    print_three_ints(std::span<const int, 3>{ c.cbegin(), c.cend() }); // OK：使用迭代器对。
    return 0;
}
```

#### Ⅲ. mdspan 示例

`std::mdspan` 是 C++23 引入的多维非拥有序列视图，提供对多维数据的安全访问。

```cpp
#include <iostream>
#include <vector>
#include <array>
#include <mdspan> // C++23 特性，可能需要最新编译器

using namespace std;

// 注意：mdspan 是 C++23 特性，可能需要使用实验性实现
// 这里使用标准名称，但实际编译可能需要特定编译器支持

#ifdef __cpp_lib_mdspan
// 使用 mdspan 作为函数参数
void process_matrix(mdspan<const int, extents<size_t, dynamic_extent, dynamic_extent>> matrix) {
    cout << "处理矩阵 (" << matrix.extent(0) << "x" << matrix.extent(1) << "):" << endl;
    
    for (size_t i = 0; i < matrix.extent(0); ++i) {
        for (size_t j = 0; j < matrix.extent(1); ++j) {
            cout << matrix[i, j] << "\t";
        }
        cout << endl;
    }
    
    cout << "元素总数: " << matrix.size() << endl;
}

// 可变的 mdspan
void modify_matrix(mdspan<int, extents<size_t, dynamic_extent, dynamic_extent>> matrix) {
    for (size_t i = 0; i < matrix.extent(0); ++i) {
        for (size_t j = 0; j < matrix.extent(1); ++j) {
            matrix[i, j] += i * 10 + j; // 修改数据
        }
    }
}

int main() {
    cout << "\n=== mdspan 示例 ===" << endl;
    
    // 创建二维数据
    vector<int> data = {
        1, 2, 3,
        4, 5, 6,
        7, 8, 9
    };
    
    // 创建 3x3 的 mdspan
    mdspan<int, extents<size_t, 3, 3>> matrix3x3(data.data());
    
    cout << "3x3 矩阵:" << endl;
    process_matrix(matrix3x3);
    
    // 创建动态大小的 mdspan
    vector<int> larger_data(20);
    for (int i = 0; i < 20; ++i) {
        larger_data[i] = i + 1;
    }
    
    // 4x5 矩阵
    mdspan<int, extents<size_t, dynamic_extent, dynamic_extent>> matrix4x5(
        larger_data.data(), 4, 5
    );
    
    cout << "\n4x5 矩阵:" << endl;
    process_matrix(matrix4x5);
    
    // 修改数据
    cout << "\n修改前的 4x5 矩阵:" << endl;
    process_matrix(matrix4x5);
    
    modify_matrix(matrix4x5);
    
    cout << "修改后的 4x5 矩阵:" << endl;
    process_matrix(matrix4x5);
    
    // 使用不同的布局策略
    cout << "\n使用不同布局的 mdspan:" << endl;
    
    // 行优先布局（默认）
    mdspan<int, extents<size_t, 2, 3>, layout_right> row_major(data.data());
    
    // 列优先布局
    mdspan<int, extents<size_t, 2, 3>, layout_left> col_major(data.data());
    
    cout << "行优先访问:" << endl;
    for (size_t i = 0; i < row_major.extent(0); ++i) {
        for (size_t j = 0; j < row_major.extent(1); ++j) {
            cout << row_major[i, j] << " ";
        }
        cout << endl;
    }
    
    cout << "列优先访问:" << endl;
    for (size_t i = 0; i < col_major.extent(0); ++i) {
        for (size_t j = 0; j < col_major.extent(1); ++j) {
            cout << col_major[i, j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
#else
int main() {
    cout << "当前编译器不支持 mdspan (C++23 特性)" << endl;
    return 0;
}
#endif
```

------



### (3) 综合示例：结合使用视图类型

```cpp
#include <iostream>
#include <string>
#include <string_view>
#include <span>
#include <vector>
#include <algorithm>

using namespace std;

// 处理文本数据的函数，使用视图类型避免拷贝
void process_text_data(span<const string_view> texts) {
    cout << "处理文本数据:" << endl;
    
    for (size_t i = 0; i < texts.size(); ++i) {
        const auto& text = texts[i];
        cout << "文本 " << i << ": " << text << " (长度: " << text.length() << ")" << endl;
        
        // 查找特定内容
        if (text.find("C++") != string_view::npos) {
            cout << "  - 包含 'C++'" << endl;
        }
    }
}

// 处理数值数据的函数
void process_numeric_data(span<const int> numbers, string_view description) {
    cout << description << ":" << endl;
    cout << "数据: ";
    
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl;
    
    // 计算统计信息
    if (!numbers.empty()) {
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        double average = static_cast<double>(sum) / numbers.size();
        
        cout << "总和: " << sum << endl;
        cout << "平均值: " << average << endl;
        
        auto min_max = minmax_element(numbers.begin(), numbers.end());
        cout << "最小值: " << *min_max.first << endl;
        cout << "最大值: " << *min_max.second << endl;
    }
}

int main() {
    cout << "=== 综合示例 ===" << endl;
    
    // 文本数据处理
    vector<string> strings = {
        "C++ is a powerful language",
        "String views are useful",
        "C++17 introduced string_view",
        "Spans provide safe array access"
    };
    
    // 创建 string_view 的向量
    vector<string_view> string_views;
    for (const auto& str : strings) {
        string_views.push_back(str);
    }
    
    process_text_data(span<const string_view>(string_views));
    
    // 数值数据处理
    vector<int> numbers = {42, 17, 89, 34, 56, 23, 71, 95, 12, 68};
    
    process_numeric_data(span<const int>(numbers), "所有数字");
    
    // 处理子集
    if (numbers.size() >= 5) {
        process_numeric_data(
            span<const int>(numbers.data() + 2, 5),
            "第3到第7个数字"
        );
    }
    
    // 使用算法与视图
    cout << "\n使用算法与视图:" << endl;
    
    // 查找包含 "C++" 的字符串
    auto it = find_if(string_views.begin(), string_views.end(), 
                     [](string_view sv) { return sv.find("C++") != string_view::npos; });
    
    if (it != string_views.end()) {
        cout << "找到包含 'C++' 的字符串: " << *it << endl;
    }
    
    // 对数值数据进行排序（使用可变 span）
    span<int> numbers_span(numbers);
    sort(numbers_span.begin(), numbers_span.end());
    
    process_numeric_data(numbers_span, "排序后的数字");
    
    return 0;
}
```

------



### (4) 使用建议

1. **优先使用视图类型**：作为函数参数时，优先使用视图类型而非容器本身，避免不必要的拷贝
2. **注意生命周期**：视图类型不拥有数据，需要确保原数据的生命周期长于视图
3. **选择合适的视图**：
   - 处理字符串时使用 `string_view`
   - 处理一维数据时使用 `span`
   - 处理多维数据时使用 `mdspan`
4. **利用视图的便利性**：视图类型提供丰富的成员函数，如 `subspan`、`substr` 等

这些视图类型是现代 C++ 编程中的重要工具，它们提供了高效、安全的数据访问方式，同时避免了不必要的内存拷贝。
