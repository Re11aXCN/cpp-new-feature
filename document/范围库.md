# 范围库 (自 C++20 起)

范围库是对算法和迭代器库的扩展和泛化，通过使其可组合且不易出错，从而使其更加强大。

该库创建和操作范围*视图*，这是一种轻量级对象，间接表示可迭代序列（*范围*）。范围是对以下内容的抽象：

-  `[`begin`, `end`)` – 迭代器对，例如通过从容器隐式转换创建的范围。所有接受迭代器对的算法现在都有接受范围的重载（例如 [`ranges::sort`](https://cppreference.cn/w/cpp/algorithm/ranges/sort)）
- begin` + ``[`0`, `size`)` – 计数序列，例如 [`views::counted`](https://cppreference.cn/w/cpp/ranges/view_counted) 返回的范围
-  `[`begin`, `*predicate*`)` – 条件终止序列，例如 [`views::take_while`](https://cppreference.cn/w/cpp/ranges/take_while_view) 返回的范围
-  `[`begin`, `..`)` – 无界序列，例如 [`views::iota`](https://cppreference.cn/w/cpp/ranges/iota_view) 返回的范围

范围库包括 [范围算法](https://cppreference.cn/w/cpp/algorithm/ranges)（急切地应用于范围）和 [范围适配器](https://cppreference.cn/w/cpp/ranges#Range_adaptors)（惰性地应用于视图）。适配器可以组合成管道，以便在迭代视图时执行其操作。

| 定义于头文件 `<ranges>`                                |      |               |
| ------------------------------------------------------ | ---- | ------------- |
| namespace std {    namespace views = ranges::views;  } |      | (自 C++20 起) |
|                                                        |      |               |

命名空间别名 `std::views` 作为 `std::ranges::views` 的简写形式提供。

| 定义于命名空间 `std::ranges`                                 |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 范围访问                                                     |                                                              |
| 定义于头文件 `<ranges>`                                      |                                                              |
| 定义于头文件 `<iterator>`                                    |                                                              |
| [ ranges::begin](https://cppreference.cn/w/cpp/ranges/begin)(C++20) | 返回指向范围开头的迭代器 (自定义点对象)                      |
| [ ranges::end](https://cppreference.cn/w/cpp/ranges/end)(C++20) | 返回指示范围结尾的哨兵 (自定义点对象)                        |
| [ ranges::cbegin](https://cppreference.cn/w/cpp/ranges/cbegin)(C++20) | 返回指向只读范围开头的迭代器 (自定义点对象)                  |
| [ ranges::cend](https://cppreference.cn/w/cpp/ranges/cend)(C++20) | 返回指示只读范围结尾的哨兵 (自定义点对象)                    |
| [ ranges::rbegin](https://cppreference.cn/w/cpp/ranges/rbegin)(C++20) | 返回范围的反向迭代器 (自定义点对象)                          |
| [ ranges::rend](https://cppreference.cn/w/cpp/ranges/rend)(C++20) | 返回范围的反向结尾迭代器 (自定义点对象)                      |
| [ ranges::crbegin](https://cppreference.cn/w/cpp/ranges/crbegin)(C++20) | 返回指向只读范围的反向迭代器 (自定义点对象)                  |
| [ ranges::crend](https://cppreference.cn/w/cpp/ranges/crend)(C++20) | 返回指向只读范围的反向结尾迭代器 (自定义点对象)              |
| ranges::reserve_hint(C++26)                                  | 返回一个等于范围给出的保留提示的整数 (自定义点对象)          |
| [ ranges::size](https://cppreference.cn/w/cpp/ranges/size)(C++20) | 返回一个等于范围大小的整数 (自定义点对象)                    |
| [ ranges::ssize](https://cppreference.cn/w/cpp/ranges/ssize)(C++20) | 返回一个等于范围大小的有符号整数 (自定义点对象)              |
| [ ranges::empty](https://cppreference.cn/w/cpp/ranges/empty)(C++20) | 检查范围是否为空 (自定义点对象)                              |
| [ ranges::data](https://cppreference.cn/w/cpp/ranges/data)(C++20) | 获取指向连续范围开头的指针 (自定义点对象)                    |
| [ ranges::cdata](https://cppreference.cn/w/cpp/ranges/cdata)(C++20) | 获取指向只读连续范围开头的指针 (自定义点对象)                |
| 范围原语                                                     |                                                              |
| 定义于头文件 `<ranges>`                                      |                                                              |
| [ ranges::iterator_tranges::const_iterator_tranges::sentinel_tranges::const_sentinel_t](https://cppreference.cn/w/cpp/ranges/iterator_t)(C++20)(C++23)(C++20)(C++23) | 获取范围的迭代器和哨兵类型 (别名模板)                        |
| [ ranges::range_difference_tranges::range_size_tranges::range_value_t](https://cppreference.cn/w/cpp/ranges/range_size_t)(C++20)(C++20)(C++20) | 获取范围的大小、差值和值类型 (别名模板)                      |
| [ ranges::range_reference_tranges::range_const_reference_tranges::range_rvalue_reference_tranges::range_common_reference_t](https://cppreference.cn/w/cpp/ranges/range_reference_t)(C++20)(C++23)(C++20)(C++20) | 获取范围的引用类型 (别名模板)                                |
| 悬垂迭代器处理                                               |                                                              |
| 定义于头文件 `<ranges>`                                      |                                                              |
| [ ranges::dangling](https://cppreference.cn/w/cpp/ranges/dangling)(C++20) | 指示不应返回迭代器或 `subrange` 的占位符类型，因为它将是悬垂的  (类) |
| [ ranges::borrowed_iterator_tranges::borrowed_subrange_t](https://cppreference.cn/w/cpp/ranges/borrowed_iterator_t)(C++20) | 获取 [`borrowed_range`](https://cppreference.cn/w/cpp/ranges/borrowed_range) 的迭代器类型或 `subrange` 类型 (别名模板) |
| 其他工具                                                     |                                                              |
| 定义于头文件 `<ranges>`                                      |                                                              |
| [ ranges::elements_of](https://cppreference.cn/w/cpp/ranges/elements_of)(C++23) | 标记一个范围，使其被视为序列而不是单个值  (类模板)           |
| 范围概念                                                     |                                                              |
| 定义于头文件 `<ranges>`                                      |                                                              |
| [ ranges::range](https://cppreference.cn/w/cpp/ranges/range)(C++20) | 指定类型为范围，即它提供 `begin` 迭代器和 `end` 哨兵  (概念) |
| [ ranges::borrowed_range](https://cppreference.cn/w/cpp/ranges/borrowed_range)(C++20) | 指定类型为 [`range`](https://cppreference.cn/w/cpp/ranges/range)，并且从它的表达式中获取的迭代器可以安全地返回，而没有悬垂的危险  (概念) |
| ranges::approximately_sized_range(C++26)                     | 指定范围可以在常数时间内估计其大小  (概念)                   |
| [ ranges::sized_range](https://cppreference.cn/w/cpp/ranges/sized_range)(C++20) | 指定范围在常数时间内知道其大小  (概念)                       |
| [ ranges::view](https://cppreference.cn/w/cpp/ranges/view)(C++20) | 指定范围是视图，即它具有常数时间的复制/移动/赋值  (概念)     |
| [ ranges::input_range](https://cppreference.cn/w/cpp/ranges/input_range)(C++20) | 指定迭代器类型满足 [`input_iterator`](https://cppreference.cn/w/cpp/iterator/input_iterator) 的范围  (概念) |
| [ ranges::output_range](https://cppreference.cn/w/cpp/ranges/output_range)(C++20) | 指定迭代器类型满足 [`output_iterator`](https://cppreference.cn/w/cpp/iterator/output_iterator) 的范围  (概念) |
| [ ranges::forward_range](https://cppreference.cn/w/cpp/ranges/forward_range)(C++20) | 指定迭代器类型满足 [`forward_iterator`](https://cppreference.cn/w/cpp/iterator/forward_iterator) 的范围  (概念) |
| [ ranges::bidirectional_range](https://cppreference.cn/w/cpp/ranges/bidirectional_range)(C++20) | 指定迭代器类型满足 [`bidirectional_iterator`](https://cppreference.cn/w/cpp/iterator/bidirectional_iterator) 的范围  (概念) |
| [ ranges::random_access_range](https://cppreference.cn/w/cpp/ranges/random_access_range)(C++20) | 指定迭代器类型满足 [`random_access_iterator`](https://cppreference.cn/w/cpp/iterator/random_access_iterator) 的范围  (概念) |
| [ ranges::contiguous_range](https://cppreference.cn/w/cpp/ranges/contiguous_range)(C++20) | 指定迭代器类型满足 [`contiguous_iterator`](https://cppreference.cn/w/cpp/iterator/contiguous_iterator) 的范围  (概念) |
| [ ranges::common_range](https://cppreference.cn/w/cpp/ranges/common_range)(C++20) | 指定范围具有相同的迭代器和哨兵类型  (概念)                   |
| [ ranges::viewable_range](https://cppreference.cn/w/cpp/ranges/viewable_range)(C++20) | 指定 [`range`](https://cppreference.cn/w/cpp/ranges/range) 安全转换为 [`view`](https://cppreference.cn/w/cpp/ranges/view) 的要求  (概念) |
| [ ranges::constant_range](https://cppreference.cn/w/cpp/ranges/constant_range)(C++23) | 指定范围具有只读元素  (概念)                                 |
| 范围转换                                                     |                                                              |
| 定义于头文件 `<ranges>`                                      |                                                              |
| [ ranges::to](https://cppreference.cn/w/cpp/ranges/to)(C++23) | 从输入范围构造一个新的非视图对象  (函数模板)                 |
| 视图                                                         |                                                              |
| 定义于头文件 `<ranges>`                                      |                                                              |
| [ ranges::view_interface](https://cppreference.cn/w/cpp/ranges/view_interface)(C++20) | 用于定义 [`view`](https://cppreference.cn/w/cpp/ranges/view) 的辅助类模板，使用 [奇特的递归模板模式](https://cppreference.cn/w/cpp/language/crtp)  (类模板) |
| [ ranges::subrange](https://cppreference.cn/w/cpp/ranges/subrange)(C++20) | 将迭代器-哨兵对组合成 [`view`](https://cppreference.cn/w/cpp/ranges/view)  (类模板) |



###  范围工厂

| 定义于头文件 `<ranges>`                                      |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std::ranges`                                 |                                                              |
| [ ranges::empty_viewviews::empty](https://cppreference.cn/w/cpp/ranges/empty_view)(C++20) | 一个没有元素的空 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (变量模板) |
| [ ranges::single_viewviews::single](https://cppreference.cn/w/cpp/ranges/single_view)(C++20) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，包含指定值的单个元素 (类模板) (自定义点对象) |
| [ ranges::iota_viewviews::iota](https://cppreference.cn/w/cpp/ranges/iota_view)(C++20) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，由通过重复递增初始值生成的序列组成 (类模板) (自定义点对象) |
| [ ranges::repeat_viewviews::repeat](https://cppreference.cn/w/cpp/ranges/repeat_view)(C++23) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，由通过重复产生相同值而生成的序列组成 (类模板) (自定义点对象) |
| [ ranges::basic_istream_viewviews::istream](https://cppreference.cn/w/cpp/ranges/basic_istream_view)(C++20) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，由通过连续应用关联输入流上的 `operator>>` 获取的元素组成 (类模板) (自定义点对象) |



###  范围适配器

| 定义于头文件 `<ranges>`                                      |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std::ranges`                                 |                                                              |
| [ ranges::range_adaptor_closure](https://cppreference.cn/w/cpp/ranges/range_adaptor_closure)(C++23) | 用于定义范围适配器闭包对象的辅助基类模板  (类模板)           |
| [ views::all_tviews::all](https://cppreference.cn/w/cpp/ranges/all_view)(C++20) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，包含 [`range`](https://cppreference.cn/w/cpp/ranges/range) 的所有元素 (别名模板) (范围适配器对象) |
| [ ranges::ref_view](https://cppreference.cn/w/cpp/ranges/ref_view)(C++20) | 某个其他 [`range`](https://cppreference.cn/w/cpp/ranges/range) 的元素的 [`view`](https://cppreference.cn/w/cpp/ranges/view)  (类模板) |
| [ ranges::owning_view](https://cppreference.cn/w/cpp/ranges/owning_view)(C++20) | 具有某些 [`range`](https://cppreference.cn/w/cpp/ranges/range) 的唯一所有权的 [`view`](https://cppreference.cn/w/cpp/ranges/view)  (类模板) |
| [ ranges::as_rvalue_viewviews::as_rvalue](https://cppreference.cn/w/cpp/ranges/as_rvalue_view)(C++23) | 将每个元素强制转换为右值的序列的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::filter_viewviews::filter](https://cppreference.cn/w/cpp/ranges/filter_view)(C++20) | 由满足谓词的 [`range`](https://cppreference.cn/w/cpp/ranges/range) 的元素组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::transform_viewviews::transform](https://cppreference.cn/w/cpp/ranges/transform_view)(C++20) | 将转换函数应用于每个元素的序列的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::take_viewviews::take](https://cppreference.cn/w/cpp/ranges/take_view)(C++20) | 由另一个 [`view`](https://cppreference.cn/w/cpp/ranges/view) 的前 N 个元素组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::take_while_viewviews::take_while](https://cppreference.cn/w/cpp/ranges/take_while_view)(C++20) | 由另一个 [`view`](https://cppreference.cn/w/cpp/ranges/view) 的初始元素组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view)，直到谓词返回 false 的第一个元素 (类模板) (范围适配器对象) |
| [ ranges::drop_viewviews::drop](https://cppreference.cn/w/cpp/ranges/drop_view)(C++20) | 由另一个 [`view`](https://cppreference.cn/w/cpp/ranges/view) 的元素组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view)，跳过前 N 个元素 (类模板) (范围适配器对象) |
| [ ranges::drop_while_viewviews::drop_while](https://cppreference.cn/w/cpp/ranges/drop_while_view)(C++20) | 由另一个 [`view`](https://cppreference.cn/w/cpp/ranges/view) 的元素组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view)，跳过初始元素子序列，直到谓词返回 false 的第一个元素 (类模板) (范围适配器对象) |
| [ ranges::join_viewviews::join](https://cppreference.cn/w/cpp/ranges/join_view)(C++20) | 由从扁平化 [`range`](https://cppreference.cn/w/cpp/ranges/range) 的 [`view`](https://cppreference.cn/w/cpp/ranges/view) 获得的序列组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::join_with_viewviews::join_with](https://cppreference.cn/w/cpp/ranges/join_with_view)(C++23) | 由从扁平化范围视图获得的序列组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view)，元素之间带有分隔符 (类模板) (范围适配器对象) |
| [ ranges::lazy_split_viewviews::lazy_split](https://cppreference.cn/w/cpp/ranges/lazy_split_view)(C++20) | 在通过使用分隔符拆分另一个 [`view`](https://cppreference.cn/w/cpp/ranges/view) 获得的子范围上的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::split_viewviews::split](https://cppreference.cn/w/cpp/ranges/split_view)(C++20) | 在通过使用分隔符拆分另一个 [`view`](https://cppreference.cn/w/cpp/ranges/view) 获得的子范围上的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::concat_viewviews::concat](https://cppreference.cn/w/cpp/ranges/concat_view)(C++26) | 由适配视图的连接组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (自定义点对象) |
| [ views::counted](https://cppreference.cn/w/cpp/ranges/view_counted)(C++20) | 从迭代器和计数创建子范围 (自定义点对象)                      |
| [ ranges::common_viewviews::common](https://cppreference.cn/w/cpp/ranges/common_view)(C++20) | 将 [`view`](https://cppreference.cn/w/cpp/ranges/view) 转换为 [`common_range`](https://cppreference.cn/w/cpp/ranges/common_range) (类模板) (范围适配器对象) |
| [ ranges::reverse_viewviews::reverse](https://cppreference.cn/w/cpp/ranges/reverse_view)(C++20) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它以相反的顺序迭代另一个双向 view 的元素 (类模板) (范围适配器对象) |
| [ ranges::as_const_viewviews::as_const](https://cppreference.cn/w/cpp/ranges/as_const_view)(C++23) | 将 [`view`](https://cppreference.cn/w/cpp/ranges/view) 转换为 [`constant_range`](https://cppreference.cn/w/cpp/ranges/constant_range) (类模板) (范围适配器对象) |
| [ ranges::elements_viewviews::elements](https://cppreference.cn/w/cpp/ranges/elements_view)(C++20) | 接受一个由 [`*tuple-like*`](https://cppreference.cn/w/cpp/utility/tuple/tuple-like) 值和数字 N 组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view)，并生成一个由每个元组的第 N 个元素组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::keys_viewviews::keys](https://cppreference.cn/w/cpp/ranges/keys_view)(C++20) | 接受一个由类对值组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view)，并生成一个由每对的第一个元素组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::values_viewviews::values](https://cppreference.cn/w/cpp/ranges/values_view)(C++20) | 接受一个由类对值组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view)，并生成一个由每对的第二个元素组成的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::enumerate_viewviews::enumerate](https://cppreference.cn/w/cpp/ranges/enumerate_view)(C++23) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它将适配序列的每个元素映射到一个由元素的位置及其值组成的元组 (类模板) (范围适配器对象) |
| [ ranges::zip_viewviews::zip](https://cppreference.cn/w/cpp/ranges/zip_view)(C++23) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它由对适配的 view 的相应元素的引用的元组组成 (类模板) (定制点对象) |
| [ ranges::zip_transform_viewviews::zip_transform](https://cppreference.cn/w/cpp/ranges/zip_transform_view)(C++23) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它由将变换函数应用于适配的 view 的相应元素的结果组成 (类模板) (定制点对象) |
| [ ranges::adjacent_viewviews::adjacent](https://cppreference.cn/w/cpp/ranges/adjacent_view)(C++23) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它由对适配的 view 的相邻元素的引用的元组组成 (类模板) (范围适配器对象) |
| [ ranges::adjacent_transform_viewviews::adjacent_transform](https://cppreference.cn/w/cpp/ranges/adjacent_transform_view)(C++23) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它由将变换函数应用于适配的 view 的相邻元素的结果组成 (类模板) (范围适配器对象) |
| [ ranges::chunk_viewviews::chunk](https://cppreference.cn/w/cpp/ranges/chunk_view)(C++23) | 一系列 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它们是另一个 [`view`](https://cppreference.cn/w/cpp/ranges/view) 的元素的 `N` 大小的非重叠连续块 (类模板) (范围适配器对象) |
| [ ranges::slide_viewviews::slide](https://cppreference.cn/w/cpp/ranges/slide_view)(C++23) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，其第 M 个元素是另一个 [`view`](https://cppreference.cn/w/cpp/ranges/view) 的第 M 个到第 (M + N - 1) 个元素的 [`view`](https://cppreference.cn/w/cpp/ranges/view) (类模板) (范围适配器对象) |
| [ ranges::chunk_by_viewviews::chunk_by](https://cppreference.cn/w/cpp/ranges/chunk_by_view)(C++23) | 将 [`view`](https://cppreference.cn/w/cpp/ranges/view) 拆分为子范围，子范围位于给定谓词返回 false 的每对相邻元素之间 (类模板) (范围适配器对象) |
| [ ranges::stride_viewviews::stride](https://cppreference.cn/w/cpp/ranges/stride_view)(C++23) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它由另一个 [`view`](https://cppreference.cn/w/cpp/ranges/view) 的元素组成，每次前进 N 个元素 (类模板) (范围适配器对象) |
| [ ranges::cartesian_product_viewviews::cartesian_product](https://cppreference.cn/w/cpp/ranges/cartesian_product_view)(C++23) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它由适配的 view 的 n 元笛卡尔积计算的结果元组组成 (类模板) (定制点对象) |
| [ ranges::cache_latest_viewviews::cache_latest](https://cppreference.cn/w/cpp/ranges/cache_latest_view)(C++26) | 一个 [`view`](https://cppreference.cn/w/cpp/ranges/view)，它缓存其底层序列的最后访问元素 (类模板) (范围适配器对象) |
| [ ranges::to_input_viewviews::to_input](https://cppreference.cn/w/cpp/ranges/to_input_view)(C++26) | 将 [`view`](https://cppreference.cn/w/cpp/ranges/view) 转换为仅为 [`input_range`](https://cppreference.cn/w/cpp/ranges/input_range) 且非 [`common_range`](https://cppreference.cn/w/cpp/ranges/common_range) 的范围 (类模板) (范围适配器对象) |



###  范围生成器 (自 C++23 起)

| 定义于头文件 `<generator>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std`                                         |                                                              |
| [ generator](https://cppreference.cn/w/cpp/coroutine/generator)(C++23) | 一个表示同步 [协程](https://cppreference.cn/w/cpp/language/coroutines) 生成器的 [`view`](https://cppreference.cn/w/cpp/ranges/view)  (类模板) |

# 使用示例

```cpp
#ifdef _WIN32
#include <windows.h>
#endif // _WIN32
#include <iostream>
#include <string>
#include <vector>
#include <list>
#include <array>
#include <tuple>
#include <algorithm>
#include <iomanip>
#include <numeric>
#include <ranges>
#include <map>
int main() {
#ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
    //std::cout.imbue(std::locale("en_US.utf8"));
#endif // _WIN32
    // 笛卡尔积
    {
        auto print = [](std::tuple<char const&, int const&, std::string const&> t, int pos)
        {
            const auto& [a, b, c] = t;
            std::cout << '(' << a << ' ' << b << ' ' << c << ')' << (pos % 4 ? " " : "\n");
        };
        const auto x = std::array{ 'A', 'B' };
        const auto y = std::vector{ 1, 2, 3 };
        const auto z = std::list<std::string>{ "α", "β", "γ", "δ" };

        for (int i{ 1 }; auto const& tuple : std::views::cartesian_product(x, y, z))
            print(tuple, i++);
    }

    // std::views::adjacent  get adjacent elements in a range
    // std::views::chunk  split a range into chunks of a given size
    // chunk_by 接收一个二元谓词，并遍历输入范围中的相邻元素对。当谓词对两个相邻元素返回 false 时，它会在这些元素之间创建一个分割点，将范围分成不同的块。
    // std::views::slide
    // std::views::stride  步长为 n 的切片
    {
        /*
        v = [1 2 3 4 5 6]
        e = [1 2 3]
        e =   [2 3 4]
        e =     [3 4 5]
        e =       [4 5 6]

        chunk(1): [1] [2] [3] [4] [5] [6]
        chunk(2): [1 2] [3 4] [5 6]
        chunk(3): [1 2 3] [4 5 6]
        chunk(4): [1 2 3 4] [5 6]
        chunk(5): [1 2 3 4 5] [6]
        chunk(6): [1 2 3 4 5 6]
        chunk(7): [1 2 3 4 5 6]

        [1, 2, 3] [1, 2, 3] [3] [3] [1, 2, 3]
        [1, 2, 3, 4] [4, 0, 2, 3] [3] [3, 2, 1]
        [_] [_] [cpp] [_] [lib] [_] [ranges] [_] [chunk] [_] [by]
        [z] [ß] [水] [🍌]

        All sliding windows of width W:
        W = 1: [1] [2] [3] [4] [5] [6]
        W = 2: [1 2] [2 3] [3 4] [4 5] [5 6]
        W = 3: [1 2 3] [2 3 4] [3 4 5] [4 5 6]
        W = 4: [1 2 3 4] [2 3 4 5] [3 4 5 6]
        W = 5: [1 2 3 4 5] [2 3 4 5 6]
        W = 6: [1 2 3 4 5 6]

        1 4 7 10
        10 7 4 1
        12 9 6 3
        password
        */
        constexpr std::array v{ 1, 2, 3, 4, 5, 6 };
        std::cout << "v = [1 2 3 4 5 6]\n";

        for (int i{}; std::tuple t : v | std::views::adjacent<3>)
        {
            auto [t0, t1, t2] = t;
            std::cout << std::format("e = {:<{}}[{} {} {}]\n", "", 2 * i++, t0, t1, t2);
        }
        // ==
        auto print_subrange = [](std::ranges::viewable_range auto&& r)
            {
                std::cout << '[';
                for (int pos{}; auto elem : r)
                    std::cout << (pos++ ? " " : "") << elem;
                std::cout << "] ";
            };

        for (const unsigned width : std::views::iota(1U, 2U + v.size()))
        {
            auto const chunks = v | std::views::chunk(width);
            std::cout << "chunk(" << width << "): ";
            std::ranges::for_each(chunks, print_subrange);
            std::cout << '\n';
        }

        auto print_chunks = [](auto view, std::string_view separator = ", ")
        {
            for (auto const subrange : view)
            {
                std::cout << '[';
                for (std::string_view prefix; auto const& elem : subrange)
                    std::cout << prefix << elem, prefix = separator;
                std::cout << "] ";
            }
            std::cout << '\n';
        };

        std::initializer_list v1 = { 1, 2, 3, 1, 2, 3, 3, 3, 1, 2, 3 };
        auto fn1 = std::ranges::less{};
        auto view1 = v1 | std::views::chunk_by(fn1);
        print_chunks(view1);

        std::initializer_list v2 = { 1, 2, 3, 4, 4, 0, 2, 3, 3, 3, 2, 1 };
        auto fn2 = std::ranges::not_equal_to{};
        auto view2 = v2 | std::views::chunk_by(fn2);
        print_chunks(view2);

        std::string_view v3 = "__cpp_lib_ranges_chunk_by";
        auto fn3 = [](auto x, auto y) { return not(x == '_' or y == '_'); };
        auto view3 = v3 | std::views::chunk_by(fn3);
        print_chunks(view3, "");

        std::string_view v4 = "\u007a\u00df\u6c34\u{1f34c}"; // "zß水🍌"
        auto fn4 = [](auto, auto ß) { return 128 == ((128 + 64) & ß); };
        auto view4 = v4 | std::views::chunk_by(fn4);
        print_chunks(view4, "");

        // ==
        std::cout << "All sliding windows of width:\n";
        for (const unsigned width : std::views::iota(1U, 1U + v.size()))
        {
            auto const windows = v | std::views::slide(width);
            std::cout << "W = " << width << ": ";
            std::ranges::for_each(windows, print_subrange);
            std::cout << '\n';
        }

        // ==
        auto print2 = [](std::ranges::viewable_range auto&& v, std::string_view separator = " ")
            {
                for (auto const& x : v)
                    std::cout << x << separator;
                std::cout << '\n';
            };

        print2(std::views::iota(1, 13) | std::views::stride(3));
        print2(std::views::iota(1, 13) | std::views::stride(3) | std::views::reverse);
        print2(std::views::iota(1, 13) | std::views::reverse | std::views::stride(3));
        using std::operator""sv;
        print2("0x0!133713337*x//42/A$@"sv | std::views::stride(0B11) |
            std::views::transform([](char O) -> char { return 0100 | O; }),
            "");
    }
    // std::views::zip  取决于最小的容器大小
    {
        auto print = [](auto const rem, auto const& range)
            {
                for (std::cout << rem; auto const& elem : range)
                    std::cout << elem << ' ';
                std::cout << '\n';
            };
        auto x = std::vector{ 1, 2, 3, 4 };
        auto y = std::list<std::string>{ "α", "β", "γ", "δ", "ε" };
        auto z = std::array{ 'A', 'B', 'C', 'D', 'E', 'F' };

        print("Source views:", "");
        print("x: ", x);
        print("y: ", y);
        print("z: ", z);

        print("\nzip(x,y,z):", "");

        for (std::tuple<int&, std::string&, char&> elem : std::views::zip(x, y, z))
        {
            std::cout << std::get<0>(elem) << ' '
                << std::get<1>(elem) << ' '
                << std::get<2>(elem) << '\n';

            std::get<char&>(elem) += ('a' - 'A'); // modifies the element of z
        }

        print("\nAfter modification, z: ", z);
    }
    // std::views::enumerate  get index and value of each element in a range
    {
        constexpr static auto v = { 'A', 'B', 'C', 'D' };

        for (auto const [index, letter] : std::views::enumerate(v))
            std::cout << '(' << index << ':' << letter << ") ";
        std::cout << '\n';

#if __cpp_lib_ranges_to_container
        // create a map using the position of each element as key
        auto m = v | std::views::enumerate | std::ranges::to<std::map>();

        for (auto const [key, value] : m)
            std::cout << '[' << key << "]:" << value << ' ';
        std::cout << '\n';
#endif

        std::vector<int> numbers{ 1, 3, 5, 7 };

        // num is mutable even with const, which does not propagate to reference to
        // make it const, use `std::views::enumerate(numbers) | std::views::as_const`
        // or `std::views::enumerate(std::as_const(numbers))`
        for (auto const [index, num] : std::views::enumerate(numbers))
        {
            ++num; // the type is int&
            std::cout << numbers[index] << ' ';
        }
        std::cout << '\n';
    }
    // std::views::keys、std::views::values、std::views::elements
    {
        const std::vector<std::tuple<std::string, double, bool>> quark_mass_charge
        {
            // name, MeV/c², has positive electric-charge:
            {"up", 2.3, true}, {"down", 4.8, false},
            {"charm", 1275, true}, {"strange", 95, false},
            {"top", 173'210, true}, {"bottom", 4'180, false},
        };

        std::cout << "Quark name:  │ ";
        // 0
        for (std::string const& name : std::views::keys(quark_mass_charge))
            std::cout << std::setw(9) << name << " │ ";

        // 1
        std::cout << "\n" "Mass MeV/c²: │ ";
        for (const double mass : std::views::values(quark_mass_charge))
            std::cout << std::setw(9) << mass << " │ ";

        std::cout << "\n" "E-charge:    │ ";
        for (const bool pos : std::views::elements<2>(quark_mass_charge))
            std::cout << std::setw(9) << (pos ? "+2/3" : "-1/3") << " │ ";
        std::cout << '\n';
    }
    // lazy_split / lazy_split_view / split / split_view
    {
        auto print = [](auto const& view)
            {
                // `view` is of std::views::lazy_split_view::__outer_iterator::value_type

                for (std::cout << "{ "; const auto element : view)
                    std::cout << element << ' ';
                std::cout << "} ";
            };
        constexpr static auto source = { 0, 1, 0, 2, 3, 0, 4, 5, 6, 0, 7, 8, 9 };
        constexpr int delimiter{ 0 };
        constexpr std::ranges::lazy_split_view outer_view{ source, delimiter };
        std::cout << "splits[" << std::ranges::distance(outer_view) << "]:  ";
        for (auto const& inner_view : outer_view)
            print(inner_view);

        constexpr std::string_view hello{ "Hello C++ 20 !" };
        std::cout << "\n" "substrings: ";
        std::ranges::for_each(hello | std::views::lazy_split(' '), print);

        constexpr std::string_view text{ "Hello-+-C++-+-20-+-!" };
        constexpr std::string_view delim{ "-+-" };
        std::cout << "\n" "substrings: ";
        std::ranges::for_each(text | std::views::lazy_split(delim), print);

        using std::operator""sv;
        constexpr auto words{ "Hello^_^C++^_^20^_^!"sv };
        constexpr auto delimx{ "^_^"sv };

        for (const auto word : std::views::split(words, delimx))
            // with string_view's C++23 range constructor:
            std::cout << std::quoted(std::string_view(word)) << ' ';
        std::cout << '\n';
    }
    // join / join_view
    {
        using namespace std::literals;

        const auto bits = { "https:"sv, "//"sv, "cppreference"sv, "."sv, "com"sv };
        for (char const c : bits | std::views::join)
            std::cout << c;
        std::cout << '\n';

        const std::vector<std::vector<int>> vints{ {1, 2}, {3, 4, 5}, {6}, {7, 8, 9} };
        auto jv = std::ranges::join_view(vints);
        for (int const e : jv)
            std::cout << e << ' ';
        std::cout << '\n';

        std::vector vstrs{ "This"sv, "is"sv, "a"sv, "test."sv };
        auto joined = vstrs | std::views::join_with(' ');

        for (auto c : joined)
            std::cout << c;
        std::cout << '\n';

        std::vector<int> v0{ 1, 2, 3 }, v1{ 4, 5 };
        int a[]{ 6, 7 };
        int i{ 8 };
        auto ie{ std::views::single(i) };


    }
    // drop / drop_view 丢弃前n个元素，大于原序列长度的drop将返回空视图
    {
        const auto nums = { 1, 2, 3, 4, 5, 8, 7 };

        std::cout << "drop " << 2 << ": ";
        for (int i : std::ranges::drop_view{ nums, 6 })
            std::cout << i << ' ';
        std::cout << '\n';

        std::cout << "drop " << 3 << ": ";
        for (int i : nums | std::views::drop(5))
            std::cout << i << ' ';
        std::cout << '\n';

        std::cout << "drop " << 4 << ": ";
        for (int i : std::views::iota(1, 8) | std::views::drop(4))
            std::cout << i << ' ';
        std::cout << '\n';

        // Note that dropping more than the number of elements is OK:
        for (int dp : {5, 6, 7, 890, 100500})
        {
            std::cout << "drop " << dp << ": ";
            for (int i : std::views::iota(1, 8) | std::views::drop(dp))
                std::cout << i << ' ';
            std::cout << '\n';
        }
    }
    // take / take_while / take_while_view
    {
        namespace views = std::views;
        auto print = [](char x) { std::cout << x; };
        
        // 视图不修改原序列，take个数大于原序列个数将仅得到原序列所有个数
        for (const char nums[]{ '1', '2', '3' };
            int n : views::iota(0, 5))
        {
            std::cout << "take(" << n << "): ";
            // safely takes only upto min(n, nums.size()) elements:
            std::ranges::for_each(nums | views::take(n), print);
            std::cout << '\n';
        }


        // 从2020开始生成满足条件，将序列take取出
        for (int year : std::views::iota(2020)
            | std::views::take_while([](int y) { return y < 2026; }))
            std::cout << year << ' ';
        std::cout << '\n';

        const char note[]{ "Today is yesterday's tomorrow!..." };
        auto not_dot = [](char c) { return c != '.'; };
        for (char x : std::ranges::take_while_view(note, not_dot))
            std::cout << x;
        std::cout << '\n';
    }
    {
        auto showAll = [](const unsigned char x) { std::putchar(x); };
        auto showChar = [](const unsigned char x) { std::cout << x << std::endl; };

        std::string in{ "cppreference.cn\n" };
        std::ranges::for_each(in.begin(), in.end(), showAll);
        std::ranges::for_each(in.begin(), in.end(), showChar);

        std::cout << '\n';
    }
    return 0;
}
```

