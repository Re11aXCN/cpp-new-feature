# 高效读取文件

```c
#include <iostream>
#include <print>
#include <fstream>
#include <vector>
#include <thread>
#include <future>
#include <chrono>
#include <cstring>
#include <string>
#ifdef _WIN32
#include <windows.h>
#else
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#endif
class MemoryMappedFile {
public:
    MemoryMappedFile(const std::string& filepath) {
#ifdef _WIN32
        hFile = CreateFileA(filepath.c_str(), GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hFile == INVALID_HANDLE_VALUE) return;

        LARGE_INTEGER size;
        GetFileSizeEx(hFile, &size);
        fileSize = static_cast<size_t>(size.QuadPart);

        hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (!hMapping) {
            CloseHandle(hFile);
            return;
        }

        _data = static_cast<const char*>(MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, fileSize));
        if (!_data) {
            CloseHandle(hMapping);
            CloseHandle(hFile);
        }
#else
        fd = open(filepath.c_str(), O_RDONLY);
        if (fd == -1) return;

        struct stat sb;
        if (fstat(fd, &sb) == -1) {
            close(fd);
            return;
        }
        fileSize = sb.st_size;

        _data = static_cast<const char*>(mmap(NULL, fileSize, PROT_READ, MAP_PRIVATE, fd, 0));
        if (_data == MAP_FAILED) {
            close(fd);
            _data = nullptr;
        }
#endif
        _isOpen = (_data != nullptr);
    }

    ~MemoryMappedFile() {
#ifdef _WIN32
        if (_data) UnmapViewOfFile(_data);
        if (hMapping) CloseHandle(hMapping);
        if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
#else
        if (_data) munmap(const_cast<char*>(_data), fileSize);
        if (fd != -1) close(fd);
#endif
    }

    bool isOpen() const { return _isOpen; }
    const char* data() const { return _data; }
    size_t size() const { return fileSize; }

private:
    const char* _data = nullptr;
    size_t fileSize = 0;
    bool _isOpen = false;
#ifdef _WIN32
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMapping = nullptr;
#else
    int fd = -1;
#endif
};
class HighPerformanceImageReader {
public:
    // 方法1: 使用内存映射文件读取
    static std::vector<char> readWithMemoryMapping(const std::string& filepath) {
#ifdef _WIN32
        // Windows实现
        HANDLE hFile = CreateFileA(filepath.c_str(), GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE) return {};

        HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (!hMapping) {
            CloseHandle(hFile);
            return {};
        }

        LARGE_INTEGER size;
        GetFileSizeEx(hFile, &size);

        char* mappedData = static_cast<char*>(MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, size.QuadPart));
        if (!mappedData) {
            CloseHandle(hMapping);
            CloseHandle(hFile);
            return {};
        }

        std::vector<char> result(mappedData, mappedData + size.QuadPart);

        UnmapViewOfFile(mappedData);
        CloseHandle(hMapping);
        CloseHandle(hFile);

        return result;
#else
        // Linux/Mac实现
        int fd = open(filepath.c_str(), O_RDONLY);
        if (fd == -1) return {};

        struct stat sb;
        if (fstat(fd, &sb) == -1) {
            close(fd);
            return {};
        }

        char* mappedData = static_cast<char*>(mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0));
        if (mappedData == MAP_FAILED) {
            close(fd);
            return {};
        }

        std::vector<char> result(mappedData, mappedData + sb.st_size);

        munmap(mappedData, sb.st_size);
        close(fd);

        return result;
#endif
    }

    // 方法2: 异步读取
    static std::future<std::vector<char>> readAsync(const std::string& filepath) {
        return std::async(std::launch::async, [filepath]() {
            std::ifstream file(filepath, std::ios::binary | std::ios::ate);
            if (!file) return std::vector<char>{};

            std::streamsize size = file.tellg();
            file.seekg(0, std::ios::beg);

            std::vector<char> buffer(size);
            if (file.read(buffer.data(), size)) {
                return buffer;
            }

            return std::vector<char>{};
            });
    }

    // 方法3: 多线程分块读取
    static std::vector<char> readInChunks(const std::string& filepath, size_t chunkSize = 4 * 1024 * 1024) {
        std::ifstream file(filepath, std::ios::binary | std::ios::ate);
        if (!file) return {};

        std::streamsize totalSize = file.tellg();
        file.seekg(0, std::ios::beg);

        std::vector<char> result(totalSize);
        std::vector<std::thread> threads;
        unsigned int numThreads = std::thread::hardware_concurrency();
        size_t chunkPerThread = (totalSize + numThreads - 1) / numThreads;

        for (unsigned int i = 0; i < numThreads; ++i) {
            size_t offset = i * chunkPerThread;
            if (offset >= totalSize) break;

            size_t size = std::min<size_t>(chunkPerThread, totalSize - offset);

            threads.emplace_back([offset, size, &result, filepath]() {
                std::ifstream threadFile(filepath, std::ios::binary);
                if (!threadFile) return;

                threadFile.seekg(offset, std::ios::beg);
                threadFile.read(result.data() + offset, size);
                });
        }

        for (auto& thread : threads) {
            thread.join();
        }

        return result;
    }

private:
    inline static std::mutex fileMutex;
};

int main() {
    auto benchmark = [](std::string_view name, auto&& func) {
        auto start = std::chrono::high_resolution_clock::now();
        func();
        auto end = std::chrono::high_resolution_clock::now();
        std::println("{} took {}ms", name, std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count());
        };
    const std::string imagePath = "E:/Game/BetterGI/Assets/Map/Teyvat/Teyvat_0_2048_SIFT.mat.png";
#define SAVE_TEST
    // 方法1: 使用内存映射文件读取
    benchmark("Memory Mapping", [&]() {
        auto data = HighPerformanceImageReader::readWithMemoryMapping(imagePath);
#ifndef SAVE_TEST
        volatile const char* ptr = data.data(); // 使用volatile防止编译器优化 
        (void)data; // 避免未使用变量警告
#else
        std::ofstream out("E:/cpp-new-feature/cpp11/memory_mapped_file.png", std::ios::binary);
        out.write(data.data(), data.size());
        out.close();
#endif // !SAVE_TEST

        });

    benchmark("Memory Mapping (Optimized)", [&]() {
        MemoryMappedFile mmf(imagePath);
        if (mmf.isOpen()) {
#ifndef SAVE_TEST
            // 直接使用mmf.data()处理数据，避免复制  
            volatile const char* data = mmf.data();
            (void)data;
#else
            std::ofstream out("E:/cpp-new-feature/cpp11/memory_mapped_file_optimized.png", std::ios::binary);
            out.write(mmf.data(), mmf.size());
            out.close();
#endif // !SAVE_TEST
        }
        });

    // 方法2: 异步读取
    benchmark("Async Read", [&]() {
        auto future = HighPerformanceImageReader::readAsync(imagePath);
        auto data = future.get();
#ifndef SAVE_TEST
        volatile const char* ptr = data.data();
        (void)ptr;
#else
        std::ofstream out("E:/cpp-new-feature/cpp11/async_read.png", std::ios::binary);
        out.write(data.data(), data.size());
        out.close();
#endif // !SAVE_TEST
        });

    // 方法3: 多线程分块读取
    benchmark("Chunked Read", [&]() {
        auto data = HighPerformanceImageReader::readInChunks(imagePath);
#ifndef SAVE_TEST
        volatile const char* ptr = data.data();
        (void)ptr;
#else
        std::ofstream out("E:/cpp-new-feature/cpp11/chunked_read.png", std::ios::binary);
        out.write(data.data(), data.size());
        out.close();
#endif // !SAVE_TEST
        });
    /* maybe output:
    1. NOT SAVE
    Memory Mapping took 25ms
    Memory Mapping (Optimized) took 0ms
    Async Read took 54ms
    Chunked Read took 33ms

    2. SAVE
    Memory Mapping took 87ms
    Memory Mapping (Optimized) took 56ms
    Async Read took 103ms
    Chunked Read took 77ms
    */
    return 0;
}

```

