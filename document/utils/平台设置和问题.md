# 栈大小查看设置

## 1. 查看

```c
#ifdef _WIN32
#include <windows.h>
#else
#include <sys/resource.h> // Linux/macOS
// int getrlimit(int resource, struct rlimit *rlptr);
// int setrlimit(int resource, const struct rlimit* rlptr);
#endif // _WIN32
void PrintStackSize() {
#ifdef _WIN32
    ULONG_PTR lowLimit, highLimit;
    GetCurrentThreadStackLimits(&lowLimit, &highLimit);
    std::size_t stackSize = highLimit - lowLimit;
    std::cout << "Stack size: " << stackSize / 1024 << " KB" << std::endl;
#else
    struct rlimit rlim;
    getrlimit(RLIMIT_STACK, &rlim);
    std::cout << "Stack size: " << rlim.rlim_cur / 1024 << " KB" << std::endl;
#endif // _WIN32
}

```

## 2. 设置

```cmake
# CMakeLists.txt
if (MSVC)
    # 设置栈大小为4MB (4194304字节)
    target_link_options(cpp11_main PRIVATE
        "/STACK:4194304"
    )
else()
    # GCC/Clang 使用 -Wl,--stack 选项
    target_link_options(cpp11_main PRIVATE
        "-Wl,--stack,4194304"
    )
endif()

#MSVC
#pragma comment(linker, "/STACK:4194304") // 4MB，Visual Studio项目属性中 命令行设置 /STACK:4194304

# 详细blog	https://blog.csdn.net/Humbunklung/article/details/125889907
```

# 控制台打印编码

```c
#ifdef _WIN32
#include <windows.h>
#endif // _WIN32
#include <iostream>
#include <locale>
int main() {
#ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
#else
    setlocale(LC_ALL, "en_US.UTF-8");
    std::locale::global(std::locale("en_US.UTF-8")); 
    std::cout.imbue(std::locale());
#endif // _WIN32
}
```

# 平台BUG问题

## MSVC

### move和static_cast进行转换右值引用

#### BUG代码

```C
struct X {
    ~X() { puts("X::~X()"); }
};

int main() {
    X&& x1 = std::move(X{}); // right，只打印一次X::~X()
    
    X&& x2 = static_cast<X&&>(X{}); // 打印两次X::~X()
    return 0;
}
```

#### 分析

##### 1. **临时对象的生命周期延长规则**

- 根据C++标准，当临时对象被绑定到const引用或右值引用时，其生命周期会被延长到引用的生命周期。例如，在代码`X&& x = std::move(X{});`中，临时对象`X{}`的生命周期被延长到`x`的作用域结束，因此只会在`x`离开作用域时销毁一次，打印一次`X::~X()`。
- 同样，在`X&& x = static_cast<X&&>(X{});`中，预期行为也应该是生命周期延长，只打印一次析构消息。

##### 2. **MSVC编译器的特殊行为**

- **`std::move`的实现**：MSVC的`std::move`被标记为`_MSVC_INTRINSIC`，这意味着它是一个编译器内置函数（intrinsic）。编译器会对此进行特殊处理，确保在返回右值引用时正确延长临时对象的生命周期。因此，`std::move(X{})`只会导致一次析构调用。
- **直接`static_cast`的问题**：然而，当直接使用`static_cast<X&&>(X{})`时，MSVC编译器（特别是在某些版本或调试模式下）可能存在一个缺陷：临时对象`X{}`在cast表达式结束后立即被销毁，而不是被正确延长生命周期。这导致临时对象被销毁一次，然后当引用`x`离开作用域时，编译器再次尝试销毁同一对象（即悬空引用），从而打印两次析构消息。这是一种未定义行为，可能导致程序崩溃。

##### 3. **根本原因**

- 这一差异源于MSVC的代码生成策略。对于内置函数如`std::move`，编译器能够优化引用绑定过程，避免额外销毁。但对于直接`static_cast`，编译器可能未能正确应用生命周期延长规则，而是将临时对象视为在完整表达式结束时销毁。
- 这可能是MSVC的一个已知问题或编译器bug，在较旧的编译器版本中更为常见。建议更新到最新版本的MSVC，因为Microsoft可能已修复此类问题。
