# 折叠表达式（C++17 ）

C++17 引入了折叠表达式，它允许对参数包中的元素进行二元操作，简化了可变参数模板的编写。折叠表达式有四种形式：一元左折叠、一元右折叠、二元左折叠和二元右折叠。

## 代码示例

```cpp
#include <iostream>
#include <string>
#include <vector>

// 一元左折叠：((((init op arg1) op arg2) op ...) op argN)
template<typename... Args>
auto unary_left_fold(Args... args) {
    return (... + args); // 展开为 ((arg1 + arg2) + ...) + argN
}

// 一元右折叠：(arg1 op (arg2 op (... op argN)))
template<typename... Args>
auto unary_right_fold(Args... args) {
    return (args + ...); // 展开为 arg1 + (arg2 + (... + argN))
}

// 二元左折叠：((((init op arg1) op arg2) op ...) op argN)
template<typename Init, typename... Args>
auto binary_left_fold(Init init, Args... args) {
    return (init + ... + args); // 展开为 (((init + arg1) + arg2) + ...) + argN
}

// 二元右折叠：(arg1 op (arg2 op (... op (argN op init))))
template<typename Init, typename... Args>
auto binary_right_fold(Init init, Args... args) {
    return (args + ... + init); // 展开为 arg1 + (arg2 + (... + (argN + init)))
}

// 打印参数包内容的辅助函数
template<typename T>
void print_arg(T arg) {
    std::cout << arg << " ";
}

template<typename... Args>
void print_all(Args... args) {
    (print_arg(args), ...); // 使用逗号运算符的一元右折叠
    std::cout << std::endl;
}

int main() {
    std::cout << "=== 折叠表达式示例 ===" << std::endl;
    
    // 一元左折叠
    std::cout << "一元左折叠 (1+2+3+4): " << unary_left_fold(1, 2, 3, 4) << std::endl;
    
    // 一元右折叠
    std::cout << "一元右折叠 (1+2+3+4): " << unary_right_fold(1, 2, 3, 4) << std::endl;
    
    // 二元左折叠
    std::cout << "二元左折叠 (10+1+2+3+4): " << binary_left_fold(10, 1, 2, 3, 4) << std::endl;
    
    // 二元右折叠
    std::cout << "二元右折叠 (1+2+3+4+10): " << binary_right_fold(10, 1, 2, 3, 4) << std::endl;
    
    // 使用折叠表达式打印所有参数
    std::cout << "打印所有参数: ";
    print_all(1, 2.5, "Hello", 'A');
    
    // 对于加法，左右折叠结果相同（加法满足结合律）
    std::cout << "\n=== 减法示例（展示结合顺序的区别）===" << std::endl;
    
    // 一元左折叠减法：(((10-1)-2)-3)
    auto left_sub = [](auto... args) { return (args - ...); };
    std::cout << "一元左折叠减法 (10-1-2-3): " << left_sub(10, 1, 2, 3) << std::endl;
    
    // 一元右折叠减法：(10-(1-(2-3)))
    auto right_sub = [](auto... args) { return (... - args); };
    std::cout << "一元右折叠减法 (10-1-2-3): " << right_sub(10, 1, 2, 3) << std::endl;
    
    // 二元左折叠减法：((((100-10)-1)-2)-3)
    std::cout << "二元左折叠减法 (100-10-1-2-3): " << binary_left_fold(100, 10, 1, 2, 3) << std::endl;
    
    // 二元右折叠减法：(10-(1-(2-(3-100))))
    std::cout << "二元右折叠减法 (10-1-2-3-100): " << binary_right_fold(100, 10, 1, 2, 3) << std::endl;
    
    return 0;
}
```

## 折叠表达式展开过程

### 一元左折叠 `(... + args)`
对于调用 `unary_left_fold(1, 2, 3, 4)`，展开过程为：
```
((1 + 2) + 3) + 4
```

### 一元右折叠 `(args + ...)`
对于调用 `unary_right_fold(1, 2, 3, 4)`，展开过程为：
```
1 + (2 + (3 + 4))
```

### 二元左折叠 `(init + ... + args)`
对于调用 `binary_left_fold(10, 1, 2, 3, 4)`，展开过程为：
```
(((10 + 1) + 2) + 3) + 4
```

### 二元右折叠 `(args + ... + init)`
对于调用 `binary_right_fold(10, 1, 2, 3, 4)`，展开过程为：
```
1 + (2 + (3 + (4 + 10)))
```

## 重要注意事项

1. 对于满足结合律的运算符（如加法、乘法），一元左折叠和一元右折叠的结果相同
2. 对于不满足结合律的运算符（如减法、除法），不同折叠方式会产生不同结果
3. 一元折叠要求参数包至少包含一个参数（空参数包会导致编译错误）
4. 二元折叠可以处理空参数包，此时表达式的结果就是初始值

折叠表达式大大简化了可变参数模板的编写，使得处理参数包的代码更加简洁和直观。

------



# `std::integer_sequence`编译时整数序列（C++14）

类模板 `std::integer_sequence` 表示一个编译时整数序列。在此基础上有一些辅助工具：

- `std::make_integer_sequence<T, N>` - 创建一个类型为 `T` 的 `0, ..., N - 1` 序列。
- `std::index_sequence_for<T...>` - 将模板参数包转换为整数序列。

## 将数组转换为元组

```c
template<typename Array, std::size_t... I>
decltype(auto) a2t_impl(const Array& a, std::integer_sequence<std::size_t, I...>) {
  return std::make_tuple(a[I]...);
}

template<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>
decltype(auto) a2t(const std::array<T, N>& a) {
  return a2t_impl(a, Indices());
}
```

## 打印函数

```c
	auto print1 = []<typename...Args>(Args&&...args1) -> void {
        [&/*can write as -> "&...args2 = std::forward<Args>(args1)"*/]() { // &...args2 = std::forward<Args>(args1)引用捕获，...args2 = std::forward<Args>(args1)值捕获
            (std::print("{} ", args1), ...);
            }();
    };
    auto print2 = [](auto&&...args) -> void {
        [&] <std::size_t...idx>(std::index_sequence<idx...>) {
            (std::print("{} ", std::get<idx>(std::forward_as_tuple(args...))/*C++26 can write as -> "args...[idx]"*/), ...);
        }(std::make_index_sequence<sizeof...(args)>{});
        };
    auto print3 = [] <typename... Args>(Args&&... args) {
        /*C++26 can add "template" before for*/for (auto arg : { args... }) {
            std::print("{} ", arg);
        }
    };
    print1("1", "2", "3");
    print2("1", "2", "3");
    print3("1", "2", "3");
    std::cout << std::endl;
```

# 