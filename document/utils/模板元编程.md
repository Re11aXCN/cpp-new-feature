# 折叠表达式（C++17 ）

C++17 引入了折叠表达式，它允许对参数包中的元素进行二元操作，简化了可变参数模板的编写。折叠表达式有四种形式：一元左折叠、一元右折叠、二元左折叠和二元右折叠。

## 代码示例

```cpp
#include <iostream>
#include <string>
#include <vector>

// 一元左折叠：((((init op arg1) op arg2) op ...) op argN)
template<typename... Args>
auto unary_left_fold(Args... args) {
    return (... + args); // 展开为 ((arg1 + arg2) + ...) + argN
}

// 一元右折叠：(arg1 op (arg2 op (... op argN)))
template<typename... Args>
auto unary_right_fold(Args... args) {
    return (args + ...); // 展开为 arg1 + (arg2 + (... + argN))
}

// 二元左折叠：((((init op arg1) op arg2) op ...) op argN)
template<typename Init, typename... Args>
auto binary_left_fold(Init init, Args... args) {
    return (init + ... + args); // 展开为 (((init + arg1) + arg2) + ...) + argN
}

// 二元右折叠：(arg1 op (arg2 op (... op (argN op init))))
template<typename Init, typename... Args>
auto binary_right_fold(Init init, Args... args) {
    return (args + ... + init); // 展开为 arg1 + (arg2 + (... + (argN + init)))
}

// 打印参数包内容的辅助函数
template<typename T>
void print_arg(T arg) {
    std::cout << arg << " ";
}

template<typename... Args>
void print_all(Args... args) {
    (print_arg(args), ...); // 使用逗号运算符的一元右折叠
    std::cout << std::endl;
}

int main() {
    std::cout << "=== 折叠表达式示例 ===" << std::endl;
    
    // 一元左折叠
    std::cout << "一元左折叠 (1+2+3+4): " << unary_left_fold(1, 2, 3, 4) << std::endl;
    
    // 一元右折叠
    std::cout << "一元右折叠 (1+2+3+4): " << unary_right_fold(1, 2, 3, 4) << std::endl;
    
    // 二元左折叠
    std::cout << "二元左折叠 (10+1+2+3+4): " << binary_left_fold(10, 1, 2, 3, 4) << std::endl;
    
    // 二元右折叠
    std::cout << "二元右折叠 (1+2+3+4+10): " << binary_right_fold(10, 1, 2, 3, 4) << std::endl;
    
    // 使用折叠表达式打印所有参数
    std::cout << "打印所有参数: ";
    print_all(1, 2.5, "Hello", 'A');
    
    // 对于加法，左右折叠结果相同（加法满足结合律）
    std::cout << "\n=== 减法示例（展示结合顺序的区别）===" << std::endl;
    
    // 一元左折叠减法：(((10-1)-2)-3)
    auto left_sub = [](auto... args) { return (args - ...); };
    std::cout << "一元左折叠减法 (10-1-2-3): " << left_sub(10, 1, 2, 3) << std::endl;
    
    // 一元右折叠减法：(10-(1-(2-3)))
    auto right_sub = [](auto... args) { return (... - args); };
    std::cout << "一元右折叠减法 (10-1-2-3): " << right_sub(10, 1, 2, 3) << std::endl;
    
    // 二元左折叠减法：((((100-10)-1)-2)-3)
    std::cout << "二元左折叠减法 (100-10-1-2-3): " << binary_left_fold(100, 10, 1, 2, 3) << std::endl;
    
    // 二元右折叠减法：(10-(1-(2-(3-100))))
    std::cout << "二元右折叠减法 (10-1-2-3-100): " << binary_right_fold(100, 10, 1, 2, 3) << std::endl;
    
    return 0;
}
```

## 折叠表达式展开过程

### 一元左折叠 `(... + args)`
对于调用 `unary_left_fold(1, 2, 3, 4)`，展开过程为：
```
((1 + 2) + 3) + 4
```

### 一元右折叠 `(args + ...)`
对于调用 `unary_right_fold(1, 2, 3, 4)`，展开过程为：
```
1 + (2 + (3 + 4))
```

### 二元左折叠 `(init + ... + args)`
对于调用 `binary_left_fold(10, 1, 2, 3, 4)`，展开过程为：
```
(((10 + 1) + 2) + 3) + 4
```

### 二元右折叠 `(args + ... + init)`
对于调用 `binary_right_fold(10, 1, 2, 3, 4)`，展开过程为：
```
1 + (2 + (3 + (4 + 10)))
```

## 逗号运算符在参数包展开中的详细解析

### 逗号运算符的基本行为

在C++中，逗号运算符`,`具有以下特性：
1. 按从左到右的顺序计算每个操作数
2. 返回最右侧操作数的值
3. 整个表达式的类型是最右侧操作数的类型

### 参数包展开中的逗号运算符

#### 原始代码分析

```cpp
template<typename Func, typename... Args>
auto all_of(Func f, Args...args) {
    int _[] = { (0, f(args))... };
    return sizeof...(args) == std::accumulate(std::begin(_), std::end(_), 0);
}
```

#### 执行逻辑顺序

对于调用 `all_of([](int v) -> bool { return v % 2 == 0; }, 1, 2, 3, 4)`：

1. 参数包展开：
   ```cpp
   int _[] = {
       (0, f(1)),  // 第一步：计算0（无效果）
                   // 第二步：计算f(1)→返回false(0)
                   // 第三步：返回f(1)的结果→0
       (0, f(2)),  // 第一步：计算0（无效果）
                   // 第二步：计算f(2)→返回true(1)
                   // 第三步：返回f(2)的结果→1
       (0, f(3)),  // 返回f(3)的结果→0
       (0, f(4))   // 返回f(4)的结果→1
   };
   ```

2. 数组初始化：
   ```cpp
   int _[] = {0, 1, 0, 1};
   ```

3. 累加计算：
   ```cpp
   std::accumulate(std::begin(_), std::end(_), 0) → 0 + 1 + 0 + 1 = 2
   ```

4. 比较结果：
   ```cpp
   return 4 == 2; // 返回false
   ```

#### 为什么需要添加0？

1. **确保类型一致性**：
   - 如果函数`f`返回`void`，直接使用`f(args)...`会导致编译错误
   - `(0, f(args))`确保表达式始终有一个非void的返回值

2. **处理边界情况**：
   - 避免某些运算符优先级问题
   - 提供一种通用的参数包展开模式

3. **历史原因**：
   - 在C++11/14中，这是处理参数包展开的常见习惯用法

#### 顺序调整的影响

如果改为`(f(args), 0)...`：

```cpp
int _[] = { (f(args), 0)... };
```

执行逻辑变为：
1. 先计算`f(args)`（调用函数）
2. 然后计算`0`
3. 返回`0`的值

因此数组会被初始化为全0：`{0, 0, 0, 0}`，完全丢失了函数调用的结果。

### C++17折叠表达式优化

C++17引入的折叠表达式可以大大简化这类代码：

#### 使用逻辑与折叠表达式

```cpp
template<typename Func, typename... Args>
bool all_of(Func f, Args... args) {
    return (f(args) && ...);
}
```

#### 执行过程

对于相同的调用：
```cpp
all_of([](int v) -> bool { return v % 2 == 0; }, 1, 2, 3, 4)
```

折叠表达式展开为：
```cpp
return f(1) && f(2) && f(3) && f(4);
```

执行流程：
1. 计算`f(1)`→返回`false`
2. 由于逻辑与的短路特性，直接返回`false`，不再计算后续表达式

#### 优势

1. **代码简洁**：一行代码替代了原来的多行实现
2. **性能优化**：利用短路求值，遇到第一个`false`就立即返回
3. **类型安全**：不需要中间数组，直接处理布尔结果
4. **可读性高**：意图更加明确，易于理解

### 其他折叠表达式应用

#### 使用逗号运算符折叠

```cpp
template<typename Func, typename... Args>
void for_each(Func f, Args... args) {
    (f(args), ...);
}
```

这个实现会对每个参数调用函数`f`，忽略返回值，类似于原始代码但更加简洁。

#### 复杂条件检查

```cpp
template<typename... Conditions>
bool complex_condition(Conditions... conds) {
    return (conds() && ...);
}
```

可以用于检查多个复杂条件，每个条件通过函数调用获取。

### 总结

逗号运算符在参数包展开中是一种有用的技巧，特别是在C++11/14中。然而，随着C++17折叠表达式的引入，我们可以编写更加简洁、高效和可读的代码。对于`all_of`这样的操作，使用逻辑与折叠表达式是明显更优的选择。

## 重要注意事项

1. 对于满足结合律的运算符（如加法、乘法），一元左折叠和一元右折叠的结果相同
2. 对于不满足结合律的运算符（如减法、除法），不同折叠方式会产生不同结果
3. 一元折叠要求参数包至少包含一个参数（空参数包会导致编译错误）
4. 二元折叠可以处理空参数包，此时表达式的结果就是初始值

折叠表达式大大简化了可变参数模板的编写，使得处理参数包的代码更加简洁和直观。

------



# `std::integer_sequence`编译时整数序列（C++14）

类模板 `std::integer_sequence` 表示一个编译时整数序列。在此基础上有一些辅助工具：

- `std::make_integer_sequence<T, N>` - 创建一个类型为 `T` 的 `0, ..., N - 1` 序列。
- `std::index_sequence_for<T...>` - 将模板参数包转换为整数序列。

## 将数组转换为元组

```c
template<typename Array, std::size_t... I>
decltype(auto) a2t_impl(const Array& a, std::integer_sequence<std::size_t, I...>) {
  return std::make_tuple(a[I]...);
}

template<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>
decltype(auto) a2t(const std::array<T, N>& a) {
  return a2t_impl(a, Indices());
}
```

## 打印函数

```c
auto print1 = []<typename...Args>(Args&&...args1) -> void {
    [&/*can write as -> "&...args2 = std::forward<Args>(args1)"*/]() { // &...args2 = std::forward<Args>(args1)引用捕获，...args2 = std::forward<Args>(args1)值捕获
        (std::print("{} ", args1), ...);
        }();
    std::cout << std::endl;
};
auto print2 = [](auto&&...args) -> void {
    [&] <std::size_t...idx>(std::index_sequence<idx...>) {
        (std::print("{} ", std::get<idx>(std::forward_as_tuple(args...))/*C++26 can write as -> "args...[idx]"*/), ...);
    }(std::make_index_sequence<sizeof...(args)>{});
    std::cout << std::endl;
    };
auto print3 = [] <typename... Args>(Args&&... args) {
    /*C++26 can add "template" before for*/for (auto arg : { args... }) {
        std::print("{} ", arg);
    }
    std::cout << std::endl;
};
auto print4 = []<typename... Args>(const std::tuple<Args...>&_Tuple) {
    constexpr std::size_t N = sizeof...(Args);
    [&] <size_t... I>(std::index_sequence<I...>) {
        (..., (std::cout << std::get<I>(_Tuple) << (I != N - 1 ? " " : "")));
    }(std::make_index_sequence<N>());
    std::cout << std::endl;
};
auto print5 = [](const auto& _Tuple) {
    constexpr std::size_t N = std::tuple_size_v<std::remove_cvref_t<decltype(_Tuple)>>; // 移除参数的CV引用限定符 必须，否则tuple_size_v计算不了
    [&] <size_t... I>(std::index_sequence<I...>) {
        (..., (std::cout << std::get<I>(_Tuple) << (I != N - 1 ? " " : "")));
    }(std::make_index_sequence<N>());
    std::cout << std::endl;
    };
print1("1", "2", 3);
print2("1", "2", 3);
print3("1", "2", "3"); // 类型必须一致
print4(std::make_tuple("1", "2", 3));
print5(std::tuple{ "1", "2", 3 });
std::cout << std::endl;
```

# 初始化列表

## 求和

```c
    auto sum_n = []<typename std::size_t...Ns, typename T>(T(&&... values)[Ns]) {
        // 将多个初始化列表整合为一个
        auto _ = { std::accumulate(std::begin(values), std::end(values), 0)... };
        return std::accumulate(_.begin(), _.end(), 0);
    };
    sum_n({ 1,2,3 }, {5,6});
```

# 存储形参（std::thread的实现）

> [std::thread](./并发支持库.md)
>
> [std::tuple](./通用工具库.md)	
>
> [std::invoke](./通用工具库.md)	
>
> [std::invocable](./概念库.md)	

```c
#include <tuple>
#include <iostream>
template <typename _Func, typename... _Args>
requires std::invocable<_Func, _Args...>
struct Input {
    using R = std::invoke_result_t<_Func, _Args...>;
    _Func _func;
    std::tuple<_Args...> _values;

    Input(_Func&& func, _Args&&... args) : _func(std::forward<_Func>(func)), _values(std::forward<_Args>(args)...) {}
    constexpr R operator()() const noexcept {
        return std::apply([&](auto&&... args) { return _func(args...); }, _values);
    }
};
int main() {
    Input input([](int a, int b) { return a + b; }, 1, 2);
    input();
    std::cout << std::get<0>(input._values) << std::endl;
    return 0;
}
```

# 禁用隐式转换

利用模板匹配有限的特性

```c
void f(int){}

struct X{
    operator int()const { return 0; }
};
struct Y {
    operator double()const { return 0.; }
};

template<typename T>
void f(T) = delete;	//使用弃置函数禁止隐式转换

// void f(auto) = delete; // C++20 起 模板简化
// void f(std::same_as<int> auto) // C++20 起 概念

int main(){
    f(1);               // int
    f(1u);              // unsigned int
    f(1l);              // long
    f(1ll);             // long long
    f(1lu);             // unsigned long
    f(1llu);            // unsigned long long
    f(1.);              // double
    f(1.f);             // float
    f('c');             // char
    f(std::uint8_t{});  // unsigned char
    f(std::int8_t{});   // signed char
    f(X{});             // X
    f(Y{});             // Y
}

```



# SFINAE

```

```

