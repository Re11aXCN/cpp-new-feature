# 头文件

```c
#include <algorithm>
#include <numeric>
#include <execution>
#include <memory>
```



# 算法库

算法库定义了用于各种目的（例如搜索、排序、计数、操作）的函数，这些函数对元素范围进行操作。请注意，[范围](https://cppreference.cn/w/cpp/iterator#Ranges)定义为 `[`first`, `last`)` 其中 last 指的是要检查或修改的最后一个元素*之后*的元素。



###  [约束算法](https://cppreference.cn/w/cpp/algorithm/ranges) (C++20 起)

C++20 提供了命名空间 `std::ranges` 中大多数算法的[约束](https://cppreference.cn/w/cpp/language/constraints)版本。在这些算法中，[范围](https://cppreference.cn/w/cpp/iterator#Ranges)可以指定为 [迭代器](https://cppreference.cn/w/cpp/iterator/input_or_output_iterator)-[哨位](https://cppreference.cn/w/cpp/iterator/sentinel_for)对，或者作为单个 [`range`](https://cppreference.cn/w/cpp/ranges/range) 参数，并且支持投影和成员指针可调用对象。此外，大多数算法的[返回类型](https://cppreference.cn/w/cpp/algorithm/ranges#Return_types)已更改为返回算法执行期间计算的所有可能有用的信息。

```
std::vector<int> v{7, 1, 4, 0, -1};
std::ranges::sort(v); // constrained algorithm
```



###  执行策略 (C++17 起)（`<execution>`）

大多数算法都有接受执行策略的重载。标准库算法支持多种[执行策略](https://cppreference.cn/w/cpp/algorithm/execution_policy_tag_t)，并且库提供了相应的执行策略类型和对象。用户可以通过使用相应类型的[执行策略对象](https://cppreference.cn/w/cpp/algorithm/execution_policy_tag)调用并行算法来静态选择执行策略。

标准库实现（但不是用户）可以定义额外的执行策略作为扩展。使用实现定义的类型的执行策略对象调用的并行算法的语义是实现定义的。

算法的并行版本（除了 [std::for_each](https://cppreference.cn/w/cpp/algorithm/for_each) 和 [std::for_each_n](https://cppreference.cn/w/cpp/algorithm/for_each_n)）被允许从范围中任意复制元素，只要 [std::is_trivially_copy_constructible_v](https://cppreference.cn/w/cpp/types/is_copy_constructible)<T> 和 [std::is_trivially_destructible_v](https://cppreference.cn/w/cpp/types/is_destructible)<T> 都是 true，其中 `T` 是元素的类型。

| 定义于头文件 `<execution>`                                   |                                  |
| ------------------------------------------------------------ | -------------------------------- |
| 定义于命名空间 `std::execution`                              |                                  |
| [ sequenced_policyparallel_policyparallel_unsequenced_policyunsequenced_policy](https://cppreference.cn/w/cpp/algorithm/execution_policy_tag_t)(C++17)(C++17)(C++17)(C++20) | 执行策略类型  (类)               |
| [ seqparpar_unsequnseq](https://cppreference.cn/w/cpp/algorithm/execution_policy_tag)(C++17)(C++17)(C++17)(C++20) | 全局执行策略对象  (常量)         |
| 定义于命名空间 `std`                                         |                                  |
| [ is_execution_policy](https://cppreference.cn/w/cpp/algorithm/is_execution_policy)(C++17) | 测试类是否表示执行策略  (类模板) |

| [特性测试](https://cppreference.cn/w/cpp/utility/feature_test) 宏 | 值                                                           | 标准                                                         | 特性     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| [`__cpp_lib_parallel_algorithm`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_parallel_algorithm) | [`201603L`](https://cppreference.cn/w/cpp/compiler_support/17#cpp_lib_parallel_algorithm_201603L) | (C++17)                                                      | 并行算法 |
| [`__cpp_lib_execution`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_execution) | [`201603L`](https://cppreference.cn/w/cpp/compiler_support/17#cpp_lib_execution_201603L) | (C++17)                                                      | 执行策略 |
| [`201902L`](https://cppreference.cn/w/cpp/compiler_support/20#cpp_lib_execution_201902L) | (C++20)                                                      | [std::execution::unsequenced_policy](https://cppreference.cn/w/cpp/algorithm/execution_policy_tag_t) |          |

###  非修改序列操作

####  批量操作

| 定义于头文件 `<algorithm>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ for_each](https://cppreference.cn/w/cpp/algorithm/for_each) | 将一元[函数对象](https://cppreference.cn/w/cpp/named_req/FunctionObject)应用于[范围](https://cppreference.cn/w/cpp/iterator#Ranges)内的元素  (函数模板) |
| [ ranges::for_each](https://cppreference.cn/w/cpp/algorithm/ranges/for_each)(C++20) | 将一元[函数对象](https://cppreference.cn/w/cpp/named_req/FunctionObject)应用于[范围](https://cppreference.cn/w/cpp/iterator#Ranges)内的元素 (算法函数对象) |
| [ for_each_n](https://cppreference.cn/w/cpp/algorithm/for_each_n)(C++17) | 将函数对象应用于序列的前 N 个元素  (函数模板)                |
| [ ranges::for_each_n](https://cppreference.cn/w/cpp/algorithm/ranges/for_each_n)(C++20) | 将函数对象应用于序列的前 N 个元素 (算法函数对象)             |



####  搜索操作

| 定义于头文件 `<algorithm>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ all_ofany_ofnone_of](https://cppreference.cn/w/cpp/algorithm/all_any_none_of)(C++11)(C++11)(C++11) | 检查谓词对于范围内的所有、任何或没有元素是否为true  (函数模板) |
| [ ranges::all_ofranges::any_ofranges::none_of](https://cppreference.cn/w/cpp/algorithm/ranges/all_any_none_of)(C++20)(C++20)(C++20) | 检查谓词对于范围内的所有、任何或没有元素是否为true (算法函数对象) |
| [ ranges::containsranges::contains_subrange](https://cppreference.cn/w/cpp/algorithm/ranges/contains)(C++23)(C++23) | 检查范围是否包含给定元素或子范围 (算法函数对象)              |
| [ findfind_iffind_if_not](https://cppreference.cn/w/cpp/algorithm/find)(C++11) | 查找满足特定条件的第一个元素  (函数模板)                     |
| [ ranges::findranges::find_ifranges::find_if_not](https://cppreference.cn/w/cpp/algorithm/ranges/find)(C++20)(C++20)(C++20) | 查找满足特定条件的第一个元素 (算法函数对象)                  |
| [ ranges::find_lastranges::find_last_ifranges::find_last_if_not](https://cppreference.cn/w/cpp/algorithm/ranges/find_last)(C++23)(C++23)(C++23) | 查找满足特定条件的最后一个元素 (算法函数对象)                |
| [ find_end](https://cppreference.cn/w/cpp/algorithm/find_end) | 查找某个范围内的最后一个元素序列  (函数模板)                 |
| [ ranges::find_end](https://cppreference.cn/w/cpp/algorithm/ranges/find_end)(C++20) | 查找某个范围内的最后一个元素序列 (算法函数对象)              |
| [ find_first_of](https://cppreference.cn/w/cpp/algorithm/find_first_of) | 搜索元素集合中的任何一个  (函数模板)                         |
| [ ranges::find_first_of](https://cppreference.cn/w/cpp/algorithm/ranges/find_first_of)(C++20) | 搜索元素集合中的任何一个 (算法函数对象)                      |
| [ adjacent_find](https://cppreference.cn/w/cpp/algorithm/adjacent_find) | 查找第一个相等的（或满足给定谓词的）相邻项  (函数模板)       |
| [ ranges::adjacent_find](https://cppreference.cn/w/cpp/algorithm/ranges/adjacent_find)(C++20) | 查找第一个相等的（或满足给定谓词的）相邻项 (算法函数对象)    |
| [ countcount_if](https://cppreference.cn/w/cpp/algorithm/count) | 返回满足特定条件的元素数量  (函数模板)                       |
| [ ranges::countranges::count_if](https://cppreference.cn/w/cpp/algorithm/ranges/count)(C++20)(C++20) | 返回满足特定条件的元素数量 (算法函数对象)                    |
| [ mismatch](https://cppreference.cn/w/cpp/algorithm/mismatch) | 查找两个范围不同的第一个位置  (函数模板)                     |
| [ ranges::mismatch](https://cppreference.cn/w/cpp/algorithm/ranges/mismatch)(C++20) | 查找两个范围不同的第一个位置 (算法函数对象)                  |
| [ equal](https://cppreference.cn/w/cpp/algorithm/equal)      | 确定两组元素是否相同  (函数模板)                             |
| [ ranges::equal](https://cppreference.cn/w/cpp/algorithm/ranges/equal)(C++20) | 确定两组元素是否相同 (算法函数对象)                          |
| [ search](https://cppreference.cn/w/cpp/algorithm/search)    | 搜索元素范围的第一次出现  (函数模板)                         |
| [ ranges::search](https://cppreference.cn/w/cpp/algorithm/ranges/search)(C++20) | 搜索元素范围的第一次出现 (算法函数对象)                      |
| [ search_n](https://cppreference.cn/w/cpp/algorithm/search_n) | 搜索范围内元素的连续副本的第一次出现  (函数模板)             |
| [ ranges::search_n](https://cppreference.cn/w/cpp/algorithm/ranges/search_n)(C++20) | 搜索范围内元素的连续副本的第一次出现 (算法函数对象)          |
| [ ranges::starts_with](https://cppreference.cn/w/cpp/algorithm/ranges/starts_with)(C++23) | 检查一个范围是否以另一个范围开始 (算法函数对象)              |
| [ ranges::ends_with](https://cppreference.cn/w/cpp/algorithm/ranges/ends_with)(C++23) | 检查一个范围是否以另一个范围结束 (算法函数对象)              |



####  折叠操作 (C++23 起)

| 定义于头文件 `<algorithm>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ ranges::fold_left](https://cppreference.cn/w/cpp/algorithm/ranges/fold_left)(C++23) | 左折叠元素范围 (算法函数对象)                                |
| [ ranges::fold_left_first](https://cppreference.cn/w/cpp/algorithm/ranges/fold_left_first)(C++23) | 使用第一个元素作为初始值左折叠元素范围 (算法函数对象)        |
| [ ranges::fold_right](https://cppreference.cn/w/cpp/algorithm/ranges/fold_right)(C++23) | 右折叠元素范围 (算法函数对象)                                |
| [ ranges::fold_right_last](https://cppreference.cn/w/cpp/algorithm/ranges/fold_right_last)(C++23) | 使用最后一个元素作为初始值右折叠元素范围 (算法函数对象)      |
| [ ranges::fold_left_with_iter](https://cppreference.cn/w/cpp/algorithm/ranges/fold_left_with_iter)(C++23) | 左折叠元素范围，并返回一个对 (迭代器, 值) (算法函数对象)     |
| [ ranges::fold_left_first_with_iter](https://cppreference.cn/w/cpp/algorithm/ranges/fold_left_first_with_iter)(C++23) | 使用第一个元素作为初始值左折叠元素范围，并返回一个对 (迭代器, [optional](https://cppreference.cn/w/cpp/utility/optional)) (算法函数对象) |



###  修改序列操作

####  复制操作

| 定义于头文件 `<algorithm>`                                   |                                                 |
| ------------------------------------------------------------ | ----------------------------------------------- |
| [ copycopy_if](https://cppreference.cn/w/cpp/algorithm/copy)(C++11) | 将元素范围复制到新位置  (函数模板)              |
| [ ranges::copyranges::copy_if](https://cppreference.cn/w/cpp/algorithm/ranges/copy)(C++20)(C++20) | 将元素范围复制到新位置 (算法函数对象)           |
| [ copy_n](https://cppreference.cn/w/cpp/algorithm/copy_n)(C++11) | 将一定数量的元素复制到新位置  (函数模板)        |
| [ ranges::copy_n](https://cppreference.cn/w/cpp/algorithm/ranges/copy_n)(C++20) | 将一定数量的元素复制到新位置 (算法函数对象)     |
| [ copy_backward](https://cppreference.cn/w/cpp/algorithm/copy_backward) | 以向后顺序复制元素范围  (函数模板)              |
| [ ranges::copy_backward](https://cppreference.cn/w/cpp/algorithm/ranges/copy_backward)(C++20) | 以向后顺序复制元素范围 (算法函数对象)           |
| [ move](https://cppreference.cn/w/cpp/algorithm/move)(C++11) | 将元素范围移动到新位置  (函数模板)              |
| [ ranges::move](https://cppreference.cn/w/cpp/algorithm/ranges/move)(C++20) | 将元素范围移动到新位置 (算法函数对象)           |
| [ move_backward](https://cppreference.cn/w/cpp/algorithm/move_backward)(C++11) | 以向后顺序将元素范围移动到新位置  (函数模板)    |
| [ ranges::move_backward](https://cppreference.cn/w/cpp/algorithm/ranges/move_backward)(C++20) | 以向后顺序将元素范围移动到新位置 (算法函数对象) |

####  交换操作

| 定义于头文件 `<algorithm>``  `(C++11 前)                     |                                      |
| ------------------------------------------------------------ | ------------------------------------ |
| 定义于头文件 `<utility>``   `(C++11 起)                      |                                      |
| 定义于头文件 `<string_view>`                                 |                                      |
| [ swap](https://cppreference.cn/w/cpp/algorithm/swap)        | 交换两个对象的值  (函数模板)         |
| 定义于头文件 `<algorithm>`                                   |                                      |
| [ swap_ranges](https://cppreference.cn/w/cpp/algorithm/swap_ranges) | 交换两个元素范围  (函数模板)         |
| [ ranges::swap_ranges](https://cppreference.cn/w/cpp/algorithm/ranges/swap_ranges)(C++20) | 交换两个元素范围 (算法函数对象)      |
| [ iter_swap](https://cppreference.cn/w/cpp/algorithm/iter_swap) | 交换两个迭代器指向的元素  (函数模板) |

####  转换操作

| 定义于头文件 `<algorithm>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ transform](https://cppreference.cn/w/cpp/algorithm/transform) | 将函数应用于元素范围，并将结果存储在目标范围中  (函数模板)   |
| [ ranges::transform](https://cppreference.cn/w/cpp/algorithm/ranges/transform)(C++20) | 将函数应用于元素范围 (算法函数对象)                          |
| [ replacereplace_if](https://cppreference.cn/w/cpp/algorithm/replace) | 将所有满足特定条件的值替换为另一个值  (函数模板)             |
| [ ranges::replaceranges::replace_if](https://cppreference.cn/w/cpp/algorithm/ranges/replace)(C++20)(C++20) | 将所有满足特定条件的值替换为另一个值 (算法函数对象)          |
| [ replace_copyreplace_copy_if](https://cppreference.cn/w/cpp/algorithm/replace_copy) | 复制一个范围，并将满足特定条件的元素替换为另一个值  (函数模板) |
| [ ranges::replace_copyranges::replace_copy_if](https://cppreference.cn/w/cpp/algorithm/ranges/replace_copy)(C++20)(C++20) | 复制一个范围，并将满足特定条件的元素替换为另一个值 (算法函数对象) |

####  生成操作

| 定义于头文件 `<algorithm>`                                   |                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| [ fill](https://cppreference.cn/w/cpp/algorithm/fill)        | 将给定值复制赋值给范围内的每个元素  (函数模板)          |
| [ ranges::fill](https://cppreference.cn/w/cpp/algorithm/ranges/fill)(C++20) | 为元素范围分配某个值 (算法函数对象)                     |
| [ fill_n](https://cppreference.cn/w/cpp/algorithm/fill_n)    | 将给定值复制赋值给范围内的 N 个元素  (函数模板)         |
| [ ranges::fill_n](https://cppreference.cn/w/cpp/algorithm/ranges/fill_n)(C++20) | 为一定数量的元素赋值 (算法函数对象)                     |
| [ generate](https://cppreference.cn/w/cpp/algorithm/generate) | 将连续函数调用的结果赋值给范围内的每个元素  (函数模板)  |
| [ ranges::generate](https://cppreference.cn/w/cpp/algorithm/ranges/generate)(C++20) | 将函数的结果保存在范围中 (算法函数对象)                 |
| [ generate_n](https://cppreference.cn/w/cpp/algorithm/generate_n) | 将连续函数调用的结果赋值给范围内的 N 个元素  (函数模板) |
| [ ranges::generate_n](https://cppreference.cn/w/cpp/algorithm/ranges/generate_n)(C++20) | 保存函数 N 次应用的结果 (算法函数对象)                  |

####  移除操作

| 定义于头文件 `<algorithm>`                                   |                                                     |
| ------------------------------------------------------------ | --------------------------------------------------- |
| [ removeremove_if](https://cppreference.cn/w/cpp/algorithm/remove) | 移除满足特定条件的元素  (函数模板)                  |
| [ ranges::removeranges::remove_if](https://cppreference.cn/w/cpp/algorithm/ranges/remove)(C++20)(C++20) | 移除满足特定条件的元素 (算法函数对象)               |
| [ remove_copyremove_copy_if](https://cppreference.cn/w/cpp/algorithm/remove_copy) | 复制元素范围，省略满足特定条件的元素  (函数模板)    |
| [ ranges::remove_copyranges::remove_copy_if](https://cppreference.cn/w/cpp/algorithm/ranges/remove_copy)(C++20)(C++20) | 复制元素范围，省略满足特定条件的元素 (算法函数对象) |
| [ unique](https://cppreference.cn/w/cpp/algorithm/unique)    | 移除范围内的连续重复元素  (函数模板)                |
| [ ranges::unique](https://cppreference.cn/w/cpp/algorithm/ranges/unique)(C++20) | 移除范围内的连续重复元素 (算法函数对象)             |
| [ unique_copy](https://cppreference.cn/w/cpp/algorithm/unique_copy) | 创建一个不包含连续重复元素的范围副本  (函数模板)    |
| [ ranges::unique_copy](https://cppreference.cn/w/cpp/algorithm/ranges/unique_copy)(C++20) | 创建一个不包含连续重复元素的范围副本 (算法函数对象) |

####  顺序更改操作

| 定义于头文件 `<algorithm>`                                   |                                       |
| ------------------------------------------------------------ | ------------------------------------- |
| [ reverse](https://cppreference.cn/w/cpp/algorithm/reverse)  | 反转范围内元素的顺序  (函数模板)      |
| [ ranges::reverse](https://cppreference.cn/w/cpp/algorithm/ranges/reverse)(C++20) | 反转范围内元素的顺序 (算法函数对象)   |
| [ reverse_copy](https://cppreference.cn/w/cpp/algorithm/reverse_copy) | 创建一个反转的范围副本  (函数模板)    |
| [ ranges::reverse_copy](https://cppreference.cn/w/cpp/algorithm/ranges/reverse_copy)(C++20) | 创建一个反转的范围副本 (算法函数对象) |
| [ rotate](https://cppreference.cn/w/cpp/algorithm/rotate)    | 旋转范围内元素的顺序  (函数模板)      |
| [ ranges::rotate](https://cppreference.cn/w/cpp/algorithm/ranges/rotate)(C++20) | 旋转范围内元素的顺序 (算法函数对象)   |
| [ rotate_copy](https://cppreference.cn/w/cpp/algorithm/rotate_copy) | 复制并旋转元素范围  (函数模板)        |
| [ ranges::rotate_copy](https://cppreference.cn/w/cpp/algorithm/ranges/rotate_copy)(C++20) | 复制并旋转元素范围 (算法函数对象)     |
| [ shift_leftshift_right](https://cppreference.cn/w/cpp/algorithm/shift)(C++20) | 移动范围内的元素  (函数模板)          |
| [ ranges::shift_leftranges::shift_right](https://cppreference.cn/w/cpp/algorithm/ranges/shift)(C++23) | 移动范围内的元素 (算法函数对象)       |
| [ random_shuffleshuffle](https://cppreference.cn/w/cpp/algorithm/random_shuffle)(C++17 前)(C++11) | 随机重排范围内的元素  (函数模板)      |
| [ ranges::shuffle](https://cppreference.cn/w/cpp/algorithm/ranges/shuffle)(C++20) | 随机重排范围内的元素 (算法函数对象)   |

####  采样操作

| 定义于头文件 `<algorithm>`                                   |                                          |
| ------------------------------------------------------------ | ---------------------------------------- |
| [ sample](https://cppreference.cn/w/cpp/algorithm/sample)(C++17) | 从序列中选择 N 个随机元素  (函数模板)    |
| [ ranges::sample](https://cppreference.cn/w/cpp/algorithm/ranges/sample)(C++20) | 从序列中选择 N 个随机元素 (算法函数对象) |

###  排序和相关操作

####  要求

某些算法要求由参数表示的序列是“已排序”或“已分区”的。如果未满足要求，则行为未定义。

| 如果对于指向序列的每个迭代器 iter 和每个非负整数 n 使得 iter + n[[1\]](https://cppreference.cn/w/cpp/algorithm#cite_note-plus-1) 是指向序列元素的[有效迭代器](https://cppreference.cn/w/cpp/iterator#Dereferenceability_and_validity)，则序列*相对于比较器 comp* 是*已排序*的，comp(*(iter + n), *iter) == false[[1\]](https://cppreference.cn/w/cpp/algorithm#cite_note-plus-1)。 | (C++20 前)    |
| ------------------------------------------------------------ | ------------- |
| 如果对于指向序列的每个迭代器 iter 和每个非负整数 n 使得 iter + n[[1\]](https://cppreference.cn/w/cpp/algorithm#cite_note-plus-1) 是指向序列元素的有效迭代器，则序列*相对于 comp 和 proj* （对于比较器 comp 和投影 proj）是*已排序*的，bool([std::invoke](https://cppreference.cn/w/cpp/utility/functional/invoke)(comp, [std::invoke](https://cppreference.cn/w/cpp/utility/functional/invoke)(proj, *(iter + n)),             [std::invoke](https://cppreference.cn/w/cpp/utility/functional/invoke)(proj, *iter)))[[1\]](https://cppreference.cn/w/cpp/algorithm#cite_note-plus-1) 为 false。如果序列相对于 comp 和 [std::identity](https://cppreference.cn/w/cpp/utility/functional/identity){} （恒等投影）是已排序的，则序列*相对于比较器 comp* 是*已排序*的。 | (自 C++20 起) |

如果存在一个整数 n，使得对于 `[`0`, `[std::distance](https://cppreference.cn/w/cpp/iterator/distance)(start, finish)`)` 中的所有 i，f(*(start + i))[[1\]](https://cppreference.cn/w/cpp/algorithm#cite_note-plus-1) 仅当 i < n 时为 true，则序列 `[`start`, `finish`)` *相对于表达式 f(e)* 是*已分区*的。

1. ↑ [1.0](https://cppreference.cn/w/cpp/algorithm#cite_ref-plus_1-0) [1.1](https://cppreference.cn/w/cpp/algorithm#cite_ref-plus_1-1) [1.2](https://cppreference.cn/w/cpp/algorithm#cite_ref-plus_1-2) [1.3](https://cppreference.cn/w/cpp/algorithm#cite_ref-plus_1-3) [1.4](https://cppreference.cn/w/cpp/algorithm#cite_ref-plus_1-4) iter + n 仅表示 “iter 递增 n 次的结果”，无论 iter 是否为随机访问迭代器。

####  分区操作

| 定义于头文件 `<algorithm>`                                   |                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| [ is_partitioned](https://cppreference.cn/w/cpp/algorithm/is_partitioned)(C++11) | 确定范围是否由给定谓词分区  (函数模板)                  |
| [ ranges::is_partitioned](https://cppreference.cn/w/cpp/algorithm/ranges/is_partitioned)(C++20) | 确定范围是否由给定谓词分区 (算法函数对象)               |
| [ partition](https://cppreference.cn/w/cpp/algorithm/partition) | 将元素范围划分为两组  (函数模板)                        |
| [ ranges::partition](https://cppreference.cn/w/cpp/algorithm/ranges/partition)(C++20) | 将元素范围划分为两组 (算法函数对象)                     |
| [ partition_copy](https://cppreference.cn/w/cpp/algorithm/partition_copy)(C++11) | 复制范围，将元素划分为两组  (函数模板)                  |
| [ ranges::partition_copy](https://cppreference.cn/w/cpp/algorithm/ranges/partition_copy)(C++20) | 复制范围，将元素划分为两组 (算法函数对象)               |
| [ stable_partition](https://cppreference.cn/w/cpp/algorithm/stable_partition) | 将元素划分为两组，同时保留它们的相对顺序  (函数模板)    |
| [ ranges::stable_partition](https://cppreference.cn/w/cpp/algorithm/ranges/stable_partition)(C++20) | 将元素划分为两组，同时保留它们的相对顺序 (算法函数对象) |
| [ partition_point](https://cppreference.cn/w/cpp/algorithm/partition_point)(C++11) | 定位已分区范围的分区点  (函数模板)                      |
| [ ranges::partition_point](https://cppreference.cn/w/cpp/algorithm/ranges/partition_point)(C++20) | 定位已分区范围的分区点 (算法函数对象)                   |

####  排序操作

| 定义于头文件 `<algorithm>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ sort](https://cppreference.cn/w/cpp/algorithm/sort)        | 将范围按升序排序  (函数模板)                                 |
| [ ranges::sort](https://cppreference.cn/w/cpp/algorithm/ranges/sort)(C++20) | 将范围按升序排序 (算法函数对象)                              |
| [ stable_sort](https://cppreference.cn/w/cpp/algorithm/stable_sort) | 对元素范围进行排序，同时保留相等元素之间的顺序  (函数模板)   |
| [ ranges::stable_sort](https://cppreference.cn/w/cpp/algorithm/ranges/stable_sort)(C++20) | 对元素范围进行排序，同时保留相等元素之间的顺序 (算法函数对象) |
| [ partial_sort](https://cppreference.cn/w/cpp/algorithm/partial_sort) | 对范围的前 N 个元素进行排序  (函数模板)                      |
| [ ranges::partial_sort](https://cppreference.cn/w/cpp/algorithm/ranges/partial_sort)(C++20) | 对范围的前 N 个元素进行排序 (算法函数对象)                   |
| [ partial_sort_copy](https://cppreference.cn/w/cpp/algorithm/partial_sort_copy) | 复制并部分排序元素范围  (函数模板)                           |
| [ ranges::partial_sort_copy](https://cppreference.cn/w/cpp/algorithm/ranges/partial_sort_copy)(C++20) | 复制并部分排序元素范围 (算法函数对象)                        |
| [ is_sorted](https://cppreference.cn/w/cpp/algorithm/is_sorted)(C++11) | 检查范围是否按升序排序  (函数模板)                           |
| [ ranges::is_sorted](https://cppreference.cn/w/cpp/algorithm/ranges/is_sorted)(C++20) | 检查范围是否按升序排序 (算法函数对象)                        |
| [ is_sorted_until](https://cppreference.cn/w/cpp/algorithm/is_sorted_until)(C++11) | 查找最大的已排序子范围  (函数模板)                           |
| [ ranges::is_sorted_until](https://cppreference.cn/w/cpp/algorithm/ranges/is_sorted_until)(C++20) | 查找最大的已排序子范围 (算法函数对象)                        |
| [ nth_element](https://cppreference.cn/w/cpp/algorithm/nth_element) | 部分排序给定范围，确保它按给定元素分区  (函数模板)           |
| [ ranges::nth_element](https://cppreference.cn/w/cpp/algorithm/ranges/nth_element)(C++20) | 部分排序给定范围，确保它按给定元素分区 (算法函数对象)        |

####  二分查找操作（在已分区范围上）

| 定义于头文件 `<algorithm>`                                   |                                                           |
| ------------------------------------------------------------ | --------------------------------------------------------- |
| [ lower_bound](https://cppreference.cn/w/cpp/algorithm/lower_bound) | 返回指向第一个*不小于*给定值的元素的迭代器  (函数模板)    |
| [ ranges::lower_bound](https://cppreference.cn/w/cpp/algorithm/ranges/lower_bound)(C++20) | 返回指向第一个*不小于*给定值的元素的迭代器 (算法函数对象) |
| [ upper_bound](https://cppreference.cn/w/cpp/algorithm/upper_bound) | 返回指向第一个*大于*某个值的元素的迭代器  (函数模板)      |
| [ ranges::upper_bound](https://cppreference.cn/w/cpp/algorithm/ranges/upper_bound)(C++20) | 返回指向第一个*大于*某个值的元素的迭代器 (算法函数对象)   |
| [ equal_range](https://cppreference.cn/w/cpp/algorithm/equal_range) | 返回与特定键匹配的元素范围  (函数模板)                    |
| [ ranges::equal_range](https://cppreference.cn/w/cpp/algorithm/ranges/equal_range)(C++20) | 返回与特定键匹配的元素范围 (算法函数对象)                 |
| [ binary_search](https://cppreference.cn/w/cpp/algorithm/binary_search) | 确定元素是否存在于部分排序的范围中  (函数模板)            |
| [ ranges::binary_search](https://cppreference.cn/w/cpp/algorithm/ranges/binary_search)(C++20) | 确定元素是否存在于部分排序的范围中 (算法函数对象)         |

####  集合操作（在已排序范围上）

| 定义于头文件 `<algorithm>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ includes](https://cppreference.cn/w/cpp/algorithm/includes) | 如果一个序列是另一个序列的子序列，则返回 true  (函数模板)    |
| [ ranges::includes](https://cppreference.cn/w/cpp/algorithm/ranges/includes)(C++20) | 如果一个序列是另一个序列的子序列，则返回 true (算法函数对象) |
| [ set_union](https://cppreference.cn/w/cpp/algorithm/set_union) | 计算两个集合的并集  (函数模板)                               |
| [ ranges::set_union](https://cppreference.cn/w/cpp/algorithm/ranges/set_union)(C++20) | 计算两个集合的并集 (算法函数对象)                            |
| [ set_intersection](https://cppreference.cn/w/cpp/algorithm/set_intersection) | 计算两个集合的交集  (函数模板)                               |
| [ ranges::set_intersection](https://cppreference.cn/w/cpp/algorithm/ranges/set_intersection)(C++20) | 计算两个集合的交集 (算法函数对象)                            |
| [ set_difference](https://cppreference.cn/w/cpp/algorithm/set_difference) | 计算两个集合的差集  (函数模板)                               |
| [ ranges::set_difference](https://cppreference.cn/w/cpp/algorithm/ranges/set_difference)(C++20) | 计算两个集合的差集 (算法函数对象)                            |
| [ set_symmetric_difference](https://cppreference.cn/w/cpp/algorithm/set_symmetric_difference) | 计算两个集合的对称差  (函数模板)                             |
| [ ranges::set_symmetric_difference](https://cppreference.cn/w/cpp/algorithm/ranges/set_symmetric_difference)(C++20) | 计算两个集合的对称差 (算法函数对象)                          |

####  合并操作（在已排序范围上）

| 定义于头文件 `<algorithm>`                                   |                                     |
| ------------------------------------------------------------ | ----------------------------------- |
| [ merge](https://cppreference.cn/w/cpp/algorithm/merge)      | 合并两个已排序的范围  (函数模板)    |
| [ ranges::merge](https://cppreference.cn/w/cpp/algorithm/ranges/merge)(C++20) | 合并两个已排序的范围 (算法函数对象) |
| [ inplace_merge](https://cppreference.cn/w/cpp/algorithm/inplace_merge) | 就地合并两个有序范围  (函数模板)    |
| [ ranges::inplace_merge](https://cppreference.cn/w/cpp/algorithm/ranges/inplace_merge)(C++20) | 就地合并两个有序范围 (算法函数对象) |

####  堆操作

| 如果 bool(comp(first[(i - 1) / 2], first[i])) 对于 `(`0`, `last - first`)` 中的所有整数 i 均为 false，则随机访问[范围](https://cppreference.cn/w/cpp/iterator#Ranges) `[`first`, `last`)` 是*相对于比较器 comp* 的*堆*。 | (C++20 前)    |
| ------------------------------------------------------------ | ------------- |
| 如果 bool([std::invoke](https://cppreference.cn/w/cpp/utility/functional/invoke)(comp, [std::invoke](https://cppreference.cn/w/cpp/utility/functional/invoke)(proj, first[(i - 1) / 2]),             [std::invoke](https://cppreference.cn/w/cpp/utility/functional/invoke)(proj, first[i])) 对于 `(`0`, `last - first`)` 中的所有整数 i 均为 false，则随机访问[范围](https://cppreference.cn/w/cpp/iterator#Ranges) `[`first`, `last`)` 是*相对于 comp 和 proj* 的*堆* （对于比较器 comp 和投影 proj）。如果范围相对于 comp 和 [std::identity](https://cppreference.cn/w/cpp/utility/functional/identity){} （恒等投影）是堆，则随机访问[范围](https://cppreference.cn/w/cpp/iterator#Ranges) `[`first`, `last`)` 是*相对于比较器 comp* 的*堆*。 | (自 C++20 起) |

堆可以使用 [std::make_heap](https://cppreference.cn/w/cpp/algorithm/make_heap) 和 [ranges::make_heap](https://cppreference.cn/w/cpp/algorithm/ranges/make_heap)(自 C++20 起) 创建。

有关堆的更多属性，请参见 [最大堆](https://en.wikipedia.org/wiki/Binary_heap)。



| 定义于头文件 `<algorithm>`                                   |                                                   |
| ------------------------------------------------------------ | ------------------------------------------------- |
| [ push_heap](https://cppreference.cn/w/cpp/algorithm/push_heap) | 向最大堆添加元素  (函数模板)                      |
| [ ranges::push_heap](https://cppreference.cn/w/cpp/algorithm/ranges/push_heap)(C++20) | 向最大堆添加元素 (算法函数对象)                   |
| [ pop_heap](https://cppreference.cn/w/cpp/algorithm/pop_heap) | 从最大堆中移除最大元素  (函数模板)                |
| [ ranges::pop_heap](https://cppreference.cn/w/cpp/algorithm/ranges/pop_heap)(C++20) | 从最大堆中移除最大元素 (算法函数对象)             |
| [ make_heap](https://cppreference.cn/w/cpp/algorithm/make_heap) | 从元素范围创建最大堆  (函数模板)                  |
| [ ranges::make_heap](https://cppreference.cn/w/cpp/algorithm/ranges/make_heap)(C++20) | 从元素范围创建最大堆 (算法函数对象)               |
| [ sort_heap](https://cppreference.cn/w/cpp/algorithm/sort_heap) | 将最大堆转换为按升序排序的元素范围  (函数模板)    |
| [ ranges::sort_heap](https://cppreference.cn/w/cpp/algorithm/ranges/sort_heap)(C++20) | 将最大堆转换为按升序排序的元素范围 (算法函数对象) |
| [ is_heap](https://cppreference.cn/w/cpp/algorithm/is_heap)(C++11) | 检查给定范围是否为最大堆  (函数模板)              |
| [ ranges::is_heap](https://cppreference.cn/w/cpp/algorithm/ranges/is_heap)(C++20) | 检查给定范围是否为最大堆 (算法函数对象)           |
| [ is_heap_until](https://cppreference.cn/w/cpp/algorithm/is_heap_until)(C++11) | 查找作为最大堆的最大子范围  (函数模板)            |
| [ ranges::is_heap_until](https://cppreference.cn/w/cpp/algorithm/ranges/is_heap_until)(C++20) | 查找作为最大堆的最大子范围 (算法函数对象)         |

####  最小值/最大值操作

| 定义于头文件 `<algorithm>`                                   |                                               |
| ------------------------------------------------------------ | --------------------------------------------- |
| [ max](https://cppreference.cn/w/cpp/algorithm/max)          | 返回给定值中较大的值  (函数模板)              |
| [ ranges::max](https://cppreference.cn/w/cpp/algorithm/ranges/max)(C++20) | 返回给定值中较大的值 (算法函数对象)           |
| [ max_element](https://cppreference.cn/w/cpp/algorithm/max_element) | 返回范围内的最大元素  (函数模板)              |
| [ ranges::max_element](https://cppreference.cn/w/cpp/algorithm/ranges/max_element)(C++20) | 返回范围内的最大元素 (算法函数对象)           |
| [ min](https://cppreference.cn/w/cpp/algorithm/min)          | 返回给定值中较小的值  (函数模板)              |
| [ ranges::min](https://cppreference.cn/w/cpp/algorithm/ranges/min)(C++20) | 返回给定值中较小的值 (算法函数对象)           |
| [ min_element](https://cppreference.cn/w/cpp/algorithm/min_element) | 返回范围内的最小元素  (函数模板)              |
| [ ranges::min_element](https://cppreference.cn/w/cpp/algorithm/ranges/min_element)(C++20) | 返回范围内的最小元素 (算法函数对象)           |
| [ minmax](https://cppreference.cn/w/cpp/algorithm/minmax)(C++11) | 返回两个元素中较小和较大的元素  (函数模板)    |
| [ ranges::minmax](https://cppreference.cn/w/cpp/algorithm/ranges/minmax)(C++20) | 返回两个元素中较小和较大的元素 (算法函数对象) |
| [ minmax_element](https://cppreference.cn/w/cpp/algorithm/minmax_element)(C++11) | 返回范围内的最小和最大元素  (函数模板)        |
| [ ranges::minmax_element](https://cppreference.cn/w/cpp/algorithm/ranges/minmax_element)(C++20) | 返回范围内的最小和最大元素 (算法函数对象)     |
| [ clamp](https://cppreference.cn/w/cpp/algorithm/clamp)(C++17) | 将值限制在一对边界值之间  (函数模板)          |
| [ ranges::clamp](https://cppreference.cn/w/cpp/algorithm/ranges/clamp)(C++20) | 将值限制在一对边界值之间 (算法函数对象)       |

####  字典序比较操作

| 定义于头文件 `<algorithm>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ lexicographical_compare](https://cppreference.cn/w/cpp/algorithm/lexicographical_compare) | 如果一个范围在字典序上小于另一个范围，则返回 true  (函数模板) |
| [ ranges::lexicographical_compare](https://cppreference.cn/w/cpp/algorithm/ranges/lexicographical_compare)(C++20) | 如果一个范围在字典序上小于另一个范围，则返回 true (算法函数对象) |
| [ lexicographical_compare_three_way](https://cppreference.cn/w/cpp/algorithm/lexicographical_compare_three_way)(C++20) | 使用三向比较比较两个范围  (函数模板)                         |

####  排列操作

| 定义于头文件 `<algorithm>`                                   |                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| [ next_permutation](https://cppreference.cn/w/cpp/algorithm/next_permutation) | 生成一个元素范围的下一个更大的字典序排列  (函数模板)    |
| [ ranges::next_permutation](https://cppreference.cn/w/cpp/algorithm/ranges/next_permutation)(C++20) | 生成一个元素范围的下一个更大的字典序排列 (算法函数对象) |
| [ prev_permutation](https://cppreference.cn/w/cpp/algorithm/prev_permutation) | 生成一个元素范围的下一个更小的字典序排列  (函数模板)    |
| [ ranges::prev_permutation](https://cppreference.cn/w/cpp/algorithm/ranges/prev_permutation)(C++20) | 生成一个元素范围的下一个更小的字典序排列 (算法函数对象) |
| [ is_permutation](https://cppreference.cn/w/cpp/algorithm/is_permutation)(C++11) | 确定一个序列是否是另一个序列的排列  (函数模板)          |
| [ ranges::is_permutation](https://cppreference.cn/w/cpp/algorithm/ranges/is_permutation)(C++20) | 确定一个序列是否是另一个序列的排列 (算法函数对象)       |

###  数值操作（`<numeric>`）

| 定义于头文件 `<numeric>`                                     |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ iota](https://cppreference.cn/w/cpp/algorithm/iota)(C++11) | 用起始值的连续增量填充一个范围  (函数模板)                   |
| [ ranges::iota](https://cppreference.cn/w/cpp/algorithm/ranges/iota)(C++23) | 用起始值的连续增量填充一个范围 (算法函数对象)                |
| [ accumulate](https://cppreference.cn/w/cpp/algorithm/accumulate) | 对一个元素范围求和或折叠  (函数模板)                         |
| [ inner_product](https://cppreference.cn/w/cpp/algorithm/inner_product) | 计算两个元素范围的内积  (函数模板)                           |
| [ adjacent_difference](https://cppreference.cn/w/cpp/algorithm/adjacent_difference) | 计算一个范围内相邻元素之间的差值  (函数模板)                 |
| [ partial_sum](https://cppreference.cn/w/cpp/algorithm/partial_sum) | 计算一个元素范围的部分和  (函数模板)                         |
| [ reduce](https://cppreference.cn/w/cpp/algorithm/reduce)(C++17) | 类似于 [std::accumulate](https://cppreference.cn/w/cpp/algorithm/accumulate)，但顺序不同  (函数模板) |
| [ exclusive_scan](https://cppreference.cn/w/cpp/algorithm/exclusive_scan)(C++17) | 类似于 [std::partial_sum](https://cppreference.cn/w/cpp/algorithm/partial_sum)，从第 ith 个和中排除第 ith 个输入元素  (函数模板) |
| [ inclusive_scan](https://cppreference.cn/w/cpp/algorithm/inclusive_scan)(C++17) | 类似于 [std::partial_sum](https://cppreference.cn/w/cpp/algorithm/partial_sum)，在第 ith 个和中包含第 ith 个输入元素  (函数模板) |
| [ transform_reduce](https://cppreference.cn/w/cpp/algorithm/transform_reduce)(C++17) | 应用一个可调用对象，然后乱序归约  (函数模板)                 |
| [ transform_exclusive_scan](https://cppreference.cn/w/cpp/algorithm/transform_exclusive_scan)(C++17) | 应用一个可调用对象，然后计算互斥扫描  (函数模板)             |
| [ transform_inclusive_scan](https://cppreference.cn/w/cpp/algorithm/transform_inclusive_scan)(C++17) | 应用一个可调用对象，然后计算包含扫描  (函数模板)             |

###  未初始化内存上的操作（`<memory>`）

| 定义于头文件 `<memory>`                                      |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ uninitialized_copy](https://cppreference.cn/w/cpp/memory/uninitialized_copy) | 将对象范围复制到未初始化的内存区域  (函数模板)               |
| [ ranges::uninitialized_copy](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_copy)(C++20) | 将对象范围复制到未初始化的内存区域 (算法函数对象)            |
| [ uninitialized_copy_n](https://cppreference.cn/w/cpp/memory/uninitialized_copy_n)(C++11) | 将多个对象复制到未初始化的内存区域  (函数模板)               |
| [ ranges::uninitialized_copy_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_copy_n)(C++20) | 将多个对象复制到未初始化的内存区域 (算法函数对象)            |
| [ uninitialized_fill](https://cppreference.cn/w/cpp/memory/uninitialized_fill) | 将一个对象复制到由范围定义的未初始化内存区域  (函数模板)     |
| [ ranges::uninitialized_fill](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_fill)(C++20) | 将一个对象复制到由范围定义的未初始化内存区域 (算法函数对象)  |
| [ uninitialized_fill_n](https://cppreference.cn/w/cpp/memory/uninitialized_fill_n) | 将一个对象复制到由起始位置和计数定义的未初始化内存区域  (函数模板) |
| [ ranges::uninitialized_fill_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_fill_n)(C++20) | 将一个对象复制到由起始位置和计数定义的未初始化内存区域 (算法函数对象) |
| [ uninitialized_move](https://cppreference.cn/w/cpp/memory/uninitialized_move)(C++17) | 将对象范围移动到未初始化的内存区域  (函数模板)               |
| [ ranges::uninitialized_move](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_move)(C++20) | 将对象范围移动到未初始化的内存区域 (算法函数对象)            |
| [ uninitialized_move_n](https://cppreference.cn/w/cpp/memory/uninitialized_move_n)(C++17) | 将多个对象移动到未初始化的内存区域  (函数模板)               |
| [ ranges::uninitialized_move_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_move_n)(C++20) | 将多个对象移动到未初始化的内存区域 (算法函数对象)            |
| [ uninitialized_default_construct](https://cppreference.cn/w/cpp/memory/uninitialized_default_construct)(C++17) | 通过 [默认初始化](https://cppreference.cn/w/cpp/language/default_initialization) 在由范围定义的未初始化内存区域中构造对象  (函数模板) |
| [ ranges::uninitialized_default_construct](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_default_construct)(C++20) | 通过 [默认初始化](https://cppreference.cn/w/cpp/language/default_initialization) 在由范围定义的未初始化内存区域中构造对象 (算法函数对象) |
| [ uninitialized_default_construct_n](https://cppreference.cn/w/cpp/memory/uninitialized_default_construct_n)(C++17) | 通过 [默认初始化](https://cppreference.cn/w/cpp/language/default_initialization) 在由起始位置和计数定义的未初始化内存区域中构造对象  (函数模板) |
| [ ranges::uninitialized_default_construct_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_default_construct_n)(C++20) | 通过 [默认初始化](https://cppreference.cn/w/cpp/language/default_initialization) 在由起始位置和计数定义的未初始化内存区域中构造对象 (算法函数对象) |
| [ uninitialized_value_construct](https://cppreference.cn/w/cpp/memory/uninitialized_value_construct)(C++17) | 通过 [值初始化](https://cppreference.cn/w/cpp/language/value_initialization) 在由范围定义的未初始化内存区域中构造对象  (函数模板) |
| [ ranges::uninitialized_value_construct](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_value_construct)(C++20) | 通过 [值初始化](https://cppreference.cn/w/cpp/language/value_initialization) 在由范围定义的未初始化内存区域中构造对象 (算法函数对象) |
| [ uninitialized_value_construct_n](https://cppreference.cn/w/cpp/memory/uninitialized_value_construct_n)(C++17) | 通过 [值初始化](https://cppreference.cn/w/cpp/language/value_initialization) 在由起始位置和计数定义的未初始化内存区域中构造对象  (函数模板) |
| [ ranges::uninitialized_value_construct_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_value_construct_n)(C++20) | 通过 [值初始化](https://cppreference.cn/w/cpp/language/value_initialization) 在由起始位置和计数定义的未初始化内存区域中构造对象 (算法函数对象) |
| [ destroy](https://cppreference.cn/w/cpp/memory/destroy)(C++17) | 销毁一个对象范围  (函数模板)                                 |
| [ ranges::destroy](https://cppreference.cn/w/cpp/memory/ranges/destroy)(C++20) | 销毁一个对象范围 (算法函数对象)                              |
| [ destroy_n](https://cppreference.cn/w/cpp/memory/destroy_n)(C++17) | 销毁一个范围内多个对象  (函数模板)                           |
| [ ranges::destroy_n](https://cppreference.cn/w/cpp/memory/ranges/destroy_n)(C++20) | 销毁一个范围内多个对象 (算法函数对象)                        |
| [ destroy_at](https://cppreference.cn/w/cpp/memory/destroy_at)(C++17) | 销毁给定地址的对象  (函数模板)                               |
| [ ranges::destroy_at](https://cppreference.cn/w/cpp/memory/ranges/destroy_at)(C++20) | 销毁给定地址的对象 (算法函数对象)                            |
| [ construct_at](https://cppreference.cn/w/cpp/memory/construct_at)(C++20) | 在给定地址创建对象  (函数模板)                               |
| [ ranges::construct_at](https://cppreference.cn/w/cpp/memory/ranges/construct_at)(C++20) | 在给定地址创建对象 (算法函数对象)                            |



###  随机数生成 (自 C++26 起)

| 定义于头文件 `<random>`                                      |                                                           |
| ------------------------------------------------------------ | --------------------------------------------------------- |
| [ ranges::generate_random](https://cppreference.cn/w/cpp/algorithm/ranges/generate_random)(C++26) | 用来自均匀随机位生成器的随机数填充一个范围 (算法函数对象) |

###  注释

| [特性测试](https://cppreference.cn/w/cpp/utility/feature_test) 宏 | 值                                                           | 标准               | 特性                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------ | ------------------------------------------------------------ |
| [`__cpp_lib_algorithm_iterator_requirements`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_algorithm_iterator_requirements) | [`202207L`](https://cppreference.cn/w/cpp/compiler_support/23#cpp_lib_algorithm_iterator_requirements_202207L) | (C++23)            | 作为非 Ranges 算法的输入的 Ranges 迭代器                     |
| [`__cpp_lib_clamp`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_clamp) | [`201603L`](https://cppreference.cn/w/cpp/compiler_support/17#cpp_lib_clamp_201603L) | (C++17)            | [std::clamp](https://cppreference.cn/w/cpp/algorithm/clamp)  |
| [`__cpp_lib_constexpr_algorithms`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_constexpr_algorithms) | [`201806L`](https://cppreference.cn/w/cpp/compiler_support/20#cpp_lib_constexpr_algorithms_201806L) | (C++20)            | 算法的 constexpr                                             |
| [`202306L`](https://cppreference.cn/w/cpp/compiler_support/26#cpp_lib_constexpr_algorithms_202306L) | (C++26)                                                      | Constexpr 稳定排序 |                                                              |
| [`__cpp_lib_algorithm_default_value_type`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_algorithm_default_value_type) | [`202403L`](https://cppreference.cn/w/cpp/compiler_support/26#cpp_lib_algorithm_default_value_type_202403L) | (C++26)            | [列表初始化](https://cppreference.cn/w/cpp/language/list_initialization) 用于算法 |
| [`__cpp_lib_freestanding_algorithm`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_freestanding_algorithm) | [`202311L`](https://cppreference.cn/w/cpp/compiler_support/26#cpp_lib_freestanding_algorithm_202311L) | (C++26)            | [``](https://cppreference.cn/w/cpp/header/algorithm) 中的独立设施 |
| [`__cpp_lib_robust_nonmodifying_seq_ops`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_robust_nonmodifying_seq_ops) | [`201304L`](https://cppreference.cn/w/cpp/compiler_support/14#cpp_lib_robust_nonmodifying_seq_ops_201304L) | (C++14)            | 使非修改序列操作更健壮（[std::mismatch](https://cppreference.cn/w/cpp/algorithm/mismatch)、[std::equal](https://cppreference.cn/w/cpp/algorithm/equal) 和 std::is_permutation 的双范围重载） |
| [`__cpp_lib_sample`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_sample) | [`201603L`](https://cppreference.cn/w/cpp/compiler_support/17#cpp_lib_sample_201603L) | (C++17)            | [std::sample](https://cppreference.cn/w/cpp/algorithm/sample) |
| [`__cpp_lib_shift`](https://cppreference.cn/w/cpp/feature_test#cpp_lib_shift) | [`201806L`](https://cppreference.cn/w/cpp/compiler_support/20#cpp_lib_shift_201806L) | (C++20)            | std::shift_left 和 std::shift_right                          |



###  C 库

| 定义于头文件 `<cstdlib>`                                    |                                        |
| ----------------------------------------------------------- | -------------------------------------- |
| [ qsort](https://cppreference.cn/w/cpp/algorithm/qsort)     | 对未指定类型的元素范围进行排序  (函数) |
| [ bsearch](https://cppreference.cn/w/cpp/algorithm/bsearch) | 在数组中搜索未指定类型的元素  (函数)   |

# Example

## 1.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>
#include <queue>
#include <numeric>
int main() {
    // heap
    {
        std::vector<unsigned> v;
        std::mt19937 gen(std::random_device{}());
        std::uniform_int_distribution<unsigned> dis(0, 100);
        std::generate_n(std::back_inserter(v), 10001, [&]() { return dis(gen); });
        std::vector<unsigned> w(v);

        std::chrono::high_resolution_clock::time_point start = std::chrono::high_resolution_clock::now();
        std::make_heap(v.begin(), v.end());
        std::sort_heap(v.begin(), v.end());
        std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();
        std::cout << "Time taken by std::make_heap and std::sort_heap: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() << " microseconds" << std::endl;
    
        start = std::chrono::high_resolution_clock::now();
        std::priority_queue<unsigned, std::vector<unsigned>, std::greater<unsigned>> pq(w.begin(), w.end());
        end = std::chrono::high_resolution_clock::now();
        
        std::cout << "Time taken by std::make_heap and std::sort_heap: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() << " microseconds" << std::endl;

        std::vector<unsigned> v2;
        while (!pq.empty()) {
            v2.emplace_back(pq.top());
            pq.pop();
        }
        std::cout << std::equal(v.begin(), v.end(), v2.begin());
        std::cout << std::endl;
    }

    // sort
    {
        std::vector<unsigned> v;
        std::mt19937 gen(std::random_device{}());
        std::uniform_int_distribution<unsigned> dis(0, 100);
        std::generate_n(std::back_inserter(v), 10001, [&]() { return dis(gen); });
        std::vector<unsigned> w(v);

        std::chrono::high_resolution_clock::time_point start = std::chrono::high_resolution_clock::now();
        std::stable_sort(v.begin(), v.end());
        std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();
        std::cout << "Time taken by std::sort: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() << " microseconds" << std::endl;

        auto merge_sort = []<typename It, typename Compare = std::less<>>(this auto&& self, It first, It last, Compare comp = Compare()) -> void
        {
            if (last - first > 1) {
                auto mid = first + (last - first) / 2;
                self(first, mid, comp);
                self(mid, last, comp);
                std::inplace_merge(first, mid, last, comp);
            }
        };
        start = std::chrono::high_resolution_clock::now();
        merge_sort(v.begin(), v.end());
        end = std::chrono::high_resolution_clock::now();
        std::cout << "Time taken by merge_sort: " << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() << " microseconds" << std::endl;
    }

    // set_diff
    {
        std::vector<unsigned> v;
        v.resize(10);
        std::iota(v.begin(), v.end(), 0);
        std::vector<unsigned> w;
        std::stable_sort(v.begin(), v.end());
        std::transform(v.begin(), v.end(), std::back_inserter(w), [](unsigned x) { return x * 2; });
        std::set_symmetric_difference(v.begin(), v.end(), w.begin(), w.end(), std::ostream_iterator<unsigned>{std::cout, " "});
        std::cout << std::endl;

        std::ranges::move(v, std::ostream_iterator<unsigned>{std::cout, " "});
        std::cout << std::endl;
    }
    return 0;
}
```

## 2. 桶排序+基数排序

### （1）test

```c++
#include "header.h"
#ifdef _WIN32
// boost容器
// folly
// abseil
#include <windows.h>
// #pragma comment(linker, "/STACK:4194304") // 4MB，或者再CMakeLists.txt/Visual Studio项目属性中设置 https://blog.csdn.net/Humbunklung/article/details/125889907
#else
#include <sys/resource.h> // Linux/macOS
// g++ - Wl, -stack_size - Wl, 0x1000000 program.cpp - o program
// int getrlimit(int resource, struct rlimit *rlptr);
// int setrlimit(int resource, const struct rlimit* rlptr);
#endif // _WIN32
#include <boost/container/small_vector.hpp>
#include <omp.h>
void GetStackSize() {
#ifdef _WIN32
    ULONG_PTR lowLimit, highLimit;
    GetCurrentThreadStackLimits(&lowLimit, &highLimit);
    std::size_t stackSize = highLimit - lowLimit;
    std::cout << "Stack size: " << stackSize / 1024 << " KB" << std::endl;
#else
    struct rlimit rlim;
    getrlimit(RLIMIT_STACK, &rlim);
    std::cout << "Stack size: " << rlim.rlim_cur / 1024 << " KB" << std::endl;
#endif // _WIN32
}

// 概念：可计算的数字类型
template<typename T>
concept NumericType = std::is_arithmetic_v<T> && !std::is_same_v<T, bool>;
// 基数排序优化版本（256桶大小）
template<NumericType T>
void radix_sort_v3_256(T* data, std::size_t size) {
    if (size <= 1) return;

    // 确定是无符号类型还是有符号类型
    using UnsignedT = std::make_unsigned_t<T>;

    // 计算需要多少轮排序（基于类型大小，每次处理8位）
    constexpr std::size_t num_passes = sizeof(T);
    constexpr std::size_t bucket_count = 256; // 每个字节256种可能值

    // 获取处理器数量
    int nproc = omp_get_num_procs();

    // 使用扁平化内存布局
    std::vector<T> buffer(size);
    T* current = data;
    T* next = buffer.data();

    std::array<std::size_t, bucket_count> count{};
    // 局部计数数组（每个处理器一个）
    std::vector<std::size_t> lcount(bucket_count * nproc);

    // 进行多轮排序
    for (std::size_t pass = 0; pass < num_passes; ++pass) {
        // 计算移位量
        std::size_t shift = 8 * pass;

        // 计算每个处理器的块大小
        std::size_t chunk = (size + nproc - 1) / nproc;

        // 并行统计每个处理器的局部计数
#pragma omp parallel for schedule(static, 1)
        for (int c = 0; c < nproc; ++c) {
            uint32_t* lc = lcount.data() + bucket_count * c;

            // 初始化局部计数
            std::fill(lc, lc + bucket_count, 0);

            // 统计当前块的元素
            std::size_t start = c * chunk;
#pragma push_macro(min)
#undef min
            std::size_t end = std::min(size, (c + 1) * chunk);
#pragma pop_macro(min)

            for (std::size_t i = start; i < end; ++i) {
                UnsignedT value;
                if constexpr (std::is_same_v<T, UnsignedT>) {
                    value = current[i]; // 直接使用，避免bit_cast
                }
                else {
                    value = std::bit_cast<UnsignedT>(current[i]);
                }

                uint32_t h = (value >> shift) & 0xFF;

                // 处理有符号类型的符号位（最后一轮）
                if constexpr (std::is_signed_v<T>) {
                    if (pass == num_passes - 1) {
                        h = h ^ 0x80; // 翻转最高位（符号位）
                    }
                }

                ++lc[h];
            }
        }

        // 合并局部计数到全局计数
        uint32_t sum = 0;
        for (std::size_t h = 0; h < bucket_count; ++h) {
            uint32_t lsum = 0;
            for (int c = 0; c < nproc; ++c) {
                uint32_t x = lcount[c * bucket_count + h];
                lcount[c * bucket_count + h] = lsum;
                lsum += x;
            }
            count[h] = sum;
            sum += lsum;
        }

        // 更新局部计数数组，使其包含全局偏移
#pragma omp parallel for schedule(static, 1)
        for (int c = 0; c < nproc; ++c) {
            uint32_t* lc = lcount.data() + bucket_count * c;
            for (std::size_t h = 0; h < bucket_count; ++h) {
                lc[h] += count[h];
            }
        }

        // 并行将元素分配到正确的位置
#pragma omp parallel for schedule(static, 1)
        for (int c = 0; c < nproc; ++c) {
            uint32_t* lc = lcount.data() + bucket_count * c;
            std::size_t start = c * chunk;
#pragma push_macro(min)
#undef min
            std::size_t end = std::min(size, (c + 1) * chunk);
#pragma pop_macro(min)

            for (std::size_t i = start; i < end; ++i) {
                UnsignedT value;
                if constexpr (std::is_same_v<T, UnsignedT>) {
                    value = current[i]; // 直接使用，避免bit_cast
                }
                else {
                    value = std::bit_cast<UnsignedT>(current[i]);
                }

                uint32_t h = (value >> shift) & 0xFF;

                if constexpr (std::is_signed_v<T>) {
                    if (pass == num_passes - 1) {
                        h = h ^ 0x80; // 翻转最高位（符号位）
                    }
                }

                next[lc[h]++] = current[i];
            }
        }

        // 交换当前和下一个缓冲区
        std::swap(current, next);
    }

    // 如果最终结果在缓冲区中，则复制回原数组
    if (current != data) {
        std::copy_n(current, size, data);
    }
}
// 并行优化的基数排序实现
// 优化的基数排序实现
template<NumericType T>
void radix_sort_v3(T* data, std::size_t size) {
    if (size <= 1) return;

    // 确定是无符号类型还是有符号类型
    using UnsignedT = std::make_unsigned_t<T>;

    // 计算需要多少轮排序（基于类型大小，每次处理16位）
    constexpr std::size_t num_passes = (sizeof(T) + 1) / 2; // 向上取整
    constexpr std::size_t bucket_count = 65536; // 每个16位65536种可能值

    // 获取处理器数量
    int nproc = omp_get_num_procs();

    // 使用扁平化内存布局
    std::vector<T> buffer(size);
    T* current = data;
    T* next = buffer.data();

    // 使用uint32_t作为计数类型，提高缓存效率
    std::vector<uint32_t> count(bucket_count);

    // 局部计数数组（每个处理器一个）
    std::vector<uint32_t> lcount(bucket_count * nproc);

    // 进行多轮排序
    for (std::size_t pass = 0; pass < num_passes; ++pass) {
        // 计算移位量
        std::size_t shift = 16 * pass;

        // 计算每个处理器的块大小
        std::size_t chunk = (size + nproc - 1) / nproc;

        // 并行统计每个处理器的局部计数
#pragma omp parallel for schedule(static, 1)
        for (int c = 0; c < nproc; ++c) {
            uint32_t* lc = lcount.data() + bucket_count * c;

            // 初始化局部计数
            std::fill(lc, lc + bucket_count, 0);

            // 统计当前块的元素
            std::size_t start = c * chunk;
#pragma push_macro(min)
#undef min
            std::size_t end = std::min(size, (c + 1) * chunk);
#pragma pop_macro(min)
            for (std::size_t i = start; i < end; ++i) {
                UnsignedT value;
                if constexpr (std::is_same_v<T, UnsignedT>) {
                    value = current[i]; // 直接使用，避免bit_cast
                }
                else {
                    value = std::bit_cast<UnsignedT>(current[i]);
                }

                uint32_t h = (value >> shift) & 0xFFFF;

                // 处理有符号类型的符号位（最后一轮）
                if constexpr (std::is_signed_v<T>) {
                    if (pass == num_passes - 1) {
                        h = h ^ 0x8000; // 翻转最高位（符号位）
                    }
                }

                ++lc[h];
            }
        }

        // 合并局部计数到全局计数
        uint32_t sum = 0;
        for (std::size_t h = 0; h < bucket_count; ++h) {
            uint32_t lsum = 0;
            for (int c = 0; c < nproc; ++c) {
                uint32_t x = lcount[c * bucket_count + h];
                lcount[c * bucket_count + h] = lsum;
                lsum += x;
            }
            count[h] = sum;
            sum += lsum;
        }

        // 更新局部计数数组，使其包含全局偏移
#pragma omp parallel for schedule(static, 1)
        for (int c = 0; c < nproc; ++c) {
            uint32_t* lc = lcount.data() + bucket_count * c;
            for (std::size_t h = 0; h < bucket_count; ++h) {
                lc[h] += count[h];
            }
        }

        // 并行将元素分配到正确的位置
#pragma omp parallel for schedule(static, 1)
        for (int c = 0; c < nproc; ++c) {
            uint32_t* lc = lcount.data() + bucket_count * c;
            std::size_t start = c * chunk;
#pragma push_macro("min")
#undef min
            std::size_t end = std::min(size, (c + 1) * chunk);
#pragma pop_macro("min")

            for (std::size_t i = start; i < end; ++i) {
                UnsignedT value;
                if constexpr (std::is_same_v<T, UnsignedT>) {
                    value = current[i]; // 直接使用，避免bit_cast
                }
                else {
                    value = std::bit_cast<UnsignedT>(current[i]);
                }

                uint32_t h = (value >> shift) & 0xFFFF;

                if constexpr (std::is_signed_v<T>) {
                    if (pass == num_passes - 1) {
                        h = h ^ 0x8000; // 翻转最高位（符号位）
                    }
                }

                next[lc[h]++] = current[i];
            }
        }

        // 交换当前和下一个缓冲区
        std::swap(current, next);
    }

    // 如果最终结果在缓冲区中，则复制回原数组
    if (current != data) {
        std::copy_n(current, size, data);
    }
}
template<NumericType T>
void radix_sort_v2_opt(T* data, std::size_t size) {
    if (size <= 1) return;

    // 确定是无符号类型还是有符号类型
    using UnsignedT = std::make_unsigned_t<T>;

    // 计算需要多少轮排序（基于类型大小）
    constexpr std::size_t num_passes = sizeof(T);
    constexpr std::size_t bucket_count = 256; // 每个字节256种可能值

    // 获取处理器数量
    int nproc = omp_get_num_procs();

    // 使用扁平化内存布局
    std::vector<T> buffer(size);
    T* current = data;
    T* next = buffer.data();

    // 在循环外部定义count和offset数组，避免重复创建
    std::array<std::size_t, bucket_count> count{};
    std::array<std::size_t, bucket_count> offset{};

    // 局部计数数组（每个处理器一个）
    std::vector<std::array<std::size_t, bucket_count>> local_counts(nproc);

    // 进行多轮排序
    for (std::size_t pass = 0; pass < num_passes; ++pass) {
        // 重置计数数组
        std::fill(count.begin(), count.end(), 0);

        // 计算每个处理器的块大小
        std::size_t chunk = (size + nproc - 1) / nproc;

        // 并行统计每个处理器的局部计数
#pragma omp parallel for schedule(static, 1)
        for (int c = 0; c < nproc; ++c) {
            auto& lcount = local_counts[c];
            std::fill(lcount.begin(), lcount.end(), 0);

            std::size_t start = c * chunk;
            std::size_t end = std::min(size, (c + 1) * chunk);

            for (std::size_t i = start; i < end; ++i) {
                UnsignedT value = std::bit_cast<UnsignedT>(current[i]);
                std::size_t byte_index = (value >> (pass * 8)) & 0xFF;

                // 处理有符号类型的符号位（最后一轮）
                if constexpr (std::is_signed_v<T>) {
                    if (pass == num_passes - 1) {
                        byte_index = byte_index ^ 0x80;
                    }
                }

                lcount[byte_index]++;
            }
        }

        // 合并局部计数到全局计数
        for (int c = 0; c < nproc; ++c) {
            for (std::size_t b = 0; b < bucket_count; ++b) {
                count[b] += local_counts[c][b];
            }
        }

        // 计算前缀和（exclusive scan）
        offset[0] = 0;
        for (std::size_t i = 1; i < bucket_count; ++i) {
            offset[i] = offset[i - 1] + count[i - 1];
        }

        // 为每个处理器创建局部偏移数组
        std::vector<std::array<std::size_t, bucket_count>> local_offsets(nproc);
        for (int c = 0; c < nproc; ++c) {
            for (std::size_t b = 0; b < bucket_count; ++b) {
                local_offsets[c][b] = offset[b];
                offset[b] += local_counts[c][b];
            }
        }

        // 并行将元素分配到正确的位置
#pragma omp parallel for schedule(static, 1)
        for (int c = 0; c < nproc; ++c) {
            auto& loffset = local_offsets[c];
            std::size_t start = c * chunk;
            std::size_t end = std::min(size, (c + 1) * chunk);

            for (std::size_t i = start; i < end; ++i) {
                UnsignedT value = std::bit_cast<UnsignedT>(current[i]);
                std::size_t byte_index = (value >> (pass * 8)) & 0xFF;

                if constexpr (std::is_signed_v<T>) {
                    if (pass == num_passes - 1) {
                        byte_index = byte_index ^ 0x80;
                    }
                }

                next[loffset[byte_index]++] = current[i];
            }
        }

        // 交换当前和下一个缓冲区
        std::swap(current, next);
    }

    // 如果最终结果在缓冲区中，则复制回原数组
    if (current != data) {
        std::copy_n(current, size, data);
    }
}
template<NumericType T>
void radix_sort_v2(T* data, std::size_t size) {
    if (size <= 1) return;

    // 确定是无符号类型还是有符号类型
    using UnsignedT = std::make_unsigned_t<T>;

    // 计算需要多少轮排序（基于类型大小）
    constexpr std::size_t num_passes = sizeof(T);
    constexpr std::size_t bucket_count = 256; // 每个字节256种可能值

    // 使用扁平化内存布局
    std::vector<T> buffer(size);
    T* current = data;
    T* next = buffer.data();

    // 在循环外部定义count和offset数组，避免重复创建
    std::array<std::size_t, bucket_count> count{};
    std::array<std::size_t, bucket_count> offset{};

    // 进行多轮排序
    for (std::size_t pass = 0; pass < num_passes; ++pass) {
        // 重置计数数组
        std::fill(count.begin(), count.end(), 0);

        // 统计每个桶的元素数量
        for (std::size_t i = 0; i < size; ++i) {
            UnsignedT value = std::bit_cast<UnsignedT>(current[i]);
            std::size_t byte_index = (value >> (pass * 8)) & 0xFF;

            // 处理有符号类型的符号位（最后一轮）
            if constexpr (std::is_signed_v<T>) {
                if (pass == num_passes - 1) {
                    byte_index = byte_index ^ 0x80;
                }
            }

            count[byte_index]++;
        }

        // 计算前缀和（exclusive scan）
        offset[0] = 0;
        for (std::size_t i = 1; i < bucket_count; ++i) {
            offset[i] = offset[i - 1] + count[i - 1];
        }

        // 将元素分配到正确的位置
        for (std::size_t i = 0; i < size; ++i) {
            UnsignedT value = std::bit_cast<UnsignedT>(current[i]);
            std::size_t byte_index = (value >> (pass * 8)) & 0xFF;

            if constexpr (std::is_signed_v<T>) {
                if (pass == num_passes - 1) {
                    byte_index = byte_index ^ 0x80;
                }
            }

            next[offset[byte_index]++] = current[i];
        }

        // 交换当前和下一个缓冲区
        std::swap(current, next);
    }

    // 如果最终结果在缓冲区中，则复制回原数组
    if (current != data) {
        std::copy_n(current, size, data);
    }
}
#include <c.h>
int main() {
#ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
    //std::cout.imbue(std::locale("en_US.utf8"));
#endif // _WIN32
    GetStackSize();
    auto print1 = []<typename...Args>(Args&&...args1) -> void {
        [&/*can write as -> "...args2 = std::forward<Args>(args1)"*/]() {
            (std::print("{} ", args1), ...);
            }();
    };
    auto print2 = [](auto&&...args) -> void {
        [&] <std::size_t...idx>(std::index_sequence<idx...>) {
            (std::print("{} ", std::get<idx>(std::forward_as_tuple(args...))/*C++26 can write as -> "args...[idx]"*/), ...);
        }(std::make_index_sequence<sizeof...(args)>{});
        };
    auto print3 = [] <typename... Args>(Args&&... args) {
        /*C++26 can add "template" before for*/for (auto arg : { args... }) {
            std::print("{} ", arg);
        }
    };
    print1("1", "2", "3");
    print2("1", "2", "3");
    print3("1", "2", "3");
    std::cout << std::endl;

    auto benchmark = [](std::string_view name, auto&& func) {
        auto start = std::chrono::high_resolution_clock::now();
        func();
        auto end = std::chrono::high_resolution_clock::now();
        std::println("{} took {}ms", name, std::chrono::duration_cast<std::chrono::microseconds>(end - start).count());
        };

    std::vector<uint32_t> vec(10'000);
    
    std::generate(vec.begin(), vec.end(), [rng = std::mt19937{}, dist =
        std::uniform_int_distribution<uint32_t>{ 0, 10'000 }]() mutable
        {
            return dist(rng);
        });
    //boost::container::small_vector<int, 10'000> small_vec;
    //small_vec.assign(vec.begin(), vec.end());

    //benchmark("SORT std::vector", [vec]() mutable { std::sort(vec.begin(), vec.end()); });
    //benchmark("SORT boost::small_vector", [small_vec]() mutable { std::sort(small_vec.begin(), small_vec.end()); });
    //
    //benchmark("STABLE_SORT std::vector", [vec]() mutable { std::stable_sort(vec.begin(), vec.end()); });
    //benchmark("STABLE_SORT boost::small_vector", [small_vec]() mutable { std::stable_sort(small_vec.begin(), small_vec.end()); });
    

    benchmark("RADIX_SORT_V2 std::vector", [vec]() mutable { radix_sort_v2(vec.data(), vec.size()); });
    //benchmark("RADIX_SORT_V3 std::vector", [vec]() mutable { radix_sort_v3_256(vec.data(), vec.size()); });
    benchmark("RADIX_SORT_V2 std::vector", [vec]() mutable { radix_sort_v2_opt(vec.data(), vec.size()); });

    return 0;
}

```

### （3）完整代码

```c
#include <type_traits>
#include <vector>
#include <array>
#include <algorithm>
#include <bit>
#include <iostream>
#include <print>
#include <string_view>
#include <chrono>
#include <random>
#include <omp.h>

template<typename _MaxCapacityType, typename _NumericType, std::uint16_t _Bucket_size = 256U>
    requires (std::is_arithmetic_v<_NumericType> && !std::is_same_v<_NumericType, bool> && (_Bucket_size == 256U || _Bucket_size == 65536U))
void radix_sort(_NumericType* _Ptr, std::size_t _Size)
{
#pragma push_macro("min")
#undef min
    static_assert(
        std::is_same_v<_MaxCapacityType, uint32_t> ||
        std::is_same_v<_MaxCapacityType, size_t> ||
        std::is_same_v<_MaxCapacityType, uint64_t> ||
        std::is_same_v<_MaxCapacityType, uintmax_t> ||
        std::is_same_v<_MaxCapacityType, unsigned> ||
        std::is_same_v<_MaxCapacityType, unsigned int> ||
        std::is_same_v<_MaxCapacityType, unsigned long long>,
        "T must be an unsigned integer type (uint32_t, size_t, uint64_t, etc.)"
        );
    using _Unsigned = std::make_unsigned_t<_NumericType>;

    if (_Size <= 1) return;

    constexpr std::uint8_t _Passes = _Bucket_size == 256U ? sizeof(_NumericType) : (sizeof(_NumericType) + 1) >> 1;
    constexpr std::uint16_t _Mask = _Bucket_size - 1; // 0xFF for 8-bit, 0xFFFF for 16-bit, etc.

    std::array<_MaxCapacityType, _Bucket_size> _Bucket_count{};
#ifdef USE_RADIX_SORT_OMP_PARALLEL
    std::uint8_t _Hardware_concurrency{ (std::uint8_t)(omp_get_num_procs()) };
    std::size_t _Chunk = (_Size + _Hardware_concurrency - 1) / _Hardware_concurrency;
    std::vector<_MaxCapacityType> _Processor_local_buckets(_Bucket_size * _Hardware_concurrency);
#else
    std::array<_MaxCapacityType, _Bucket_size> _Scanned{};
#endif // USE_RADIX_SORT_OMP_PARALLEL

    std::vector<_NumericType> _Buffer(_Size);
    _NumericType* _Start = _Ptr;
    _NumericType* _End = _Buffer.data();

    for (std::uint8_t _Pass = 0; _Pass < _Passes; ++_Pass) {
#ifdef USE_RADIX_SORT_OMP_PARALLEL
#pragma omp parallel for schedule(static, 1)
        for (std::uint8_t _Core = 0; _Core < _Hardware_concurrency; ++_Core) {
            _MaxCapacityType* _Plb_ptr = _Processor_local_buckets.data() + _Bucket_size * _Core;
            for (std::size_t _Idx = 0; _Idx < _Bucket_size; ++_Idx)  _Plb_ptr[_Idx] = 0;

            for (std::size_t _Idx = _Core * _Chunk, _EIdx = std::min(_Size, (_Core + 1) * _Chunk); _Idx < _EIdx; ++_Idx) {
                if constexpr (std::is_signed_v<_NumericType>) {
                    _Unsigned _Value = std::bit_cast<_Unsigned>(_Start[_Idx]);
                    std::uint16_t _Byte_idx = (_Value >> (_Pass * 8)) & _Mask;

                    if (_Pass == _Passes - 1) _Byte_idx ^= _Bucket_size >> 1;

                    ++_Plb_ptr[_Byte_idx];
                }
                else {
                    ++_Plb_ptr[(_Start[_Idx] >> (_Pass * 8)) & _Mask];
                }
            }
        }
#else
        std::fill(_Bucket_count.begin(), _Bucket_count.end(), 0);
        // Count the number of elements per bucket
        for (std::size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            if constexpr (std::is_signed_v<_NumericType>) {
                _Unsigned _Value = std::bit_cast<_Unsigned>(_Start[_Idx]);
                std::uint16_t _Byte_idx = (_Value >> (_Pass * 8)) & _Mask;

                if (_Pass == _Passes - 1) _Byte_idx ^= _Bucket_size >> 1;

                ++_Bucket_count[_Byte_idx];
            }
            else {
                ++_Bucket_count[(_Start[_Idx] >> (_Pass * 8)) & _Mask];
            }
        }
#endif // USE_RADIX_SORT_OMP_PARALLEL
        // Calculate the sum of prefixes by exclusive scan
#ifdef USE_RADIX_SORT_OMP_PARALLEL
        std::size_t _Temp_sum{ 0 };
        for (std::size_t _Idx = 0; _Idx < _Bucket_size; ++_Idx) {
            std::size_t _Temp_sum_local{ 0 };
            for (std::uint8_t _Core = 0; _Core < _Hardware_concurrency; ++_Core) {
                std::size_t _Idx_local = _Bucket_size * _Core + _Idx;
                _MaxCapacityType _Temp_count_local = _Processor_local_buckets[_Idx_local];
                _Processor_local_buckets[_Idx_local] = _Temp_sum_local;
                _Temp_sum_local += _Temp_count_local;
            }
            _Bucket_count[_Idx] = _Temp_sum;
            _Temp_sum += _Temp_sum_local;
        }
#else
        _Scanned[0] = 0;
        for (std::size_t _Idx = 1; _Idx < _Bucket_size; ++_Idx) {
            _Scanned[_Idx] = _Scanned[_Idx - 1] + _Bucket_count[_Idx - 1];
        }
#endif // USE_RADIX_SORT_OMP_PARALLEL

#ifdef USE_RADIX_SORT_OMP_PARALLEL
#pragma omp parallel for schedule(static, 1)
        for (std::uint8_t _Core = 0; _Core < _Hardware_concurrency; ++_Core) {
            _MaxCapacityType* _Plb_ptr = _Processor_local_buckets.data() + _Bucket_size * _Core;
            for (std::size_t _Idx = 0; _Idx < _Bucket_size; ++_Idx)  _Plb_ptr[_Idx] += _Bucket_count[_Idx];

            for (std::size_t _Idx = _Core * _Chunk, _EIdx = std::min(_Size, (_Core + 1) * _Chunk); _Idx < _EIdx; ++_Idx) {
                if constexpr (std::is_signed_v<_NumericType>) {
                    _Unsigned _Value = std::bit_cast<_Unsigned>(_Start[_Idx]);
                    std::uint16_t _Byte_idx = (_Value >> (_Pass * 8)) & _Mask;

                    if (_Pass == _Passes - 1) _Byte_idx ^= _Bucket_size >> 1;

                    _End[_Plb_ptr[_Byte_idx]++] = _Start[_Idx];
                }
                else {
                    _End[_Plb_ptr[(_Start[_Idx] >> (_Pass * 8)) & _Mask]++] = _Start[_Idx];
                }
            }
        }
#else
        // Move elements to their final positions
        for (std::size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            if constexpr (std::is_signed_v<_NumericType>) {
                _Unsigned _Value = std::bit_cast<_Unsigned>(_Start[_Idx]);
                std::uint16_t _Byte_idx = (_Value >> (_Pass * 8)) & _Mask;

                if (_Pass == _Passes - 1) _Byte_idx ^= _Bucket_size >> 1;

                _End[_Scanned[_Byte_idx]++] = _Start[_Idx];
            }
            else {
                std::uint16_t _Byte_idx = (_Start[_Idx] >> (_Pass * 8)) & _Mask;
                _End[_Scanned[_Byte_idx]++] = _Start[_Idx];
            }

        }
#endif // USE_RADIX_SORT_OMP_PARALLEL
        // Swap buffer
        std::swap(_Start, _End);
    }

    if (_Start != _Ptr)  std::copy_n(_Start, _Size, _Ptr);
#pragma pop_macro("min")
}
```

## 3. 找出前n个最小/最大的数

```c
template <typename _Ty, typename _Cmp = std::less<_Ty>>
requires (std::is_arithmetic_v<_Ty> && !std::is_same_v<_Ty, bool>)
std::vector<_Ty> find_top_n(const std::vector<_Ty>& vec, std::size_t n) {
    if (n >= vec.size()) return vec;
    std::priority_queue<_Ty, std::vector<_Ty>, _Cmp> min_heap;

    // 第一阶段：先填充n个元素
    auto it = vec.begin();
    for (; it != vec.end() && min_heap.size() < n; ++it) {
        min_heap.push(*it);
    }

    // 第二阶段：只处理可能大于堆顶的元素
    for (; it != vec.end(); ++it) {
        if (*it > min_heap.top()) {
            min_heap.pop();
            min_heap.push(*it);
        }
    }

    std::vector<_Ty> result;
    result.reserve(n);
    while (!min_heap.empty()) {
        result.push_back(min_heap.top());
        min_heap.pop();
    }
    std::reverse(result.begin(), result.end());
    return result;
}
```

