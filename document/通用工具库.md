# 头文件

```
#include <functional>
#include <utility>
#include <compare>
#include <tuple>
#include <any>
#include <variant>
#include <optional>
#include <expected>

```



# 一、`<functional>`

## 1. 概述定义

此头文件是[函数对象](https://cppreference.cn/w/cpp/utility/functional)库的一部分，并提供标准的[哈希函数](https://cppreference.cn/w/cpp/utility/hash)。

| 命名空间                                                     |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [`placeholders`](https://cppreference.cn/w/cpp/utility/functional/placeholders) (C++11) | 为 [std::bind](https://cppreference.cn/w/cpp/utility/functional/bind) 表达式中未绑定的参数提供占位符 |
| 类                                                           |                                                              |
| 包装器                                                       |                                                              |
| [ function](https://cppreference.cn/w/cpp/utility/functional/function)(C++11) | 任何可复制构造的可调用对象的可复制包装器  (类模板)           |
| [ move_only_function](https://cppreference.cn/w/cpp/utility/functional/move_only_function)(C++23) | 任何支持给定调用签名中限定符的可调用对象的仅移动包装器  (类模板) |
| [ copyable_function](https://cppreference.cn/w/cpp/utility/functional/copyable_function)(C++26) | 任何支持给定调用签名中限定符的可复制构造的可调用对象的可复制包装器  (类模板) |
| [ function_ref](https://cppreference.cn/w/cpp/utility/functional/function_ref)(C++26) | 任何可调用对象的非拥有包装器  (类模板)                       |
| [ mem_fn](https://cppreference.cn/w/cpp/utility/functional/mem_fn)(C++11) | 从成员指针创建函数对象  (函数模板)                           |
| [ reference_wrapper](https://cppreference.cn/w/cpp/utility/functional/reference_wrapper)(C++11) | [*CopyConstructible*](https://cppreference.cn/w/cpp/named_req/CopyConstructible) 和 [*CopyAssignable*](https://cppreference.cn/w/cpp/named_req/CopyAssignable) 引用包装器  (类模板) |
| [ unwrap_referenceunwrap_ref_decay](https://cppreference.cn/w/cpp/utility/functional/unwrap_reference)(C++20)(C++20) | 获取包装在 [std::reference_wrapper](https://cppreference.cn/w/cpp/utility/functional/reference_wrapper) 中的引用类型  (类模板) |
| 辅助类                                                       |                                                              |
| [ bad_function_call](https://cppreference.cn/w/cpp/utility/functional/bad_function_call)(C++11) | 当调用空的 [std::function](https://cppreference.cn/w/cpp/utility/functional/function) 时抛出的异常  (类) |
| [ is_bind_expression](https://cppreference.cn/w/cpp/utility/functional/is_bind_expression)(C++11) | 指示对象是否为 `std::bind` 表达式或可以用作表达式  (类模板)  |
| [ is_placeholder](https://cppreference.cn/w/cpp/utility/functional/is_placeholder)(C++11) | 指示对象是否为标准占位符或可以用作占位符  (类模板)           |
| 算术运算                                                     |                                                              |
| [ plus](https://cppreference.cn/w/cpp/utility/functional/plus) | 实现 x + y 的函数对象  (类模板)                              |
| [ minus](https://cppreference.cn/w/cpp/utility/functional/minus) | 实现 x - y 的函数对象  (类模板)                              |
| [ multiplies](https://cppreference.cn/w/cpp/utility/functional/multiplies) | 实现 x * y 的函数对象  (类模板)                              |
| [ divides](https://cppreference.cn/w/cpp/utility/functional/divides) | 实现 x / y 的函数对象  (类模板)                              |
| [ modulus](https://cppreference.cn/w/cpp/utility/functional/modulus) | 实现 x % y 的函数对象  (类模板)                              |
| [ negate](https://cppreference.cn/w/cpp/utility/functional/negate) | 实现 -x 的函数对象  (类模板)                                 |
| 比较                                                         |                                                              |
| [ equal_to](https://cppreference.cn/w/cpp/utility/functional/equal_to) | 实现 x == y 的函数对象  (类模板)                             |
| [ not_equal_to](https://cppreference.cn/w/cpp/utility/functional/not_equal_to) | 实现 x != y 的函数对象  (类模板)                             |
| [ greater](https://cppreference.cn/w/cpp/utility/functional/greater) | 实现 x > y 的函数对象  (类模板)                              |
| [ less](https://cppreference.cn/w/cpp/utility/functional/less) | 实现 x < y 的函数对象  (类模板)                              |
| [ greater_equal](https://cppreference.cn/w/cpp/utility/functional/greater_equal) | 实现 x >= y 的函数对象  (类模板)                             |
| [ less_equal](https://cppreference.cn/w/cpp/utility/functional/less_equal) | 实现 x <= y 的函数对象  (类模板)                             |
| 概念约束的比较                                               |                                                              |
| [ ranges::equal_to](https://cppreference.cn/w/cpp/utility/functional/ranges/equal_to)(C++20) | 实现 x == y 的约束函数对象  (类)                             |
| [ ranges::not_equal_to](https://cppreference.cn/w/cpp/utility/functional/ranges/not_equal_to)(C++20) | 实现 x != y 的约束函数对象  (类)                             |
| [ ranges::greater](https://cppreference.cn/w/cpp/utility/functional/ranges/greater)(C++20) | 实现 x > y 的约束函数对象  (类)                              |
| [ ranges::less](https://cppreference.cn/w/cpp/utility/functional/ranges/less)(C++20) | 实现 x < y 的约束函数对象  (类)                              |
| [ ranges::greater_equal](https://cppreference.cn/w/cpp/utility/functional/ranges/greater_equal)(C++20) | 实现 x >= y 的约束函数对象  (类)                             |
| [ ranges::less_equal](https://cppreference.cn/w/cpp/utility/functional/ranges/less_equal)(C++20) | 实现 x <= y 的约束函数对象  (类)                             |
| [ compare_three_way](https://cppreference.cn/w/cpp/utility/compare/compare_three_way)(C++20) | 实现 x <=> y 的约束函数对象  (类)                            |
| 逻辑运算                                                     |                                                              |
| [ logical_and](https://cppreference.cn/w/cpp/utility/functional/logical_and) | 实现 x && y 的函数对象  (类模板)                             |
| [ logical_or](https://cppreference.cn/w/cpp/utility/functional/logical_or) | 实现 x \|\| y 的函数对象  (类模板)                           |
| [ logical_not](https://cppreference.cn/w/cpp/utility/functional/logical_not) | 实现 !x 的函数对象  (类模板)                                 |
| 位运算                                                       |                                                              |
| [ bit_and](https://cppreference.cn/w/cpp/utility/functional/bit_and) | 实现 x & y 的函数对象  (类模板)                              |
| [ bit_or](https://cppreference.cn/w/cpp/utility/functional/bit_or) | 实现 x \| y 的函数对象  (类模板)                             |
| [ bit_xor](https://cppreference.cn/w/cpp/utility/functional/bit_xor) | 实现 x ^ y 的函数对象  (类模板)                              |
| [ bit_not](https://cppreference.cn/w/cpp/utility/functional/bit_not)(C++14) | 实现 ~x 的函数对象  (类模板)                                 |
| 取反器                                                       |                                                              |
| [ not_fn](https://cppreference.cn/w/cpp/utility/functional/not_fn)(C++17) | 创建一个函数对象，该对象返回它所持有的函数对象结果的补码  (函数模板) |
| 恒等                                                         |                                                              |
| [ identity](https://cppreference.cn/w/cpp/utility/functional/identity)(C++20) | 返回其参数不变的函数对象  (类)                               |
| 搜索器                                                       |                                                              |
| [ default_searcher](https://cppreference.cn/w/cpp/utility/functional/default_searcher)(C++17) | 标准 C++ 库搜索算法实现  (类模板)                            |
| [ boyer_moore_searcher](https://cppreference.cn/w/cpp/utility/functional/boyer_moore_searcher)(C++17) | Boyer-Moore 搜索算法实现  (类模板)                           |
| [ boyer_moore_horspool_searcher](https://cppreference.cn/w/cpp/utility/functional/boyer_moore_horspool_searcher)(C++17) | Boyer-Moore-Horspool 搜索算法实现  (类模板)                  |
| 哈希                                                         |                                                              |
| [ hash](https://cppreference.cn/w/cpp/utility/hash)(C++11)   | 哈希函数对象  (类模板)                                       |
| [ std::hash<*Arithmetic*>std::hash<*Enumeration*>std::hashstd::hash](https://cppreference.cn/w/cpp/utility/hash)(C++11) | [std::hash](https://cppreference.cn/w/cpp/utility/hash) 对基本类型、枚举类型和指针类型的特化  (类模板特化) |
| 常量                                                         |                                                              |
| 定义于命名空间 `std::placeholders`                           |                                                              |
| [ _1, _2, _3, _4, ...](https://cppreference.cn/w/cpp/utility/functional/placeholders)(C++11) | std::bind 表达式中未绑定参数的占位符  (常量)                 |
| 函数                                                         |                                                              |
| [ bind_frontbind_back](https://cppreference.cn/w/cpp/utility/functional/bind_front)(C++20)(C++23) | 按顺序将可变数量的参数绑定到函数对象  (函数模板)             |
| [ bind](https://cppreference.cn/w/cpp/utility/functional/bind)(C++11) | 将一个或多个参数绑定到函数对象  (函数模板)                   |
| [ refcref](https://cppreference.cn/w/cpp/utility/functional/ref)(C++11)(C++11) | 创建一个 [std::reference_wrapper](https://cppreference.cn/w/cpp/utility/functional/reference_wrapper)，其类型从参数推导而来  (函数模板) |
| [ invokeinvoke_r](https://cppreference.cn/w/cpp/utility/functional/invoke)(C++17)(C++23) | 使用给定参数调用任何 [*Callable*](https://cppreference.cn/w/cpp/named_req/Callable) 对象 并可以指定返回类型(自 C++23 起)  (函数模板) |

在 C++11 中弃用，并在 C++17 中移除

| 基类                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ unary_function](https://cppreference.cn/w/cpp/utility/functional/unary_function)(在 C++11 中弃用)(在 C++17 中移除) | 适配器兼容的 unary function 基类  (类模板)                   |
| [ binary_function](https://cppreference.cn/w/cpp/utility/functional/binary_function)(在 C++11 中弃用)(在 C++17 中移除) | 适配器兼容的 binary function 基类  (类模板)                  |
| 绑定器                                                       |                                                              |
| [ binder1stbinder2nd](https://cppreference.cn/w/cpp/utility/functional/binder12)(在 C++11 中弃用)(在 C++17 中移除) | 持有二元函数及其一个参数的函数对象  (类模板)                 |
| [ bind1stbind2nd](https://cppreference.cn/w/cpp/utility/functional/bind12)(在 C++11 中弃用)(在 C++17 中移除) | 将一个参数绑定到二元函数  (函数模板)                         |
| 函数适配器                                                   |                                                              |
| [ pointer_to_unary_function](https://cppreference.cn/w/cpp/utility/functional/pointer_to_unary_function)(在 C++11 中弃用)(在 C++17 中移除) | 指向一元函数的指针的适配器兼容包装器  (类模板)               |
| [ pointer_to_binary_function](https://cppreference.cn/w/cpp/utility/functional/pointer_to_binary_function)(在 C++11 中弃用)(在 C++17 中移除) | 指向二元函数的指针的适配器兼容包装器  (类模板)               |
| [ ptr_fun](https://cppreference.cn/w/cpp/utility/functional/ptr_fun)(在 C++11 中弃用)(在 C++17 中移除) | 从指向函数的指针创建适配器兼容的函数对象包装器  (函数模板)   |
| [ mem_fun_tmem_fun1_tconst_mem_fun_tconst_mem_fun1_t](https://cppreference.cn/w/cpp/utility/functional/mem_fun_t)(在 C++11 中弃用)(在 C++17 中移除) | 指向无参或一参成员函数的指针的包装器，可通过对象指针调用  (类模板) |
| [ mem_fun](https://cppreference.cn/w/cpp/utility/functional/mem_fun)(在 C++11 中弃用)(在 C++17 中移除) | 从指向成员函数的指针创建包装器，可通过对象指针调用  (函数模板) |
| [ mem_fun_ref_tmem_fun1_ref_tconst_mem_fun_ref_tconst_mem_fun1_ref_t](https://cppreference.cn/w/cpp/utility/functional/mem_fun_ref_t)(在 C++11 中弃用)(在 C++17 中移除) | 指向无参或一参成员函数的指针的包装器，可通过对象引用调用  (类模板) |
| [ mem_fun_ref](https://cppreference.cn/w/cpp/utility/functional/mem_fun_ref)(在 C++11 中弃用)(在 C++17 中移除) | 从指向成员函数的指针创建包装器，可通过对象引用调用  (函数模板) |



在 C++17 中弃用，并在 C++20 中移除

| 取反器                                                       |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ unary_negate](https://cppreference.cn/w/cpp/utility/functional/unary_negate)(在 C++17 中弃用)(在 C++20 中移除) | 包装器函数对象，返回它所持有一元谓词的补  (类模板)           |
| [ binary_negate](https://cppreference.cn/w/cpp/utility/functional/binary_negate)(在 C++17 中弃用)(在 C++20 中移除) | 包装器函数对象，返回它所持有二元谓词的补  (类模板)           |
| [ not1](https://cppreference.cn/w/cpp/utility/functional/not1)(在 C++17 中弃用)(在 C++20 中移除) | 构造自定义的 [std::unary_negate](https://cppreference.cn/w/cpp/utility/functional/unary_negate) 对象  (函数模板) |
| [ not2](https://cppreference.cn/w/cpp/utility/functional/not2)(在 C++17 中弃用)(在 C++20 中移除) | 构造自定义的 [std::binary_negate](https://cppreference.cn/w/cpp/utility/functional/binary_negate) 对象  (函数模板) |

## 2. 使用示例

### (1) reference_wrapper

```cpp
#include <functional>
#include <type_traits>
#ifdef _WIN32
#include <windows.h>
#endif // _WIN32

int main() {
#ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
    //std::cout.imbue(std::locale("en_US.utf8"));
#endif // _WIN32
    static_assert(std::is_same_v<std::unwrap_reference_t<int>, int>);
    static_assert(std::is_same_v<std::unwrap_reference_t<const int>, const int>);
    static_assert(std::is_same_v<std::unwrap_reference_t<int&>, int&>);
    static_assert(std::is_same_v<std::unwrap_reference_t<int&&>, int&&>);
    static_assert(std::is_same_v<std::unwrap_reference_t<int*>, int*>);

    {
        using T = std::reference_wrapper<int>;
        using X = std::unwrap_reference_t<T>;
        static_assert(std::is_same_v<X, int&>);
    }
    {
        using T = std::reference_wrapper<int&>;
        using X = std::unwrap_reference_t<T>;
        static_assert(std::is_same_v<X, int&>);
    }
    static_assert(std::is_same_v<std::unwrap_ref_decay_t<int>, int>);
    static_assert(std::is_same_v<std::unwrap_ref_decay_t<const int>, int>);
    static_assert(std::is_same_v<std::unwrap_ref_decay_t<const int&>, int>);	// 类型退化
    {
        using T = std::reference_wrapper<const int&>;	//包装
        using X = std::unwrap_ref_decay_t<T>;	//类型不退化
        static_assert(std::is_same_v<X, const int&>);
    }
    return 0;
}
```

### (2) 搜索器

#### a. C++17标准定义及自定义拓展搜索器

C++17 引入了三种字符串搜索器，并可通过拓展实现更多搜索算法。以下是各种搜索器的详细比较分析：

| 搜索器                               | 底层算法             | 时间复杂度             | 空间复杂度 | 预处理开销 | 最佳适用场景                 | 推荐模式串大小 | 测试表现评价                 |
| ------------------------------------ | -------------------- | ---------------------- | ---------- | ---------- | ---------------------------- | -------------- | ---------------------------- |
| `std::default_searcher`              | 编译器优化实现       | 取决于编译器实现       | O(1)       | 无         | 通用场景，小模式串           | < 10字符       | 性能优异，与string::find相当 |
| `std::boyer_moore_searcher`          | Boyer-Moore          | O(n/m)最佳，O(n*m)最坏 | O(m+σ)     | 中         | 中大型模式串，性能要求高     | > 10字符       | 长模式串表现优秀             |
| `std::boyer_moore_horspool_searcher` | Boyer-Moore-Horspool | O(n*m)最坏，O(n)平均   | O(σ)       | 低         | 中小型模式串，平衡性能与开销 | 5-50字符       | 综合性能良好                 |
| `kmp_searcher`                       | Knuth-Morris-Pratt   | O(n+m)                 | O(m)       | 中         | 需要最坏情况保证的场景       | 任意长度       | 稳定但平均性能一般           |
| `sunday_searcher`                    | Sunday               | O(n)平均，O(n*m)最坏   | O(σ)       | 低         | 通用场景，特别是英文文本     | 任意长度       | 性能优异，综合表现最佳之一   |
| `rabin_karp_searcher`                | Rabin-Karp           | O(n+m)平均，O(n*m)最坏 | O(1)       | 低         | 多模式搜索，滚动哈希应用场景 | 任意长度       | 当前实现性能较差             |
| `string::find`                       | 编译器优化实现       | 取决于编译器实现       | O(1)       | 无         | 通用场景，原生字符串操作     | 任意长度       | 性能最佳，编译器高度优化     |
| `brute_force_search`                 | 暴力匹配             | O(n*m)                 | O(1)       | 无         | 极小模式串或教学目的         | < 5字符        | 小模式串可用，其他场景避免   |

#### b. 拓展搜索器代码（functional_ex.hpp）

```c
#pragma once

#include <functional>
#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

// KMP (Knuth-Morris-Pratt) searcher implementation
template <class _RanItPat, class _Pred_eq>
void _Build_kmp_failure_table(_Iter_diff_t<_RanItPat>* const _Failure, const _RanItPat _Pat_first,
    const _Iter_diff_t<_RanItPat> _Pat_size, _Pred_eq& _Eq) {
    // Builds KMP failure function table from a pattern [_Pat_first, _Pat_first + _Pat_size)
    using _Diff = _Iter_diff_t<_RanItPat>;

    if (_Pat_size == 0) {
        return;
    }

    _Failure[0] = 0;
    _Diff _Len = 0;

    for (_Diff _Idx = 1; _Idx < _Pat_size; ++_Idx) {
        while (_Len > 0 && !_Eq(_Pat_first[_Idx], _Pat_first[_Len])) {
            _Len = _Failure[_Len - 1];
        }

        if (_Eq(_Pat_first[_Idx], _Pat_first[_Len])) {
            ++_Len;
        }

        _Failure[_Idx] = _Len;
    }
}

template <class _RanItHaystack, class _RanItPat, class _Pred_eq>
pair<_RanItHaystack, _RanItHaystack> _Kmp_search(
    const _Iter_diff_t<_RanItPat>* _Failure, const _RanItPat _Pat_first, const _Iter_diff_t<_RanItPat> _Pat_size,
    _RanItHaystack _First, _RanItHaystack _Last, _Pred_eq& _Eq) {
    // KMP string search algorithm
    static_assert(is_same_v<_Iter_value_t<_RanItPat>, _Iter_value_t<_RanItHaystack>>,
        "kmp_searcher requires matching iterator value types");
    using _Diff = _Iter_diff_t<_RanItPat>;

    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);

    if (_Pat_size == 0) {
        return { _First, _First };
    }

    const auto _UPat_first = _STD _Get_unwrapped_n(_Pat_first, _Pat_size);
    _Diff _Pat_idx = 0;

    while (_UFirst != _ULast) {
        if (_Eq(*_UFirst, _UPat_first[_Pat_idx])) {
            ++_Pat_idx;
            ++_UFirst;

            if (_Pat_idx == _Pat_size) {
                // Found match
                const auto _Match_start = _UFirst - _Pat_size;
                _STD _Seek_wrapped(_Last, _UFirst);
                _STD _Seek_wrapped(_First, _Match_start);
                return { _First, _Last };
            }
        }
        else {
            if (_Pat_idx != 0) {
                _Pat_idx = _Failure[_Pat_idx - 1];
            }
            else {
                ++_UFirst;
            }
        }
    }

    _STD _Seek_wrapped(_Last, _ULast);
    _STD _Seek_wrapped(_First, _ULast);
    return { _First, _Last };
}

_EXPORT_STD template <class _RanItPat, class _Pred_eq = equal_to<>>
class kmp_searcher {
public:
    kmp_searcher(const _RanItPat _First, const _RanItPat _Last, _Pred_eq _Eq = _Pred_eq())
        : _Pat_first(_First), _Pat_size(_STD _Get_unwrapped(_Last) - _STD _Get_unwrapped(_First)), _Eq(_STD move(_Eq)) {
        // preprocess a pattern for use with the KMP string search algorithm
        _STD _Adl_verify_range(_First, _Last);

        if (_Pat_size > 0) {
            _Failure_table = _STD make_unique<_Iter_diff_t<_RanItPat>[]>(static_cast<size_t>(_Pat_size));
            _STD _Build_kmp_failure_table(_Failure_table.get(), _STD _Get_unwrapped(_First), _Pat_size, _Eq);
        }
    }

    template <class _RanItHaystack>
    _NODISCARD pair<_RanItHaystack, _RanItHaystack> operator()(
        const _RanItHaystack _First, const _RanItHaystack _Last) const {
        // search for the preprocessed pattern in [_First, _Last)
        if (_Pat_size == 0) {
            return { _First, _First };
        }

        return _STD _Kmp_search(_Failure_table.get(), _Pat_first, _Pat_size, _First, _Last, _Eq);
    }

private:
    _RanItPat _Pat_first;
    _Iter_diff_t<_RanItPat> _Pat_size;
    _Pred_eq _Eq;
    unique_ptr<_Iter_diff_t<_RanItPat>[]> _Failure_table;
};

// Rabin-Karp searcher implementation
template <class _Value_t>
struct _Rabin_karp_hash {
    using _Hash_t = size_t;
    static constexpr _Hash_t _Base = 257;
    static constexpr _Hash_t _Mod = 1000000007; // Large prime number

    static _Hash_t _To_unsigned_byte(_Value_t _Char) {
        return static_cast<_Hash_t>(static_cast<unsigned char>(_Char));
    }

    static _Hash_t _Compute_hash(const _Value_t* _Data, size_t _Len) {
        _Hash_t _Hash = 0;
        for (size_t _Idx = 0; _Idx < _Len; ++_Idx) {
            _Hash = (_Hash * _Base + _To_unsigned_byte(_Data[_Idx])) % _Mod;
        }

        return _Hash;
    }

    static _Hash_t _Roll_hash(_Hash_t _Old_hash, _Value_t _Old_char, _Value_t _New_char, _Hash_t _Highest_power) {
        // Remove old character and add new character
        _Hash_t _New_hash = (_Old_hash + _Mod - (_To_unsigned_byte(_Old_char) * _Highest_power) % _Mod) % _Mod;
        _New_hash = (_New_hash * _Base + _To_unsigned_byte(_New_char)) % _Mod;
        return _New_hash;
    }

    static _Hash_t _Roll_hash(_Hash_t _Old_hash, const _Value_t* _Old_chars,
        const _Value_t* _New_chars, size_t _Char_len, _Hash_t _Highest_power) {
        // Remove the contribution of the first character in the previous window
        // Note: _Old_chars points to the start of the character sequence to remove
        _Hash_t _Char_value = _Compute_hash(_Old_chars, _Char_len);
        _Hash_t _New_hash = (_Old_hash + _Mod - (_Char_value * _Highest_power) % _Mod) % _Mod;

        // Add the contribution of the new character
        // Note: _New_chars points to the start of the character sequence to add
        return _Compute_hash(_New_chars, _Char_len);
    }

    static _Hash_t _Fast_power(_Hash_t base, _Hash_t exp, _Hash_t mod) {
        _Hash_t result = 1;
        base %= mod;

        while (exp > 0) {
            if (exp & 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp >>= 1;
        }

        return result;
    }

    static _Hash_t _Compute_highest_power(size_t _Pattern_length) {
        if (_Pattern_length == 0) return 1;
        return _Fast_power(_Base, _Pattern_length - 1, _Mod);
    }
    
};

template <class _RanItHaystack, class _RanItPat, class _Pred_eq>
pair<_RanItHaystack, _RanItHaystack> _Rabin_karp_search(
    const _RanItPat _Pat_first, const _Iter_diff_t<_RanItPat> _Pat_size,
    _RanItHaystack _First, _RanItHaystack _Last, _Pred_eq& _Eq) {
    // Rabin-Karp string search algorithm
    static_assert(is_same_v<_Iter_value_t<_RanItPat>, _Iter_value_t<_RanItHaystack>>,
        "rabin_karp_searcher requires matching iterator value types");
    using _Value_t = _Iter_value_t<_RanItPat>;
    using _Hash = _Rabin_karp_hash<_Value_t>;
    using _Diff = _Iter_diff_t<_RanItPat>;

    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);

    if (_Pat_size == 0) {
        return { _First, _First };
    }

    const auto _UPat_first = _STD _Get_unwrapped_n(_Pat_first, _Pat_size);
    const auto _Haystack_size = _ULast - _UFirst;

    if (_Haystack_size < _Pat_size) {
        _STD _Seek_wrapped(_Last, _ULast);
        _STD _Seek_wrapped(_First, _ULast);
        return { _First, _Last };
    }

    // Compute pattern hash
    const auto _Pattern_hash = _Hash::_Compute_hash(_UPat_first, static_cast<size_t>(_Pat_size));

    // Compute power for rolling hash
    const auto _Highest_power = _Hash::_Compute_highest_power(static_cast<size_t>(_Pat_size));

    // Compute initial window hash
    auto _Text_hash = _Hash::_Compute_hash(_UFirst, static_cast<size_t>(_Pat_size));

    // Check first window
    if (_Text_hash == _Pattern_hash) {
        if (_STD equal(_UPat_first, _UPat_first + _Pat_size, _UFirst, _STD _Pass_fn(_Eq))) {
            _STD _Seek_wrapped(_Last, _UFirst + _Pat_size);
            _STD _Seek_wrapped(_First, _UFirst);
            return { _First, _Last };
        }
    }
    // Roll the hash and check remaining windows
    for (auto _Text_start = _UFirst + 1; _Text_start <= _ULast - _Pat_size; ++_Text_start) {
        _Text_hash = _Hash::_Roll_hash(_Text_hash, *(_Text_start - 1), *(_Text_start + _Pat_size - 1), _Highest_power);

        if (_Text_hash == _Pattern_hash) {
            if (_STD equal(_UPat_first, _UPat_first + _Pat_size, _Text_start, _STD _Pass_fn(_Eq))) {
                _STD _Seek_wrapped(_Last, _Text_start + _Pat_size);
                _STD _Seek_wrapped(_First, _Text_start);
                return { _First, _Last };
            }
        }
    }

    _STD _Seek_wrapped(_Last, _ULast);
    _STD _Seek_wrapped(_First, _ULast);
    return { _First, _Last };
}

_EXPORT_STD template <class _RanItPat, class _Pred_eq = equal_to<>>
class rabin_karp_searcher {
public:
    rabin_karp_searcher(const _RanItPat _First, const _RanItPat _Last, _Pred_eq _Eq = _Pred_eq())
        : _Pat_first(_First), _Pat_size(_STD _Get_unwrapped(_Last) - _STD _Get_unwrapped(_First)), _Eq(_STD move(_Eq)) {
        // preprocess a pattern for use with the Rabin-Karp string search algorithm
        _STD _Adl_verify_range(_First, _Last);
    }

    template <class _RanItHaystack>
    _NODISCARD pair<_RanItHaystack, _RanItHaystack> operator()(
        const _RanItHaystack _First, const _RanItHaystack _Last) const {
        // search for the preprocessed pattern in [_First, _Last)
        if (_Pat_size == 0) {
            return { _First, _First };
        }

        return _STD _Rabin_karp_search(_Pat_first, _Pat_size, _First, _Last, _Eq);
    }

private:
    _RanItPat _Pat_first;
    _Iter_diff_t<_RanItPat> _Pat_size;
    _Pred_eq _Eq;
};

// Sunday searcher implementation
template <class _Value_t>
struct _Sunday_bad_char_table {
    static constexpr size_t _Table_size = 256; // For char/unsigned char

    template <class _RanItPat>
    static void _Build_table(_Iter_diff_t<_RanItPat>* _Table, const _RanItPat _Pat_first,
        const _Iter_diff_t<_RanItPat> _Pat_size) {
        // Initialize all entries to pattern length + 1
        const auto _Default_shift = _Pat_size + 1;
        for (size_t _Idx = 0; _Idx < _Table_size; ++_Idx) {
            _Table[_Idx] = _Default_shift;
        }

        // Fill table with actual shift values
        for (_Iter_diff_t<_RanItPat> _Idx = 0; _Idx < _Pat_size; ++_Idx) {
            const auto _Char_val = static_cast<unsigned char>(_Pat_first[_Idx]);
            _Table[_Char_val] = _Pat_size - _Idx;
        }
    }
};

template <class _RanItHaystack, class _RanItPat, class _Pred_eq>
pair<_RanItHaystack, _RanItHaystack> _Sunday_search(
    const _RanItPat _Pat_first, const _Iter_diff_t<_RanItPat> _Pat_size,
    _RanItHaystack _First, _RanItHaystack _Last, _Pred_eq& _Eq) {
    // Sunday string search algorithm
    static_assert(is_same_v<_Iter_value_t<_RanItPat>, _Iter_value_t<_RanItHaystack>>,
        "sunday_searcher requires matching iterator value types");
    using _Value_t = _Iter_value_t<_RanItPat>;
    using _Diff = _Iter_diff_t<_RanItPat>;

    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);

    if (_Pat_size == 0) {
        return { _First, _First };
    }

    const auto _UPat_first = _STD _Get_unwrapped_n(_Pat_first, _Pat_size);
    const auto _Haystack_size = _ULast - _UFirst;

    if (_Haystack_size < _Pat_size) {
        _STD _Seek_wrapped(_Last, _ULast);
        _STD _Seek_wrapped(_First, _ULast);
        return { _First, _Last };
    }

    // Build bad character table
    _Diff _Bad_char_table[_Sunday_bad_char_table<_Value_t>::_Table_size];
    _Sunday_bad_char_table<_Value_t>::_Build_table(_Bad_char_table, _UPat_first, _Pat_size);

    auto _Text_pos = _UFirst;

    while (_Text_pos <= _ULast - _Pat_size) {
        // Compare pattern with current window
        _Diff _Match_pos = 0;
        while (_Match_pos < _Pat_size && _STD _Pass_fn(_Eq)(_UPat_first[_Match_pos], _Text_pos[_Match_pos])) {
            ++_Match_pos;
        }

        if (_Match_pos == _Pat_size) {
            // Found a match
            _STD _Seek_wrapped(_Last, _Text_pos + _Pat_size);
            _STD _Seek_wrapped(_First, _Text_pos);
            return { _First, _Last };
        }

        // Calculate shift using Sunday algorithm
        const auto _Next_pos = _Text_pos + _Pat_size;
        if (_Next_pos < _ULast) {
            const auto _Next_char = static_cast<unsigned char>(*_Next_pos);
            _Text_pos += _Bad_char_table[_Next_char];
        }
        else {
            break; // No more characters to examine
        }
    }

    _STD _Seek_wrapped(_Last, _ULast);
    _STD _Seek_wrapped(_First, _ULast);
    return { _First, _Last };
}

_EXPORT_STD template <class _RanItPat, class _Pred_eq = equal_to<>>
class sunday_searcher {
public:
    sunday_searcher(const _RanItPat _First, const _RanItPat _Last, _Pred_eq _Eq = _Pred_eq())
        : _Pat_first(_First), _Pat_size(_STD _Get_unwrapped(_Last) - _STD _Get_unwrapped(_First)), _Eq(_STD move(_Eq)) {
        // preprocess a pattern for use with the Sunday string search algorithm
        _STD _Adl_verify_range(_First, _Last);
    }

    template <class _RanItHaystack>
    _NODISCARD pair<_RanItHaystack, _RanItHaystack> operator()(
        const _RanItHaystack _First, const _RanItHaystack _Last) const {
        // search for the preprocessed pattern in [_First, _Last)
        if (_Pat_size == 0) {
            return { _First, _First };
        }

        return _STD _Sunday_search(_Pat_first, _Pat_size, _First, _Last, _Eq);
    }

private:
    _RanItPat _Pat_first;
    _Iter_diff_t<_RanItPat> _Pat_size;
    _Pred_eq _Eq;
};


_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
```



#### c. 示例代码及性能测试结果

```cpp
#include <chrono>
#include <print>
#include <iostream>
#include <fstream>
#include <functional>
#include <algorithm>
#include <sstream>
#include <iomanip>

#ifdef _WIN32
#include <windows.h>
#endif // _WIN32
//#include "functional_ex.hpp"

// 暴力循环匹配字符串函数
template <typename Iter1, typename Iter2>
Iter1 brute_force_search(Iter1 text_start, Iter1 text_end, Iter2 pattern_start, Iter2 pattern_end) {
    if (pattern_start == pattern_end) return text_start; // 空模式

    Iter1 current = text_start;
    while (current != text_end) {
        Iter1 text_it = current;
        Iter2 pattern_it = pattern_start;

        // 尝试匹配模式
        while (text_it != text_end && pattern_it != pattern_end && *text_it == *pattern_it) {
            ++text_it;
            ++pattern_it;
        }

        // 如果整个模式都匹配了
        if (pattern_it == pattern_end) {
            return current;
        }

        ++current;
    }

    return text_end; // 未找到
}

// 测试函数：测量搜索器的性能
void test_searcher(const std::string& name, std::function<bool()> searcher_func) {
    auto start = std::chrono::high_resolution_clock::now();
    bool found = searcher_func();
    auto end = std::chrono::high_resolution_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::left(std::cout);
    std::cout << std::setw(32) << name << ": " << std::setw(12) << (found ? "Found" : "Not found")
        << std::setw(10) << " | Time: " << duration.count() << " μs" << std::endl;
}

std::string read_file_to_string(const std::string& file_path) {
    std::ifstream file(file_path);
    if (!file.is_open()) {
        throw std::runtime_error("无法打开文件: " + file_path);
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    return buffer.str();
}
int main() {
#ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
    //std::cout.imbue(std::locale("en_US.utf8"));
#endif // _WIN32

    std::vector<std::string> patterns;
    std::string text;

    if constexpr (false) // 随机生成测试文本
    {
        std::string temp(10000, 'a');
        temp.replace(5000, 5, "hello"); // 在中间插入模式
        text = std::move(temp);

        // 不同大小的模式串
        patterns = { "a", "hello", "hello world", "xyzabc123" };
    }
    else
    {
        std::string file_path;

        if constexpr (true) {
            patterns = {
        "Flicker",
        "verification-code",
        "这是一封自动发送的邮件",
        "Re11aXCN",
        "帮助中心",
        "VERIFICATION_TYPE",
        "VERIFICATION_CODE",
        "footer-links",
        "copy-notification"
            };
            file_path = "E:\\Flicker\\Flicker\\Global\\Smtp\\template.html";
        }
        else {
            patterns = {
                "所示，保存编辑后的",
                R"#(所示，保存编辑后的</w:t>)#",
                R"#(所示，保存编辑后的</w:t></w:r>)#",
                R"#(所示，保存编辑后的</w:t></w:r><w:r w:rsidRPr)#",
                R"#(所示，保存编辑后的</w:t></w:r><w:r w:rsidRPr="00D97FE1">)#",
                R"#(5-9</w:t></w:r><w:r w:rsidRPr="00D97FE1"><w:rPr><w:rFonts w:ascii="Times New Roman" w:hAnsi="Times New Roman" w:hint="eastAsia"/><w:color w:val="000000"/><w:szCs w:val="21"/></w:rPr><w:t>，给出)#",
                R"#(</w:rPr><w:t>转换器用例图</w:t></w:r><w:r w:rsidR="00FF693C")#"
            };
            file_path = "C:\\Users\\Re11a\\Desktop\\document.xml";
        }
        try {
            text = read_file_to_string(file_path);
            std::cout << "成功读取文件，文件大小: " << text.size() << " 字节" << std::endl;
        }
        catch (const std::exception& e) {
            std::cerr << "错误: " << e.what() << std::endl;
            return 1;
        }

    }

    for (const auto& pattern : patterns) {
        std::cout << "\nTesting pattern: '" << pattern << "' (length: "
            << pattern.size() << ")\n";
        std::cout << "==========================================\n";

        // inner string_find
        test_searcher("string_find", [&]() {
            auto result = text.find(pattern, 0);
            return result != std::string::npos;
            });

        // 暴力搜索
        test_searcher("brute_force_search", [&]() {
            auto result = brute_force_search(text.begin(), text.end(), pattern.begin(), pattern.end());
            return result != text.end();
            });

        // default_searcher
        test_searcher("default_searcher", [&]() {
            auto searcher = std::default_searcher(pattern.begin(), pattern.end());
            auto result = search(text.begin(), text.end(), searcher);
            return result != text.end();
            });

        // boyer_moore_searcher
        test_searcher("boyer_moore_searcher", [&]() {
            try {
                auto searcher = std::boyer_moore_searcher(
                    pattern.begin(), pattern.end());
                auto result = search(text.begin(), text.end(), searcher);
                return result != text.end();
            }
            catch (const std::exception& e) {
                std::cerr << "Exception: " << e.what() << std::endl;
                return false;
            }
            });

        // boyer_moore_horspool_searcher
        test_searcher("boyer_moore_horspool_searcher", [&]() {
            try {
                auto searcher = std::boyer_moore_horspool_searcher(
                    pattern.begin(), pattern.end());
                auto result = search(text.begin(), text.end(), searcher);
                return result != text.end();
            }
            catch (const std::exception& e) {
                std::cerr << "Exception: " << e.what() << std::endl;
                return false;
            }
            });

        //// kmp_searcher
        //test_searcher("kmp_searcher", [&]() {
        //    try {
        //        auto searcher = std::kmp_searcher(
        //            pattern.begin(), pattern.end());
        //        auto result = search(text.begin(), text.end(), searcher);
        //        return result != text.end();
        //    }
        //    catch (const std::exception& e) {
        //        std::cerr << "Exception: " << e.what() << std::endl;
        //        return false;
        //    }
        //    });

        //// sunday_searcher
        //test_searcher("sunday_searcher", [&]() {
        //    try {
        //        auto searcher = std::sunday_searcher(
        //            pattern.begin(), pattern.end());
        //        auto result = search(text.begin(), text.end(), searcher);
        //        return result != text.end();
        //    }
        //    catch (const std::exception& e) {
        //        std::cerr << "Exception: " << e.what() << std::endl;
        //        return false;
        //    }
        //    });

        //// rabin_karp_searcher
        //test_searcher("rabin_karp_searcher", [&]() {
        //    try {
        //        auto searcher = std::rabin_karp_searcher(
        //            pattern.begin(), pattern.end());
        //        auto result = search(text.begin(), text.end(), searcher);
        //        return result != text.end();
        //    }
        //    catch (const std::exception& e) {
        //        std::cerr << "Exception: " << e.what() << std::endl;
        //        return false;
        //    }
        //    });
    }
    return 0;
}


//RELEASE 模式

// 测试 template.html

/*
成功读取文件，文件大小: 13660 字节

Testing pattern: 'Flicker' (length: 7)
==========================================
string_find                     : Found        | Time:  0 μs
brute_force_search              : Found        | Time:  0 μs
default_searcher                : Found        | Time:  0 μs
boyer_moore_searcher            : Found        | Time:  15 μs
boyer_moore_horspool_searcher   : Found        | Time:  1 μs
kmp_searcher                    : Found        | Time:  0 μs
sunday_searcher                 : Found        | Time:  0 μs
rabin_karp_searcher             : Found        | Time:  9 μs

Testing pattern: 'verification-code' (length: 17)
==========================================
string_find                     : Found        | Time:  0 μs
brute_force_search              : Found        | Time:  2 μs
default_searcher                : Found        | Time:  0 μs
boyer_moore_searcher            : Found        | Time:  3 μs
boyer_moore_horspool_searcher   : Found        | Time:  2 μs
kmp_searcher                    : Found        | Time:  6 μs
sunday_searcher                 : Found        | Time:  1 μs
rabin_karp_searcher             : Found        | Time:  22 μs

Testing pattern: '这是一封自动发送的邮件' (length: 33)
==========================================
string_find                     : Found        | Time:  1 μs
brute_force_search              : Found        | Time:  7 μs
default_searcher                : Found        | Time:  1 μs
boyer_moore_searcher            : Found        | Time:  4 μs
boyer_moore_horspool_searcher   : Found        | Time:  2 μs
kmp_searcher                    : Found        | Time:  11 μs
sunday_searcher                 : Found        | Time:  1 μs
rabin_karp_searcher             : Found        | Time:  67 μs

Testing pattern: 'Re11aXCN' (length: 8)
==========================================
string_find                     : Found        | Time:  3 μs
brute_force_search              : Found        | Time:  7 μs
default_searcher                : Found        | Time:  1 μs
boyer_moore_searcher            : Found        | Time:  7 μs
boyer_moore_horspool_searcher   : Found        | Time:  5 μs
kmp_searcher                    : Found        | Time:  11 μs
sunday_searcher                 : Found        | Time:  4 μs
rabin_karp_searcher             : Found        | Time:  68 μs

Testing pattern: '帮助中心' (length: 12)
==========================================
string_find                     : Found        | Time:  2 μs
brute_force_search              : Found        | Time:  7 μs
default_searcher                : Found        | Time:  1 μs
boyer_moore_searcher            : Found        | Time:  5 μs
boyer_moore_horspool_searcher   : Found        | Time:  5 μs
kmp_searcher                    : Found        | Time:  11 μs
sunday_searcher                 : Found        | Time:  3 μs
rabin_karp_searcher             : Found        | Time:  63 μs

Testing pattern: 'VERIFICATION_TYPE' (length: 17)
==========================================
string_find                     : Found        | Time:  1 μs
brute_force_search              : Found        | Time:  6 μs
default_searcher                : Found        | Time:  1 μs
boyer_moore_searcher            : Found        | Time:  4 μs
boyer_moore_horspool_searcher   : Found        | Time:  4 μs
kmp_searcher                    : Found        | Time:  8 μs
sunday_searcher                 : Found        | Time:  2 μs
rabin_karp_searcher             : Found        | Time:  54 μs

Testing pattern: 'VERIFICATION_CODE' (length: 17)
==========================================
string_find                     : Found        | Time:  3 μs
brute_force_search              : Found        | Time:  6 μs
default_searcher                : Found        | Time:  1 μs
boyer_moore_searcher            : Found        | Time:  4 μs
boyer_moore_horspool_searcher   : Found        | Time:  2 μs
kmp_searcher                    : Found        | Time:  8 μs
sunday_searcher                 : Found        | Time:  2 μs
rabin_karp_searcher             : Found        | Time:  56 μs

Testing pattern: 'footer-links' (length: 12)
==========================================
string_find                     : Found        | Time:  1 μs
brute_force_search              : Found        | Time:  5 μs
default_searcher                : Found        | Time:  1 μs
boyer_moore_searcher            : Found        | Time:  4 μs
boyer_moore_horspool_searcher   : Found        | Time:  3 μs
kmp_searcher                    : Found        | Time:  7 μs
sunday_searcher                 : Found        | Time:  2 μs
rabin_karp_searcher             : Found        | Time:  39 μs

Testing pattern: 'copy-notification' (length: 17)
==========================================
string_find                     : Found        | Time:  1 μs
brute_force_search              : Found        | Time:  6 μs
default_searcher                : Found        | Time:  1 μs
boyer_moore_searcher            : Found        | Time:  4 μs
boyer_moore_horspool_searcher   : Found        | Time:  3 μs
kmp_searcher                    : Found        | Time:  9 μs
sunday_searcher                 : Found        | Time:  2 μs
rabin_karp_searcher             : Found        | Time:  43 μs
*/

// 测试 毕业设计论文，docx约4万字，提取document.xml进行测试
/*
成功读取文件，文件大小: 2604643 字节

Testing pattern: '所示，保存编辑后的' (length: 27)
==========================================
string_find                     : Found        | Time:  338 μs
brute_force_search              : Found        | Time:  1679 μs
default_searcher                : Found        | Time:  318 μs
boyer_moore_searcher            : Found        | Time:  338 μs
boyer_moore_horspool_searcher   : Found        | Time:  329 μs
kmp_searcher                    : Found        | Time:  2263 μs
sunday_searcher                 : Found        | Time:  349 μs
rabin_karp_searcher             : Found        | Time:  14951 μs

Testing pattern: '所示，保存编辑后的</w:t>' (length: 33)
==========================================
string_find                     : Found        | Time:  315 μs
brute_force_search              : Found        | Time:  1656 μs
default_searcher                : Found        | Time:  318 μs
boyer_moore_searcher            : Found        | Time:  398 μs
boyer_moore_horspool_searcher   : Found        | Time:  440 μs
kmp_searcher                    : Found        | Time:  2327 μs
sunday_searcher                 : Found        | Time:  412 μs
rabin_karp_searcher             : Found        | Time:  14946 μs

Testing pattern: '所示，保存编辑后的</w:t></w:r>' (length: 39)
==========================================
string_find                     : Found        | Time:  311 μs
brute_force_search              : Found        | Time:  1645 μs
default_searcher                : Found        | Time:  297 μs
boyer_moore_searcher            : Found        | Time:  402 μs
boyer_moore_horspool_searcher   : Found        | Time:  429 μs
kmp_searcher                    : Found        | Time:  2588 μs
sunday_searcher                 : Found        | Time:  397 μs
rabin_karp_searcher             : Found        | Time:  15061 μs

Testing pattern: '所示，保存编辑后的</w:t></w:r><w:r w:rsidRPr' (length: 53)
==========================================
string_find                     : Found        | Time:  305 μs
brute_force_search              : Found        | Time:  1616 μs
default_searcher                : Found        | Time:  301 μs
boyer_moore_searcher            : Found        | Time:  426 μs
boyer_moore_horspool_searcher   : Found        | Time:  393 μs
kmp_searcher                    : Found        | Time:  2256 μs
sunday_searcher                 : Found        | Time:  338 μs
rabin_karp_searcher             : Found        | Time:  14535 μs

Testing pattern: '所示，保存编辑后的</w:t></w:r><w:r w:rsidRPr="00D97FE1">' (length: 65)
==========================================
string_find                     : Found        | Time:  345 μs
brute_force_search              : Found        | Time:  1616 μs
default_searcher                : Found        | Time:  310 μs
boyer_moore_searcher            : Found        | Time:  472 μs
boyer_moore_horspool_searcher   : Found        | Time:  423 μs
kmp_searcher                    : Found        | Time:  2408 μs
sunday_searcher                 : Found        | Time:  376 μs
rabin_karp_searcher             : Found        | Time:  14879 μs

Testing pattern: '5-9</w:t></w:r><w:r w:rsidRPr="00D97FE1"><w:rPr><w:rFonts w:ascii="Times New Roman" w:hAnsi="Times New Roman" w:hint="eastAsia"/><w:color w:val="000000"/><w:szCs w:val="21"/></w:rPr><w:t>，给出' (length: 196)
==========================================
string_find                     : Found        | Time:  206 μs
brute_force_search              : Found        | Time:  962 μs
default_searcher                : Found        | Time:  266 μs
boyer_moore_searcher            : Found        | Time:  200 μs
boyer_moore_horspool_searcher   : Found        | Time:  213 μs
kmp_searcher                    : Found        | Time:  1365 μs
sunday_searcher                 : Found        | Time:  196 μs
rabin_karp_searcher             : Found        | Time:  8710 μs

Testing pattern: '</w:rPr><w:t>转换器用例图</w:t></w:r><w:r w:rsidR="00FF693C"' (length: 66)
==========================================
string_find                     : Found        | Time:  296 μs
brute_force_search              : Found        | Time:  1487 μs
default_searcher                : Found        | Time:  339 μs
boyer_moore_searcher            : Found        | Time:  342 μs
boyer_moore_horspool_searcher   : Found        | Time:  305 μs
kmp_searcher                    : Found        | Time:  1724 μs
sunday_searcher                 : Found        | Time:  262 μs
rabin_karp_searcher             : Found        | Time:  8732 μs
*/
```

#### d. 搜索测试的html文件

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flicker - 验证您的注册</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* 重置样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            background: white /*linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c)*/;
            color: #333;
            line-height: 1.6;
            padding: 20px 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .email-container {
            max-width: 800px;
            width: 100%;
            margin: 20px;
            background: #ffffff;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.25);
            position: relative;
            transition: transform 0.3s ease;
        }
        
        .email-container:hover {
            transform: translateY(-5px);
        }
        
        .header {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            padding: 40px 20px 30px;
            text-align: center;
            position: relative;
        }
        
        .logo-container {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            width: 70px;
            height: 70px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .logo {
            color: #6a11cb;
            font-size: 36px;
        }
        
        .app-name {
            color: white;
            font-size: 32px;
            font-weight: 800;
            letter-spacing: 1px;
            margin-bottom: 5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .tagline {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            font-weight: 300;
        }
        
        .content {
            padding: 50px 30px 40px;
            text-align: center;
            background: #fff;
        }
        
        .title {
            font-size: 28px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 30px;
            position: relative;
            padding-bottom: 15px;
        }
        
        .title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 4px;
            background: linear-gradient(90deg, #6a11cb, #2575fc);
            border-radius: 2px;
        }
        
        .text {
            font-size: 17px;
            color: #4a5568;
            margin-bottom: 25px;
            line-height: 1.7;
        }
        
        .verification-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px 0;
        }
        
        .verification-code {
            background: #f8f9fc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 25px 40px;
            font-size: 40px;
            font-weight: 800;
            color: #3182ce;
            letter-spacing: 8px;
            display: inline-block;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            position: relative;
            transition: all 0.3s ease;
        }
        
        .verification-code:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        }
        
        .copy-btn {
            display: inline-flex;
            align-items: center;
            background: #3182ce;
            color: white;
            text-decoration: none;
            padding: 16px 40px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(49, 130, 206, 0.4);
            cursor: pointer;
            border: none;
            outline: none;
        }
        
        .copy-btn:hover {
            background: #2b6cb0;
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(49, 130, 206, 0.5);
        }
        
        .copy-btn:active {
            transform: translateY(1px);
        }
        
        .copy-btn i {
            margin-right: 12px;
            font-size: 20px;
        }
        
        .note {
            background: #f0f9ff;
            border-left: 4px solid #3182ce;
            padding: 20px;
            text-align: left;
            margin: 40px 0 30px;
            border-radius: 0 8px 8px 0;
            font-size: 15px;
        }
        
        .note-title {
            color: #2d3748;
            font-weight: 700;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
        }
        
        .note-title i {
            color: #3182ce;
            margin-right: 10px;
            font-size: 20px;
        }
        
        .note ul {
            padding-left: 30px;
        }
        
        .note li {
            margin-bottom: 10px;
            color: #4a5568;
        }
        
        .support {
            font-size: 16px;
            color: #4a5568;
            margin-top: 40px;
        }
        
        .support a {
            color: #3182ce;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .support a:hover {
            text-decoration: underline;
            color: #2b6cb0;
        }
        
        .footer {
            background: #f7fafc;
            padding: 30px 20px;
            text-align: center;
            color: #718096;
            font-size: 14px;
            border-top: 1px solid #e2e8f0;
        }
        
        .footer-links {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .footer-links a {
            color: #4a5568;
            text-decoration: none;
            margin: 0 15px;
            transition: color 0.2s;
            display: inline-block;
            padding: 5px 0;
        }
        
        .footer-links a:hover {
            color: #3182ce;
            text-decoration: underline;
        }
        
        .address {
            margin-top: 20px;
            line-height: 1.6;
        }
        
        .automated-note {
            font-size: 13px;
            color: #a0aec0;
            margin-top: 25px;
            font-style: italic;
        }
        
        .copy-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: rgba(49, 130, 206, 0.95);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-weight: 600;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            transition: transform 0.4s ease;
            z-index: 1000;
        }
        
        .copy-notification.show {
            transform: translateX(-50%) translateY(0);
        }
        
        @media (max-width: 620px) {
            .email-container {
                margin: 10px;
            }
            
            .content {
                padding: 40px 20px;
            }
            
            .verification-code {
                font-size: 30px;
                padding: 20px 30px;
                letter-spacing: 6px;
            }
            
            .title {
                font-size: 24px;
            }
            
            .copy-btn {
                padding: 14px 30px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- 复制成功通知 -->
    <div class="copy-notification" id="copyNotification">
        <i class="fas fa-check-circle"></i> 验证码已复制到剪贴板！
    </div>
    
    <div class="email-container">
        <div class="header">
            <div class="logo-container">
                <div class="logo">
                    <i class="fas fa-bolt"></i>
                </div>
            </div>
            <h1 class="app-name">Flicker</h1>
            <p class="tagline">即时通讯，连接世界</p>
        </div>
        
        <div class="content">
            <h2 class="title">验证您的{{VERIFICATION_TYPE}}</h2>
            <p class="text">感谢您{{VERIFICATION_TYPE}}Flicker！为完成{{VERIFICATION_TYPE}}，请复制下方验证码并粘贴到{{VERIFICATION_TYPE}}页面：</p>
            
            <div class="verification-container">
				<div class="verification-code" id="verificationCode">{{VERIFICATION_CODE}}</div>
                
                <button class="copy-btn" id="copyButton">
                    <i class="fas fa-copy"></i> 复制验证码
                </button>
            </div>
            
            <div class="note">
                <div class="note-title">
                    <i class="fas fa-info-circle"></i> 重要提示：
                </div>
                <ul>
                    <li>此验证码将在 <strong>5分钟</strong> 后失效</li>
                    <li>请勿将此代码分享给任何人</li>
                    <li>如果您没有请求此验证码，请忽略此邮件</li>
                    <li>复制后请尽快在{{VERIFICATION_TYPE}}页面完成验证</li>
                </ul>
            </div>
            
            <p class="support">
                如有任何问题，请随时回复此邮件或访问我们的
                <a href="#">帮助中心</a>。
            </p>
        </div>
        
        <div class="footer">
            <div class="footer-links">
                <a href="#">帮助中心</a>
                <a href="#">隐私政策</a>
                <a href="#">服务条款</a>
                <a href="#">联系我们</a>
            </div>
            
             <div class="address">
				Re11aXCN <br>
				https://github.com/Re11aXCN<br>
				CN
             </div>
            
             <p class="automated-note">
                 这是一封自动发送的邮件。如果您未进行{{VERIFICATION_TYPE}}操作，请忽略此邮件。
             </p>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButton = document.getElementById('copyButton');
            const verificationCode = document.getElementById('verificationCode');
            const notification = document.getElementById('copyNotification');
            
            copyButton.addEventListener('click', function() {
                // 获取验证码文本
                const code = verificationCode.innerText.trim();
                
                // 使用现代剪贴板API
                navigator.clipboard.writeText(code).then(() => {
                    // 显示复制成功通知
                    notification.classList.add('show');
                    
                    // 更新按钮状态
                    copyButton.innerHTML = '<i class="fas fa-check"></i> 已复制！';
                    copyButton.style.background = '#10b981';
                    
                    // 3秒后恢复按钮状态
                    setTimeout(() => {
                        copyButton.innerHTML = '<i class="fas fa-copy"></i> 复制验证码';
                        copyButton.style.background = '#3182ce';
                        notification.classList.remove('show');
                    }, 3000);
                }).catch(err => {
                    // 备用方法（适用于旧浏览器）
                    const textArea = document.createElement('textarea');
                    textArea.value = code;
                    document.body.appendChild(textArea);
                    textArea.select();
                    
                    try {
                        document.execCommand('copy');
                        
                        // 显示复制成功通知
                        notification.classList.add('show');
                        
                        // 更新按钮状态
                        copyButton.innerHTML = '<i class="fas fa-check"></i> 已复制！';
                        copyButton.style.background = '#10b981';
                        
                        // 3秒后恢复按钮状态
                        setTimeout(() => {
                            copyButton.innerHTML = '<i class="fas fa-copy"></i> 复制验证码';
                            copyButton.style.background = '#3182ce';
                            notification.classList.remove('show');
                        }, 3000);
                    } catch (err) {
                        alert('无法复制验证码，请手动复制: ' + code);
                    }
                    
                    document.body.removeChild(textArea);
                });
            });
        });
    </script>
</body>
</html>
```



#### e. 搜索器总结

根据性能测试结果和分析，可以得出以下结论：

1. **模式串长度的影响**
   - 超短模式串（<5字符）：暴力搜索和默认搜索器表现相当
   - 短到中等模式串（5-15字符）：Sunday算法和Boyer-Moore-Horspool表现优异
   - 长模式串（>15字符）：Boyer-Moore算法优势明显
2. **算法选择建议**
   - **默认选择**：`std::string::find` 或 `std::default_searcher`，编译器进行了深度优化
   - **通用需求**：Sunday算法综合表现最佳，预处理开销低且搜索效率高
   - **特定场景**：
     - 需要最坏情况保证：KMP算法
     - 长模式串搜索：Boyer-Moore算法
     - 多模式搜索：考虑Rabin-Karp（但需要优化当前实现）
3. **性能关键发现**
   - 标准库实现的`default_searcher`和`string::find`经过高度优化，在大多数场景下都是最佳选择
   - Sunday算法在自定义算法中表现最为出色，综合性能优异
   - 当前Rabin-Karp实现存在性能问题，需要进一步优化哈希函数和冲突处理
4. **实践建议**
   - 优先使用标准库提供的搜索功能
   - 只有在特定性能需求且经过充分测试后，才考虑自定义搜索算法
   - 对于超长文本或特殊搜索需求，可以考虑基于算法特性选择专用搜索器
5. **编译器优化影响**
   - 测试发现`std::default_searcher`在不同编译器下可能有不同实现
   - MSVC的实现通常基于高效的双向比较算法，并针对不同模式串长度进行优化
   - 使用`std::search`时，编译器会根据迭代器类型和模式大小选择最优算法

### (3) std::invoke/std::invoke_r/[`显式对象参数特性(C++23)`](https://open-std.org/JTC1/SC22/WG21/docs/papers/2021/p0847r7.html#recursive-lambdas)

#### a. 核心概念：`INVOKE` 机制

在深入 `std::invoke` 之前，必须理解 C++ 标准中定义的 **`INVOKE`** 机制。它不是一个具体的函数，而是一个概念性的操作，规定了如何用一组参数调用一个*可调用对象 (Callable Object)*。`std::invoke` 就是这个机制的标准库实现。

`INVOKE(f, arg1, arg2, ..., argN)` 的操作定义如下：

1.  **如果 `f` 是类 `T` 的成员函数指针：**
    *   那么调用它时，第一个参数必须是一个类对象（或对象的指针/引用）。
    *   调用形式为：`(arg1.*f)(arg2, ..., argN)`，如果 `arg1` 是 `T` 的对象、引用或派生类对象。
    *   或者 `(arg1->*f)(arg2, ..., argN)`，如果 `arg1` 是 `T` 的指针（如 `T*`, `std::unique_ptr<T>`, `std::shared_ptr<T>`）。

2.  **如果 `f` 是类 `T` 的数据成员指针：**
    *   那么调用它时，只有一个参数，即类对象。
    *   调用形式为：`arg1.*f` 或 `arg1->*f`。

3.  **其他所有情况（普通函数、函数对象、lambda 等）：**
    *   直接调用：`f(arg1, arg2, ..., argN)`。

**`std::invoke` 解决了什么问题？**
它提供了一个**统一的、泛型的调用语法**。无论你要**调用的是普通函数、成员函数、还是数据成员**，你都可以用 `std::invoke(f, args...)` 这一个语法来完成。这在编写模板代码时极其有用，因为模板作者无需关心 `f` 的具体类型，只需知道它是可调用的即可。

---

#### b. `std::invoke` 详解

* 函数原型

```cpp
template< class F, class... Args >
std::invoke_result_t<F, Args...> invoke( F&& f, Args&&... args ) noexcept(/* see below */);
```

* 使用示例

```cpp
#include <iostream>
#include <functional>
#include <memory>

// 1. 普通全局函数
void global_func(int x, const std::string& s) {
    std::cout << "Global function: " << x << ", " << s << std::endl;
}

// 2. 函数对象（重载了 operator() 的类）
struct Functor {
    void operator()(double d) const {
        std::cout << "Functor: " << d << std::endl;
    }
    int data = 100;
};

struct MyClass {
    // 3. 成员函数
    void member_func(int value) {
        std::cout << "Member function: " << value << ", data: " << data << std::endl;
    }
    // 4. const 成员函数
    void const_member_func(int value) const {
        std::cout << "Const Member function: " << value << std::endl;
    }
    // 5. 静态成员函数
    static void static_func(const std::string& s) {
        std::cout << "Static function: " << s << std::endl;
    }

    // 6. C++23 显式对象参数成员函数
    void explicit_object_func(this MyClass& self, int value) {
        std::cout << "Explicit object function: " << value << ", data: " << self.data << std::endl;
    }

    // 7. C++23 显式对象参数 const 成员函数
    void explicit_object_const_func(this const MyClass& self, int value) {
        std::cout << "Explicit object const function: " << value << ", data: " << self.data << std::endl;
    }

    int data = 42;
};

int main() {
    MyClass obj;
    auto lambda = [](int a, int b) { return a + b; };

    std::cout << "=== Using std::invoke ===\n";

    // --- 使用 std::invoke 调用各种对象 ---

    // 1. 调用普通函数
    std::invoke(&global_func, 10, "Hello");

    // 2. 调用函数对象
    Functor func_obj;
    std::invoke(func_obj, 3.14);
    // 也可以调用其数据成员
    std::cout << "Invoking data member: " << std::invoke(&Functor::data, func_obj) << std::endl;

    // 3. 调用成员函数（需要传入一个对象作为第一个参数）
    std::invoke(&MyClass::member_func, obj, 88);
    // 用指针调用成员函数
    std::invoke(&MyClass::member_func, &obj, 99);
    // 用智能指针调用成员函数
    auto ptr = std::make_shared<MyClass>();
    std::invoke(&MyClass::member_func, ptr, 77);

    // 4. 调用 const 成员函数
    const MyClass const_obj;
    std::invoke(&MyClass::const_member_func, const_obj, 66);

    // 5. 调用静态成员函数
    std::invoke(&MyClass::static_func, "World");

    // 6. 调用 lambda 表达式
    int sum = std::invoke(lambda, 5, 6);
    std::cout << "Lambda result: " << sum << std::endl;

    // 7. 调用数据成员指针
    int MyClass::* mem_data_ptr = &MyClass::data;
    std::cout << "Invoke data member ptr on object: " << std::invoke(mem_data_ptr, obj) << std::endl;
    std::cout << "Invoke data member ptr on pointer: " << std::invoke(mem_data_ptr, &obj) << std::endl;

    // 8. 调用 C++23 显式对象参数成员函数
    std::invoke(&MyClass::explicit_object_func, obj, 55);
    std::invoke(&MyClass::explicit_object_const_func, const_obj, 44);

    std::cout << "\n=== Using traditional methods (pre-C++23) ===\n";

    // --- 使用传统方式调用 ---

    // 1. 普通函数直接调用
    global_func(10, "Hello (direct)");

    // 2. 函数对象直接调用
    func_obj(3.14);

    // 3. 成员函数调用
    // 直接通过对象调用
    obj.member_func(88);
    // 通过指针调用
    MyClass* obj_ptr = &obj;
    obj_ptr->member_func(99);
    // 通过智能指针调用
    ptr->member_func(77);

    // 4. const 成员函数调用
    const_obj.const_member_func(66);

    // 5. 静态成员函数调用
    MyClass::static_func("World (direct)");

    // 6. lambda 直接调用
    sum = lambda(5, 6);
    std::cout << "Lambda result (direct): " << sum << std::endl;

    // 7. 数据成员访问
    std::cout << "Data member access: " << obj.data << std::endl;
    std::cout << "Data member access via pointer: " << obj_ptr->data << std::endl;

    // 8. 使用 std::mem_fn 调用成员函数
    auto member_func_fn = std::mem_fn(&MyClass::member_func);
    member_func_fn(obj, 33);

    auto const_member_func_fn = std::mem_fn(&MyClass::const_member_func);
    const_member_func_fn(const_obj, 22);

    // 9. 使用成员指针语法调用
    void (MyClass:: * member_func_ptr)(int) = &MyClass::member_func;
    (obj.*member_func_ptr)(11);
    (obj_ptr->*member_func_ptr)(12);

    // 10. 使用成员指针语法访问数据成员
    std::cout << "Data member pointer access: " << obj.*mem_data_ptr << std::endl;
    std::cout << "Data member pointer access via pointer: " << obj_ptr->*mem_data_ptr << std::endl;

    std::cout << "\n=== Using C++23 explicit object parameter ===\n";

    // --- 使用 C++23 显式对象参数调用 ---

    // 1. 直接调用
    obj.explicit_object_func(55);
    const_obj.explicit_object_const_func(44);

    // 2. 使用成员指针语法调用
    auto explicit_object_func_ptr = &MyClass::explicit_object_func;
    explicit_object_func_ptr(obj, 33);

    // 3. 使用 std::invoke 调用（已在上方展示）

    return 0;
}
```

---

#### c. `std::invoke_r` 详解 (C++23)

* 函数原型

```cpp
template< class R, class F, class... Args >
constexpr R invoke_r( F&& f, Args&&... args ) noexcept(/* see below */);
```
`std::invoke_r` 在 `std::invoke` 的基础上增加了一个模板参数 `R`，用于**显式指定返回类型**。它会执行 `INVOKE` 操作，然后将其结果**静态转换**为类型 `R`。

这在你需要精确控制返回类型时非常有用，例如避免不必要的隐式转换，或者在模板中统一返回类型。

* 使用示例

```cpp
#include <functional>
#include <iostream>

double returns_double() {
    return 3.14159;
}

int main() {
    // 使用 invoke：返回类型是 double
    auto d = std::invoke(returns_double);
    std::cout << "invoke result (double): " << d << std::endl;

    // 使用 invoke_r：将 double 结果静态转换为 int
    int i = std::invoke_r<int>(returns_double);
    std::cout << "invoke_r<int> result (int): " << i << std::endl; // 输出 3

    // 另一个例子：将返回的 int 转换为 void（丢弃返回值）
    std::invoke_r<void>([] { return 42; }); // 调用 lambda 但忽略其返回值

    // 在模板中确保返回类型非常有用
    struct Foo { short operator()() { return 123; } };
    Foo f;

    // 确保调用 f() 并返回 long 类型
    long result = std::invoke_r<long>(f);
    std::cout << "invoke_r<long> result: " << result << std::endl;

    return 0;
}
```

---

#### d. 与 `std::bind` 和 Lambda 的区别

这是一个非常重要的概念辨析。

| 特性         | `std::invoke`                                  | `std::bind`                                                  | Lambda                                                       |
| :----------- | :--------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **目的**     | **立即执行**一个调用。提供一个统一的调用语法。 | **创建一個新的可调用对象**，用于**延迟调用**和**参数绑定**。 | **定义一个匿名函数对象**，捕获上下文，用于延迟调用和自定义行为。 |
| **返回值**   | 返回被调用对象 `f` 的执行结果。                | 返回一个特殊的**函数对象**，调用这个对象才会执行原函数。     | 返回一个**匿名函数对象**，调用这个对象会执行其函数体。       |
| **核心作用** | **调用**。是调用操作的抽象。                   | **绑定和柯里化**。是函数参数的抽象。                         | **定义行为**和**捕获状态**。是函数本身的抽象。               |
| **使用场景** | 泛型编程中，统一调用语法。转发调用操作。       | 将多参数函数绑定为少参数函数；调整参数顺序。                 | 需要内联定义简单操作；需要捕获局部变量。                     |

**关系与协作：**
*   `std::invoke` 是“最终执行那一步”的通用工具。
*   `std::bind` 和 Lambda 都可以生成一个**可调用对象**，而这个生成的对象最终可以被 `std::invoke` 调用。
*   在现代 C++ 中，**Lambda 通常比 `std::bind` 更受欢迎**，因为其语法更清晰，更容易内联优化，并且能更灵活地捕获变量。

**示例对比：**

```cpp
#include <functional>
#include <iostream>

void print_sum(int a, int b) {
    std::cout << a + b << std::endl;
}

int main() {
    int x = 10, y = 20;

    // 目标：创建一个可调用对象，它调用 print_sum 时第一个参数固定为 x

    // 1. 使用 std::bind (C++11)
    auto bind_fn = std::bind(print_sum, x, std::placeholders::_1);
    // 现在调用 bind_fn(y) 等价于 print_sum(x, y)
    std::invoke(bind_fn, y); // 输出 30
    // 注意：bind_fn 本身就是一个可调用对象，可以被 invoke

    // 2. 使用 Lambda (更现代，更清晰)
    auto lambda_fn = [x](int b) { print_sum(x, b); };
    std::invoke(lambda_fn, y); // 输出 30

    // 3. 直接使用 std::invoke
    // 这里无法实现“延迟调用”和“部分绑定”，只能立即执行。
    std::invoke(print_sum, x, y); // 输出 30，但这是立即执行的。

    return 0;
}
```

**总结：** `invoke` 是“执行”，`bind` 和 Lambda 是“准备要执行的东西”。它们在不同层面上解决问题。

---

#### e. 典型应用场景

1.  **泛型库和模板元编程**：这是 `std::invoke` 最重要的用途。标准库中的 `std::thread`, `std::async`, `std::bind` 等，其内部实现都需要一种统一的方式来调用用户传入的可调用对象。
    ```cpp
    template<typename F, typename... Args>
    auto my_async_launcher(F&& func, Args&&... args) {
        // ... 做一些准备工作，比如创建线程
        // 然后用统一的方式调用函数
        return std::invoke(std::forward<F>(func), std::forward<Args>(args)...);
    }
    ```

2.  **实现 `std::visit`  for `std::variant`**：`visit` 的实现需要根据variant当前存储的类型，调用对应的可调用对象，这完美契合 `std::invoke` 的用途。

3.  **包装器和装饰器**：如果你想写一个包装函数，在目标函数调用前后添加一些通用逻辑（如日志、锁、计时），可以使用 `invoke` 来调用目标函数。
    ```cpp
    template<typename F>
    auto with_logging(F f) {
        return [f](auto&&... args) {
            std::cout << "Calling function..." << std::endl;
            // 使用 invoke 来保证能正确处理所有类型的可调用对象
            auto result = std::invoke(f, std::forward<decltype(args)>(args)...);
            std::cout << "Function returned." << std::endl;
            return result;
        };
    }
    
    // 使用
    auto logged_func = with_logging([](int x) { return x * x; });
    int a = logged_func(5); // 输出日志并计算
    ```

4.  **回调机制**：在事件处理系统中，存储的回调可能是多种形式（函数指针、成员函数指针、lambda），`invoke` 提供了统一的触发方式。

#### 总结

| 工具                | 引入标准 | 核心功能                                                     |
| :------------------ | :------- | :----------------------------------------------------------- |
| **`std::invoke`**   | C++17    | 提供统一的、泛型的调用语法，隐藏普通函数、成员函数等调用方式的差异。 |
| **`std::invoke_r`** | C++23    | 在 `invoke` 基础上，增加显式指定返回类型的功能。             |
| **`std::bind`**     | C++11    | 绑定参数，创建新的可调用对象，用于延迟调用和参数柯里化。     |
| **Lambda**          | C++11    | 内联定义匿名函数对象，可捕获上下文，是现代 C++ 实现回调和行为定制的首选。 |

**简单来说：当你需要编写一个模板，并且这个模板要调用某个未知类型的可调用对象时，`std::invoke` 是你的最佳选择。它提供了类型安全且语法统一的调用方式。**

#### `显示对象参数特性(C++23)`

> [](./关键字和语法糖特性.md)

* 这个特性的添加能够在类内 **调用自身、返回自身**，**明确了this**，同时能够**简化	函数指针式的调用类内成员函数**	见	**`std::invoke`详解的例子**
* **明确了this**指：作为参数，可以是值拷贝，可以是引用，可以是引用const
* 同时也能够应用到lambda表达式中，lambda本身就是一个闭包，匿名的类对象语法糖调用仿函数类似调用函数，所有既然是对象，那么使用显示对象参数特性就能够实现自身的递归调用

递归实现归并排序

```c
 auto merge_sort = []<typename It, typename Compare = std::less<>>(this auto&& self, It first, It last, Compare comp = Compare()) -> void
        {
            if (last - first > 1) {
                auto mid = first + (last - first) / 2;
                self(first, mid, comp);
                self(mid, last, comp);
                std::inplace_merge(first, mid, last, comp);
            }
        };
```



### (4) std::apply

#### a. 函数原型

```cpp
template< class F, class Tuple >
constexpr decltype(auto) apply( F&& f, Tuple&& t );
```

`std::apply` 调用可调用对象 `f`，并将元组 `t` 中的元素解包作为参数传递给 `f`。实际上，它的行为类似于：
```cpp
std::invoke(std::forward<F>(f), std::get<0>(std::forward<Tuple>(t)), std::get<1>(std::forward<Tuple>(t)), ...);
```

#### b. 与 `std::invoke` 的关系

- `std::invoke` 接受分散的参数
- `std::apply` 接受一个包含所有参数的元组

可以将 `std::apply` 看作是将元组展开为参数列表，然后使用 `std::invoke` 进行调用的一个函数。

#### c. 使用示例

```cpp
#include <iostream>
#include <tuple>
#include <functional>

// 普通函数
void print_values(int a, double b, const std::string& c) {
    std::cout << "Values: " << a << ", " << b << ", " << c << std::endl;
}

// 函数对象
struct Multiplier {
    int operator()(int a, int b, int c) const {
        return a * b * c;
    }
};

// 类
class Processor {
public:
    void process(int x, int y) {
        std::cout << "Processing: " << x << " * " << y << " = " << (x * y) << std::endl;
    }
    
    static void static_process(const std::string& msg, int count) {
        for (int i = 0; i < count; ++i) {
            std::cout << "Static: " << msg << std::endl;
        }
    }
};

int main() {
    // 1. 使用普通函数
    auto args1 = std::make_tuple(42, 3.14, "Hello");
    std::apply(print_values, args1);
    
    // 2. 使用函数对象
    Multiplier mult;
    auto args2 = std::make_tuple(2, 3, 4);
    int result = std::apply(mult, args2);
    std::cout << "Multiplication result: " << result << std::endl;
    
    // 3. 使用成员函数
    Processor proc;
    auto args3 = std::make_tuple(5, 6);
    // 注意：需要将对象作为第一个参数
    std::apply(&Processor::process, std::tuple_cat(std::make_tuple(&proc), args3));
    
    // 4. 使用静态成员函数
    auto args4 = std::make_tuple("Test", 3);
    std::apply(&Processor::static_process, args4);
    
    // 5. 使用 lambda
    auto lambda = [](int a, int b, int c) { return a + b + c; };
    auto args5 = std::make_tuple(1, 2, 3);
    int sum = std::apply(lambda, args5);
    std::cout << "Sum: " << sum << std::endl;
    
    return 0;
}
```

#### e. 更简洁的成员函数调用方式

对于成员函数，可以使用 `std::apply` 的另一种形式，将对象和参数放在同一个元组中：

```cpp
// 创建包含对象指针和参数的元组
auto member_args = std::make_tuple(&proc, 5, 6);
std::apply(&Processor::process, member_args);
```

#### d. 实现原理

`std::apply` 的实现通常依赖于模板元编程和索引序列，大致如下：

```cpp
// 辅助实现
template <class F, class Tuple, std::size_t... I>
constexpr decltype(auto) apply_impl(F&& f, Tuple&& t, std::index_sequence<I...>) {
    // 使用 std::invoke 来保证通用调用
    return std::invoke(std::forward<F>(f), std::get<I>(std::forward<Tuple>(t))...);
}

// 主函数
template <class F, class Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& t) {
    return apply_impl(
        std::forward<F>(f),
        std::forward<Tuple>(t),
        std::make_index_sequence<std::tuple_size_v<std::decay_t<Tuple>>>{}
    );
}
```

#### f. 应用场景

1. **参数打包和解包**：当你有一个元组，并且想将其内容作为参数传递给函数时
2. **泛型编程**：在模板中，有时参数被保存在元组中，需要解包调用
3. **函数式编程**：与 `std::bind` 和 lambda 结合，可以实现柯里化等函数式编程技术
4. **从其他函数获取参数元组**：某些函数（如 `std::bind`）返回的参数需要解包使用

```cpp
// 示例：将多个函数应用于同一组参数
template <typename... Funcs, typename... Args>
void apply_all(std::tuple<Funcs...> funcs, std::tuple<Args...> args) {
    // 对每个函数应用参数
    (std::apply(std::get<Funcs>(funcs), args), ...);
}

// 使用
auto funcs = std::make_tuple(
    [](int a, int b) { std::cout << "Sum: " << a + b << std::endl; },
    [](int a, int b) { std::cout << "Product: " << a * b << std::endl; }
);
auto params = std::make_tuple(3, 4);
apply_all(funcs, params);
```

#### 总结

- `std::invoke`：用一组参数调用可调用对象，处理成员指针等特殊情况
- `std::apply`：用元组中的参数调用可调用对象，内部使用 `std::invoke`
- `std::invoke_r`：C++23 中引入，指定返回类型调用可调用对象

它们三者都是调用可调用对象的工具，但适用场景略有不同。`std::apply` 侧重于元组参数的展开，而 `std::invoke` 侧重于统一的调用语法。在实际编程中，它们常常结合使用，为泛型编程提供了强大的工具集。

------



# 二、`<utility>`

## rel_ops 比较运算

`std::rel_ops` 命名空间提供了一种基于用户定义的 `operator==` 和 `operator<` 自动生成其他比较运算符的方法。

```cpp
#include <utility>
#include <iostream>

class MyClass {
public:
    int value;
    
    MyClass(int v) : value(v) {}
    
    bool operator==(const MyClass& other) const {
        return value == other.value;
    }
    
    bool operator<(const MyClass& other) const {
        return value < other.value;
    }
};

int main() {
    using namespace std::rel_ops;
    
    MyClass a(5), b(10);
    
    std::cout << "a == b: " << (a == b) << std::endl;  // 用户定义
    std::cout << "a != b: " << (a != b) << std::endl;  // 自动生成
    std::cout << "a < b: " << (a < b) << std::endl;    // 用户定义
    std::cout << "a > b: " << (a > b) << std::endl;    // 自动生成
    std::cout << "a <= b: " << (a <= b) << std::endl;  // 自动生成
    std::cout << "a >= b: " << (a >= b) << std::endl;  // 自动生成
    
    return 0;
}
```

注意事项

- 在 C++20 中已弃用，因为 C++20 引入了三路比较运算符 `<=>`，可以更简洁地实现所有比较运算符
- 需要显式使用 `using namespace std::rel_ops` 来启用自动生成的运算符

---

## pair 功能

`std::pair` 是一个模板类，用于存储两个可能不同类型的值。

基本用法

```cpp
#include <utility>
#include <iostream>
#include <string>

int main() {
    // 创建 pair 的几种方式
    std::pair<int, std::string> p1(1, "one");
    auto p2 = std::make_pair(2, "two");  // 自动推导类型
    std::pair p3(3, "three");            // C++17 类模板参数推导
    
    // 访问元素
    std::cout << "p1: " << p1.first << ", " << p1.second << std::endl;
    
    // 结构化绑定 (C++17)
    auto [num, str] = p1;
    std::cout << "Structured binding: " << num << ", " << str << std::endl;
    
    // 比较操作
    std::pair<int, std::string> p4(1, "one");
    std::cout << "p1 == p4: " << (p1 == p4) << std::endl;
    
    return 0;
}
```

应用场景

- 函数返回多个值
- 作为 map 的键值对
- 需要将两个相关值组合在一起的情况

---

## tuple 功能

`std::tuple` 是 `std::pair` 的泛化，可以存储任意数量的不同类型的值。

基本用法

```cpp
#include <tuple>
#include <iostream>
#include <string>

int main() {
    // 创建 tuple
    std::tuple<int, std::string, double> t1(1, "hello", 3.14);
    auto t2 = std::make_tuple(2, "world", 2.71);
    std::tuple t3(3, "!", 1.41);  // C++17 类模板参数推导
    
    // 访问元素
    std::cout << "t1: " << std::get<0>(t1) << ", " 
              << std::get<1>(t1) << ", " << std::get<2>(t1) << std::endl;
    
    // 结构化绑定 (C++17)
    auto [a, b, c] = t1;
    std::cout << "Structured binding: " << a << ", " << b << ", " << c << std::endl;
    
    // 连接多个 tuple
    auto t4 = std::tuple_cat(t1, t2);
    
    return 0;
}
```

---

## variant 功能

`std::variant` 是类型安全的联合体，可以持有多种类型中的一种。

基本用法

```cpp
#include <variant>
#include <iostream>
#include <string>

int main() {
    std::variant<int, std::string, double> v;
    
    v = 42;  // 存储 int
    std::cout << "Contains int: " << std::get<int>(v) << std::endl;
    
    v = "hello";  // 存储字符串
    std::cout << "Contains string: " << std::get<std::string>(v) << std::endl;
    
    // 检查当前存储的类型
    if (std::holds_alternative<int>(v)) {
        std::cout << "Variant holds an int" << std::endl;
    } else if (std::holds_alternative<std::string>(v)) {
        std::cout << "Variant holds a string" << std::endl;
    }
    
    // 使用 visit 处理所有可能类型
    std::visit([](auto&& arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, int>) {
            std::cout << "Got int: " << arg << std::endl;
        } else if constexpr (std::is_same_v<T, std::string>) {
            std::cout << "Got string: " << arg << std::endl;
        } else if constexpr (std::is_same_v<T, double>) {
            std::cout << "Got double: " << arg << std::endl;
        }
    }, v);
    
    return 0;
}
```

---

## tie 与 ignore 的使用

`std::tie` 和 `std::ignore` 用于从 tuple 或 pair 中提取值。

基本用法

```cpp
#include <tuple>
#include <iostream>
#include <utility>

std::tuple<int, std::string, double> get_data() {
    return {42, "answer", 3.14};
}

int main() {
    int num;
    std::string str;
    double dbl;
    
    // 使用 tie 提取值
    std::tie(num, str, dbl) = get_data();
    std::cout << "Extracted: " << num << ", " << str << ", " << dbl << std::endl;
    
    // 使用 ignore 忽略某些值
    std::tie(num, std::ignore, dbl) = get_data();
    std::cout << "Extracted with ignore: " << num << ", " << dbl << std::endl;
    
    return 0;
}
```

---

## 结构化绑定 (C++17)

结构化绑定提供了一种更简洁的方式来解包 tuple、pair 和结构体。

与 tie 的对比

```cpp
#include <tuple>
#include <iostream>
#include <utility>

std::tuple<int, std::string, double> get_data() {
    return {42, "answer", 3.14};
}

struct Point {
    int x, y;
};

int main() {
    // 传统方式 (C++11/14)
    int num1;
    std::string str1;
    double dbl1;
    std::tie(num1, str1, dbl1) = get_data();
    
    // 结构化绑定 (C++17)
    auto [num2, str2, dbl2] = get_data();
    
    std::cout << "Traditional: " << num1 << ", " << str1 << ", " << dbl1 << std::endl;
    std::cout << "Structured: " << num2 << ", " << str2 << ", " << dbl2 << std::endl;
    
    // 结构化绑定也适用于结构体
    Point p{10, 20};
    auto [x, y] = p;
    std::cout << "Point: " << x << ", " << y << std::endl;
    
    return 0;
}
```

优势

- 代码更简洁
- 不需要预先声明变量
- 支持引用绑定 (`auto& [a, b] = ...`)

---

## variant 的 monostate

`std::monostate` 是一个空类，用作 `std::variant` 的占位符类型。

使用场景和示例

```cpp
#include <variant>
#include <iostream>
#include <string>

// 一个没有默认构造函数的类
class NoDefault {
public:
    NoDefault(int value) : value(value) {}
    int value;
};

int main() {
    // 如果没有 monostate，这会编译错误，因为 NoDefault 没有默认构造函数
    // std::variant<NoDefault, std::string> v; // 错误!
    
    // 使用 monostate 作为第一个选项，允许 variant 默认构造
    std::variant<std::monostate, NoDefault, std::string> v;
    
    // 默认构造的 variant 包含 monostate
    if (std::holds_alternative<std::monostate>(v)) {
        std::cout << "Variant is empty (monostate)" << std::endl;
    }
    
    // 可以赋值为其他类型
    v = NoDefault(42);
    
    if (std::holds_alternative<NoDefault>(v)) {
        std::cout << "Variant holds NoDefault with value: " 
                  << std::get<NoDefault>(v).value << std::endl;
    }
    
    // 重置为 monostate
    v = std::monostate{};
    
    return 0;
}
```

主要用途

- 作为 variant 的第一个替代项，使 variant 可默认构造
- 表示"空"或"无值"状态
- 处理没有默认构造函数的类型

---

## swap 与 exchange

`std::swap` 和 `std::exchange` 都用于操作对象的值，但有不同用途。

swap 的基本用法

```cpp
#include <utility>
#include <iostream>

int main() {
    int a = 10, b = 20;
    
    std::cout << "Before swap: a = " << a << ", b = " << b << std::endl;
    
    std::swap(a, b);  // 交换两个值
    
    std::cout << "After swap: a = " << a << ", b = " << b << std::endl;
    
    // 自定义类型的 swap
    struct MyData {
        int value;
        std::string name;
        
        // 自定义 swap 函数
        friend void swap(MyData& first, MyData& second) {
            using std::swap;
            swap(first.value, second.value);
            swap(first.name, second.name);
        }
    };
    
    MyData d1{1, "Alice"}, d2{2, "Bob"};
    swap(d1, d2);  // 使用自定义 swap
    
    return 0;
}
```

exchange 的基本用法

```cpp
#include <utility>
#include <iostream>

int main() {
    int value = 10;
    
    std::cout << "Original value: " << value << std::endl;
    
    // 将 value 设置为 20，并返回旧值
    int old_value = std::exchange(value, 20);
    
    std::cout << "New value: " << value << std::endl;
    std::cout << "Old value: " << old_value << std::endl;
    
    // 在移动语义中的应用
    class Resource {
        int* data;
    public:
        Resource() : data(new int[100]) {}
        ~Resource() { delete[] data; }
        
        // 移动构造函数
        Resource(Resource&& other) noexcept 
            : data(std::exchange(other.data, nullptr)) {}
        
        // 移动赋值运算符
        Resource& operator=(Resource&& other) noexcept {
            if (this != &other) {
                delete[] data;
                data = std::exchange(other.data, nullptr);
            }
            return *this;
        }
    };
    
    return 0;
}
```

区别与选择

- `std::swap`：交换两个对象的值
- `std::exchange`：用新值替换对象的当前值，并返回旧值
- 选择：
  - 需要交换两个值时使用 `swap`
  - 需要替换值并获取旧值时使用 `exchange`
  - `exchange` 在实现移动操作时特别有用

---



# 三、`<compare>`比较运算引伸(C++20 三路运算符`<=>`)

`<compare>` 头文件提供了三路比较运算符 `<=>`（俗称"飞船运算符"）的相关支持，包括比较类别、概念和工具函数。

## 1. 核心组件详解

### (1) 比较类别类型

| 类型                    | 描述                       | 可能的值                                     | 适用场景                 |
| ----------------------- | -------------------------- | -------------------------------------------- | ------------------------ |
| `std::partial_ordering` | 部分排序，允许不可比较的值 | `less`, `equivalent`, `greater`, `unordered` | 浮点数、含有NaN的值      |
| `std::weak_ordering`    | 弱排序，等价但不一定相等   | `less`, `equivalent`, `greater`              | 不区分大小写的字符串比较 |
| `std::strong_ordering`  | 强排序，等价意味着相等     | `less`, `equal`, `greater`                   | 整数、区分大小写的字符串 |

### (2) 概念

| 概念                             | 描述                                |
| -------------------------------- | ----------------------------------- |
| `std::three_way_comparable`      | 指定类型支持三路比较运算符 `<=>`    |
| `std::three_way_comparable_with` | 指定两个类型可以使用 `<=>` 进行比较 |

### (3) 工具类和函数

| 名称                                  | 描述                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| `std::common_comparison_category`     | 获取所有给定类型可转换到的最强比较类别                       |
| `std::compare_three_way_result`       | 获取给定类型上 `<=>` 运算符的结果类型                        |
| `std::compare_three_way`              | 实现 `x <= y` 的函数对象                                     |
| `std::strong_order`                   | 执行三向比较并生成 `std::strong_ordering` 类型的结果         |
| `std::weak_order`                     | 执行三向比较并生成 `std::weak_ordering` 类型的结果           |
| `std::partial_order`                  | 执行三路比较并产生 `std::partial_ordering` 类型的结果        |
| `std::compare_strong_order_fallback`  | 即使 `operator<=>` 不可用，也执行三路比较并产生 `std::strong_ordering` |
| `std::compare_weak_order_fallback`    | 即使 `operator<=>` 不可用，也执行三路比较并产生 `std::weak_ordering` |
| `std::compare_partial_order_fallback` | 即使 `operator<=>` 不可用，也执行三向比较并生成 `std::partial_ordering` |

### (4) 比较结果检查函数

| 函数      | 描述                       |
| --------- | -------------------------- |
| `is_eq`   | 检查比较结果是否等于       |
| `is_neq`  | 检查比较结果是否不等于     |
| `is_lt`   | 检查比较结果是否小于       |
| `is_lteq` | 检查比较结果是否小于或等于 |
| `is_gt`   | 检查比较结果是否大于       |
| `is_gteq` | 检查比较结果是否大于或等于 |



## 3. 三路运算符 (`<=>`) 的使用

三路比较运算符是 C++20 引入的一个非常重要的特性。它之所以叫“三路”，是因为它**一次比较就能同时确定两个对象之间的小于、等于和大于三种关系**，并将结果封装在一个对象中返回。

### （1）基本语法

```cpp
auto result = a <=> b;
```

`result` 的类型不是简单的 `bool`，而是一个**比较类别（Comparison Category）** 类型的对象。这个对象可以告诉我们 `a` 和 `b` 的完整关系。

### （2）比较类别（返回值类型）

`a <=> b` 的返回值类型通常是以下三种之一，它们都定义在 `<compare>` 头文件中：

*   **`std::strong_ordering`**：表示“强序”。
    *   含义：如果两个值相等，它们就是不可区分的（例如整数）。`a == b` 必然意味着 `f(a) == f(b)`（任何操作的结果都相同）。
    *   可能的值：`std::strong_ordering::less`、`std::strong_ordering::equal`（等价于 `std::strong_ordering::equivalent`)、`std::strong_ordering::greater`。
*   **`std::weak_ordering`**：表示“弱序”。
    *   含义：**两个值可以等价但不完全相等（例如不区分大小写的字符串比较）**。`a == b` 并不意味着它们完全一样，只是它们在某种比较标准下被视为等价（例如 `"Hello"` 和 `"HELLO"` 在不区分大小写的情况下等价）。
    *   可能的值：`std::weak_ordering::less`、`std::weak_ordering::equivalent`、`std::weak_ordering::greater`。
*   **`std::partial_ordering`**：表示“偏序”。
    *   含义：允许存在不可比较的值（例如浮点数中的 `NaN`）。`NaN <=> 任何数（包括它自己）` 的结果是 `std::partial_ordering::unordered`。
    *   可能的值：`std::partial_ordering::less`、`std::partial_ordering::equivalent`、`std::partial_ordering::greater`、`std::partial_ordering::unordered`。

### （3）如何使用返回值

你很少需要直接与这些类别对象交互。最主要的使用方式是让编译器自动利用它们来生成所有的传统比较运算符（`==`, `!=`, `<`, `<=`, `>, >=`）。

**直接使用 `<=>` 判断结果：**

```cpp
#include <iostream>
#include <compare>

int main() {
    int a = 5, b = 3;
    auto result = a <=> b;

    if (result > 0) {
        std::cout << "a is greater than b\n"; // 输出
    } else if (result < 0) {
        std::cout << "a is less than b\n";
    } else { // (result == 0)
        std::cout << "a is equal to b\n";
    }

    // 或者使用成员函数/常量
    if (result == std::strong_ordering::equal) {
        // ...
    }
}
```

### （4）最大价值：自动生成比较运算符

这是 `<=>` 最重要的用途。如果你为自定义类定义了 `operator<=>`，并且编译器发现缺少某个传统比较运算符（比如 `<`），**编译器会自动为你生成它**，其行为与 `<=>` 保持一致。

**示例：为自定义类启用自动比较**

```cpp
#include <compare>
#include <iostream>

class Point {
public:
    int x;
    int y;

    // 编译器自动生成 ==, !=, <, <=, >, >=
    // 注意：默认生成的是按成员字典序比较
    auto operator<=>(const Point&) const = default;
};

int main() {
    Point p1{1, 2}, p2{1, 3};

    std::cout << (p1 < p2) << std::endl;  // true (p1 < p2)
    std::cout << (p1 > p2) << std::endl;  // false
    std::cout << (p1 == p2) << std::endl; // false
}
```

在上面的例子中，我们只写了一句 `auto operator<=>(const Point&) const = default;`，编译器就为我们生成了全部 6 个关系运算符和 `!=`，极大地减少了重复代码。

**手动实现 `<=>`：**

```cpp
class MyString {
private:
    char* data;
    size_t length;
public:
    // 手动实现三路比较，按字典序比较字符串
    std::strong_ordering operator<=>(const MyString& rhs) const {
        int cmp_result = std::strcmp(data, rhs.data);
        if (cmp_result < 0) return std::strong_ordering::less;
        else if (cmp_result > 0) return std::strong_ordering::greater;
        else return std::strong_ordering::equal;
    }

    // 注意：C++20 中，operator== 通常需要单独定义（或使用 =default）以获得最高效率。
    // 但对于默认的 `=default` operator<=>，编译器会同时生成默认的 operator==。
    bool operator==(const MyString& rhs) const {
        return std::strcmp(data, rhs.data) == 0;
    }
};
```

---

## 4. 与传统运算符 (`==`, `!=`, `>`, `<`, `>=`, `<=`) 的区别

| 特性                   | 传统关系运算符                                       | 三路比较运算符 (`<=>`)                                       |
| :--------------------- | :--------------------------------------------------- | :----------------------------------------------------------- |
| **返回值**             | **`bool`**（`true` 或 `false`）                      | **比较类别对象**（`std::strong_ordering` 等）                |
| **一次调用提供的信息** | **单一关系**。调用 `a < b` 只告诉你是否小于。        | **全部关系**。一次调用即可确定小于、等于或大于。             |
| **主要用途**           | 直接在条件语句中进行特定比较。                       | 1. **直接使用**（较少见）。<br>2. **让编译器自动生成所有传统运算符**（主要用途）。 |
| **代码量**             | 需要为类手动定义多个运算符，代码冗长。               | **极大简化**。通常只需定义 `<=>` 和 `==`（或直接 `=default`），编译器自动生成其余所有。 |
| **引入版本**           | 从 C 语言继承，始终存在。                            | **C++20**                                                    |
| **语义清晰度**         | 实现完整的比较需要多次调用（理论上），可能效率较低。 | 更清晰地表达了“比较”这一整体概念，允许编译器和库进行优化。   |

### 核心区别总结

1.  **返回值不同**：这是最根本的区别。传统运算符返回 `bool` 回答“是/否”，而 `<=>` 返回一个对象回答“是什么关系”。
2.  **目的不同**：传统运算符是**最终使用的工具**，而 `<=>` 在现代 C++ 中更多地是**一个用于生成工具的工厂**。你定义好 `<=>`，它就为你制造出 `==`, `<`, `>` 等所有工具。
3.  **效率与简洁性**：`<=>` 通过**避免代码重复**极大地提高了开发效率，并保证了所有比较运算符行为的一致性。

### 重要注意事项

*   **`operator==` 的优化**：在 C++20 中，即使你定义了 `operator<=>`，也**最好单独定义一个 `operator==`**。因为编译器可以利用这一点进行优化（例如，对于 `std::string`，判断相等可以比按字典序比较更快）。使用 `=default` 时，编译器会生成一个高效的 `operator==`。
*   **一致性**：由 `<=>` 自动生成的所有运算符保证行为逻辑一致，避免了手动实现时可能出现的疏忽和错误。

总之，**三路运算符 (`<=>`) 是现代 C++ 中实现比较操作的首选方式**，它通过委派给编译器来生成代码，使得程序更简洁、更安全、更易维护。而传统的运算符则是你最终在 `if`、`while` 等语句中直接使用的那个布尔条件。



1. **默认比较**：使用 `= default` 可以自动生成比较运算符，但需要确保所有成员都有比较运算符。

2. **比较类别选择**：根据类型的语义选择合适的比较类别：
   - 如果等价意味着相等，使用 `strong_ordering`
   - 如果等价但不一定相等，使用 `weak_ordering`
   - 如果允许不可比较的值，使用 `partial_ordering`

3. **回退机制**：对于没有定义 `<=>` 的类型，可以使用回退比较函数（如 `compare_strong_order_fallback`）。

这个示例展示了 `<compare>` 头文件的核心功能，包括不同的比较类别、概念、工具函数以及如何为自定义类型实现三路比较。

## 5. 完整示例代码

```cpp
#include <compare>
#include <iostream>
#include <string>
#include <vector>
#include <cmath> // for NaN
#include <algorithm> // for sort

// 1. 自定义类实现三路比较
class Point {
public:
    int x, y;
    
    Point(int x, int y) : x(x), y(y) {}
    
    // 实现三路比较运算符
    auto operator<=>(const Point& other) const = default;
    
    // 为了演示，也提供传统的比较运算符
    bool operator==(const Point& other) const = default;
};

// 2. 自定义类实现弱排序（不区分大小写的字符串）
class CaseInsensitiveString {
public:
    std::string value;
    
    CaseInsensitiveString(const std::string& s) : value(s) {}
    
    // 实现弱排序的三路比较
    std::weak_ordering operator<=>(const CaseInsensitiveString& other) const {
        // 转换为小写后比较
        auto to_lower = [](const std::string& s) {
            std::string result;
            for (char c : s) {
                result += std::tolower(c);
            }
            return result;
        };
        
        std::string lower_this = to_lower(value);
        std::string lower_other = to_lower(other.value);
        
        if (lower_this < lower_other) return std::weak_ordering::less;
        if (lower_this > lower_other) return std::weak_ordering::greater;
        return std::weak_ordering::equivalent;
    }
    
    bool operator==(const CaseInsensitiveString& other) const {
        // 转换为小写后比较
        auto to_lower = [](const std::string& s) {
            std::string result;
            for (char c : s) {
                result += std::tolower(c);
            }
            return result;
        };
        
        return to_lower(value) == to_lower(other.value);
    }
};

// 3. 自定义类实现部分排序（支持NaN）
class OptionalDouble {
public:
    double value;
    bool has_value;
    
    OptionalDouble(double v = 0.0) : value(v), has_value(true) {}
    OptionalDouble(std::nullptr_t) : value(0.0), has_value(false) {} // 表示无值
    
    // 实现部分排序的三路比较
    std::partial_ordering operator<=>(const OptionalDouble& other) const {
        // 如果任一操作数无值，则不可比较
        if (!has_value || !other.has_value) {
            return std::partial_ordering::unordered;
        }
        
        // 比较值
        if (std::isnan(value) || std::isnan(other.value)) {
            return std::partial_ordering::unordered;
        }
        
        if (value < other.value) return std::partial_ordering::less;
        if (value > other.value) return std::partial_ordering::greater;
        return std::partial_ordering::equivalent;
    }
    
    bool operator==(const OptionalDouble& other) const {
        // 如果任一操作数无值，则不相等
        if (!has_value || !other.has_value) {
            return false;
        }
        
        // 如果任一值是NaN，则不相等
        if (std::isnan(value) || std::isnan(other.value)) {
            return false;
        }
        
        return value == other.value;
    }
};

// 4. 演示自定义比较函数对象
struct LengthComparator {
    std::strong_ordering operator()(const std::string& a, const std::string& b) const {
        if (a.length() < b.length()) return std::strong_ordering::less;
        if (a.length() > b.length()) return std::strong_ordering::greater;
        return std::strong_ordering::equal;
    }
};

int main() {
    std::cout.setf(std::ios_base::boolalpha);
    std::cout << "=== C++20 <compare> 头文件功能演示 ===\n\n";
    
    // 1. 演示强排序
    std::cout << "1. 强排序示例 (Point类):\n";
    Point p1(1, 2), p2(3, 4), p3(1, 2);
    
    auto result1 = p1 <=> p2;
    auto result2 = p1 <=> p3;
    
    std::cout << "p1 <=> p2: ";
    if (result1 < 0) std::cout << "p1 < p2\n";
    else if (result1 > 0) std::cout << "p1 > p2\n";
    else std::cout << "p1 == p2\n";
    
    std::cout << "p1 <=> p3: ";
    if (result2 < 0) std::cout << "p1 < p3\n";
    else if (result2 > 0) std::cout << "p1 > p3\n";
    else std::cout << "p1 == p3\n";
    
    // 使用比较结果检查函数
    std::cout << "使用比较结果检查函数:\n";
    std::cout << "is_lt(result1): " << std::is_lt(result1) << "\n";
    std::cout << "is_eq(result2): " << std::is_eq(result2) << "\n";
    std::cout << std::endl;
    
    // 2. 演示弱排序
    std::cout << "2. 弱排序示例 (CaseInsensitiveString类):\n";
    CaseInsensitiveString s1("Hello"), s2("HELLO"), s3("World");
    
    auto result3 = s1 <=> s2;
    auto result4 = s1 <=> s3;
    
    std::cout << "s1 <=> s2: ";
    if (result3 < 0) std::cout << "s1 < s2\n";
    else if (result3 > 0) std::cout << "s1 > s2\n";
    else std::cout << "s1 == s2 (等价但不一定相同)\n";
    
    std::cout << "s1 <=> s3: ";
    if (result4 < 0) std::cout << "s1 < s3\n";
    else if (result4 > 0) std::cout << "s1 > s3\n";
    else std::cout << "s1 == s3\n";
    
    std::cout << "s1 == s2: " << (s1 == s2) << "\n";
    std::cout << std::endl;
    
    // 3. 演示部分排序
    std::cout << "3. 部分排序示例 (OptionalDouble类):\n";
    OptionalDouble d1(3.14), d2(2.71), d3(std::numeric_limits<double>::quiet_NaN()), d4(nullptr);
    
    auto result5 = d1 <=> d2;
    auto result6 = d1 <=> d3;
    auto result7 = d4 <=> d3;
    
    std::cout << "d1 <=> d2: ";
    if (result5 < 0) std::cout << "d1 < d2\n";
    else if (result5 > 0) std::cout << "d1 > d2\n";
    else if (std::is_eq(result5)) std::cout << "d1 == d2\n";
    else std::cout << "d1 和 d2 不可比较\n";
    
    std::cout << "d1 <=> d3: ";
    if (result6 < 0) std::cout << "d1 < d3\n";
    else if (result6 > 0) std::cout << "d1 > d3\n";
    else if (std::is_eq(result6)) std::cout << "d1 == d3\n";
    else std::cout << "d1 和 d3 不可比较\n";
    
    std::cout << "d4 <=> d3: ";
    if (result7 < 0) std::cout << "d4 < d3\n";
    else if (result7 > 0) std::cout << "d4 > d3\n";
    else if (std::is_eq(result7)) std::cout << "d4 == d3\n";
    else std::cout << "d4 和 d3 不可比较\n";
    
    std::cout << "d1 == d3: " << (d1 == d3) << "\n";
    std::cout << std::endl;
    
    // 4. 演示 common_comparison_category
    std::cout << "4. common_comparison_category 示例:\n";
    using category1 = std::common_comparison_category_t<std::strong_ordering, std::weak_ordering>;
    std::cout << "strong_ordering 和 weak_ordering 的公共类别: ";
    if constexpr (std::is_same_v<category1, std::strong_ordering>) {
        std::cout << "strong_ordering\n";
    } else if constexpr (std::is_same_v<category1, std::weak_ordering>) {
        std::cout << "weak_ordering\n";
    } else {
        std::cout << "partial_ordering\n";
    }
    
    using category2 = std::common_comparison_category_t<std::strong_ordering, std::partial_ordering>;
    std::cout << "strong_ordering 和 partial_ordering 的公共类别: ";
    if constexpr (std::is_same_v<category2, std::strong_ordering>) {
        std::cout << "strong_ordering\n";
    } else if constexpr (std::is_same_v<category2, std::weak_ordering>) {
        std::cout << "weak_ordering\n";
    } else {
        std::cout << "partial_ordering\n";
    }
    std::cout << std::endl;
    
    // 5. 演示 compare_three_way
    std::cout << "5. compare_three_way 示例:\n";
    std::compare_three_way compare;
    int a = 5, b = 10;
    auto result8 = compare(a, b);
    
    std::cout << "compare(5, 10): ";
    if (result8 < 0) std::cout << "小于\n";
    else if (result8 > 0) std::cout << "大于\n";
    else std::cout << "等于\n";
    std::cout << std::endl;
    
    // 6. 演示自定义比较函数对象
    std::cout << "6. 自定义比较函数对象示例:\n";
    std::vector<std::string> words = {"apple", "banana", "cherry", "date", "elderberry"};
    
    // 使用长度比较器排序
    LengthComparator length_compare;
    std::sort(words.begin(), words.end(), [&](const auto& a, const auto& b) {
        return length_compare(a, b) < 0;
    });
    
    std::cout << "按长度排序的单词: ";
    for (const auto& word : words) {
        std::cout << word << " ";
    }
    std::cout << "\n" << std::endl;
    
    // 7. 演示回退比较函数
    std::cout << "7. 回退比较函数示例:\n";
    
    // 创建一个没有定义 <=> 的类
    class SimpleInt {
    public:
        int value;
        SimpleInt(int v) : value(v) {}
        
        // 只定义 < 和 ==，没有定义 <=>
        bool operator<(const SimpleInt& other) const { return value < other.value; }
        bool operator==(const SimpleInt& other) const { return value == other.value; }
    };
    
    SimpleInt si1(5), si2(10);
    
    // 使用回退比较函数
    auto result9 = std::compare_strong_order_fallback(si1, si2);
    std::cout << "compare_strong_order_fallback(SimpleInt(5), SimpleInt(10)): ";
    if (result9 < 0) std::cout << "小于\n";
    else if (result9 > 0) std::cout << "大于\n";
    else std::cout << "等于\n";
    
    return 0;
}
```

## 6. 使用场景和重要性

1. **简化代码**：三路比较运算符 `<=>` 可以自动生成所有六个比较运算符（`<`, `<=`, `>`, `>=`, `==`, `!=`），减少样板代码。

2. **提供更丰富的比较信息**：传统的比较运算符只返回布尔值，而三路比较返回一个比较类别，提供了更多关于比较关系的信息。

3. **支持不同的排序语义**：
   - 强排序：等价意味着相等（如整数、区分大小写的字符串）
   - 弱排序：等价但不一定相等（如不区分大小写的字符串）
   - 部分排序：允许不可比较的值（如浮点数中的NaN）

4. **提高代码可读性和可维护性**：通过明确指定比较的语义，使代码意图更加清晰。

5. **支持标准库算法**：许多标准库算法（如排序、查找）可以利用三路比较来提高效率和正确性。

# 四、`<source_location>`

## 1. 定义

```c
_STD_BEGIN
_EXPORT_STD struct source_location {
    _NODISCARD static consteval source_location current(const uint_least32_t _Line_ = __builtin_LINE(),
        const uint_least32_t _Column_ = __builtin_COLUMN(), const char* const _File_ = __builtin_FILE(),
#if _USE_DETAILED_FUNCTION_NAME_IN_SOURCE_LOCATION
        const char* const _Function_ = __builtin_FUNCSIG()
#else // ^^^ detailed / basic vvv
        const char* const _Function_ = __builtin_FUNCTION()
#endif // ^^^ basic ^^^
            ) noexcept {
        source_location _Result{};
        _Result._Line     = _Line_;
        _Result._Column   = _Column_;
        _Result._File     = _File_;
        _Result._Function = _Function_;
        return _Result;
    }

    _NODISCARD_CTOR constexpr source_location() noexcept = default;

    _NODISCARD constexpr uint_least32_t line() const noexcept {
        return _Line;
    }
    _NODISCARD constexpr uint_least32_t column() const noexcept {
        return _Column;
    }
    _NODISCARD constexpr const char* file_name() const noexcept {
        return _File;
    }
    _NODISCARD constexpr const char* function_name() const noexcept {
        return _Function;
    }

private:
    uint_least32_t _Line{};
    uint_least32_t _Column{};
    const char* _File     = "";
    const char* _Function = "";
};
_STD_END
```

## 2. 使用示例

```c
#include <iostream>
#include <source_location>

void log(const std::string& message, 
         const std::source_location& location = std::source_location::current()) {
    std::cout << "File: " << location.file_name()
              << "\nFunction: " << location.function_name()
              << "\nLine: " << location.line()
              << "\nColumn: " << location.column()
              << "\nMessage: " << message << "\n\n";
}

int main() {
    log("Hello from main!"); // 自动捕获调用位置信息
    
    // 手动指定位置（较少用）
    constexpr auto loc = std::source_location::current();
    std::cout << "Manual location: " << loc.file_name() << ":" << loc.line() << "\n";
    
    return 0;
}
```

# 五、`<tuple>`、`<any>`、`<variant>`、`<optional>`、`<expected>`

## 1. [`<tuple>` 标准库头文件详解](https://cppreference.cn/w/cpp/header/tuple)

`<tuple>` 头文件提供了 `std::tuple` 类模板，它是一个固定大小的异构值集合，可以包含不同类型的元素。它是 C++11 引入的重要特性，用于处理多个值的组合。

### (1) 基本用法示例

```cpp
#include <iostream>
#include <tuple>
#include <string>
#include <functional>
#include <vector>
#include <algorithm>

using namespace std;

// 示例函数，返回多个值
tuple<int, string, double> getPersonInfo() {
    return make_tuple(30, "John Doe", 175.5);
}

// 示例结构体
struct Person {
    int age;
    string name;
    double height;
    
    // 从tuple转换的构造函数
    Person(const tuple<int, string, double>& info) 
        : age(get<0>(info)), name(get<1>(info)), height(get<2>(info)) {}
    
    // 转换为tuple的转换运算符
    operator tuple<int, string, double>() const {
        return make_tuple(age, name, height);
    }
};

int main() {
    cout << "=== C++ tuple 基本用法示例 ===" << endl << endl;
    
    // 1. 创建tuple
    cout << "1. 创建tuple:" << endl;
    tuple<int, string, double> person1(25, "Alice", 165.2);
    auto person2 = make_tuple(30, "Bob", 180.3); // 使用make_tuple
    tuple person3(35, "Charlie", 175.8); // C++17 类模板参数推导
    
    // 2. 访问tuple元素
    cout << "2. 访问tuple元素:" << endl;
    cout << "Person1: " << get<0>(person1) << ", " 
         << get<1>(person1) << ", " << get<2>(person1) << endl;
    
    // 3. 结构化绑定 (C++17)
    cout << "3. 结构化绑定:" << endl;
    auto [age, name, height] = person2;
    cout << "Person2: " << age << ", " << name << ", " << height << endl;
    
    // 4. 修改tuple元素
    cout << "4. 修改tuple元素:" << endl;
    get<0>(person3) = 36;
    get<1>(person3) = "Charles";
    cout << "修改后的Person3: " << get<0>(person3) << ", " 
         << get<1>(person3) << ", " << get<2>(person3) << endl;
    
    // 5. 比较tuple
    cout << "5. 比较tuple:" << endl;
    auto p1 = make_tuple(25, "Alice");
    auto p2 = make_tuple(30, "Bob");
    cout << "p1 < p2: " << (p1 < p2) << endl; // 按字典序比较
    
    // 6. 使用tie解包tuple
    cout << "6. 使用tie解包tuple:" << endl;
    int a;
    string b;
    double c;
    tie(a, b, c) = getPersonInfo();
    cout << "解包结果: " << a << ", " << b << ", " << c << endl;
    
    // 7. 使用ignore忽略某些元素
    cout << "7. 使用ignore忽略元素:" << endl;
    tie(ignore, b, ignore) = getPersonInfo();
    cout << "只获取名字: " << b << endl;
    
    // 8. 连接tuple
    cout << "8. 连接tuple:" << endl;
    auto tuple1 = make_tuple(1, "Hello");
    auto tuple2 = make_tuple(3.14, 'A');
    auto combined = tuple_cat(tuple1, tuple2);
    cout << "连接后的tuple: " << get<0>(combined) << ", " << get<1>(combined)
         << ", " << get<2>(combined) << ", " << get<3>(combined) << endl;
    
    // 9. 使用forward_as_tuple创建转发引用tuple
    cout << "9. 使用forward_as_tuple:" << endl;
    string firstName = "John";
    string lastName = "Doe";
    auto nameTuple = forward_as_tuple(move(firstName), move(lastName));
    cout << "转发引用tuple: " << get<0>(nameTuple) << " " << get<1>(nameTuple) << endl;
    
    // 10. 使用apply调用函数
    cout << "10. 使用apply调用函数:" << endl;
    auto printInfo = [](int age, const string& name, double height) {
        cout << "应用结果: " << age << ", " << name << ", " << height << endl;
    };
    apply(printInfo, person1);
    
    // 11. 使用make_from_tuple构造对象
    cout << "11. 使用make_from_tuple构造对象:" << endl;
    auto personArgs = make_tuple(40, "David", 185.0);
    auto person = make_from_tuple<Person>(personArgs);
    cout << "构造的Person: " << person.age << ", " 
         << person.name << ", " << person.height << endl;
    
    return 0;
}
```

### (2) 模板元编程与tuple结合示例

```cpp
#include <iostream>
#include <tuple>
#include <type_traits>
#include <utility>

using namespace std;

// 1. 编译时遍历tuple
template<typename Tuple, typename Func, size_t... Is>
void for_each_impl(Tuple&& t, Func&& f, index_sequence<Is...>) {
    (forward<Func>(f)(get<Is>(forward<Tuple>(t))), ...);
}

template<typename Tuple, typename Func>
void tuple_for_each(Tuple&& t, Func&& f) {
    constexpr size_t size = tuple_size_v<remove_reference_t<Tuple>>;
    for_each_impl(forward<Tuple>(t), forward<Func>(f), make_index_sequence<size>{});
}

// 2. 编译时转换tuple
template<typename Tuple, typename Func, size_t... Is>
auto transform_impl(Tuple&& t, Func&& f, index_sequence<Is...>) {
    return make_tuple(forward<Func>(f)(get<Is>(forward<Tuple>(t)))...);
}

template<typename Tuple, typename Func>
auto tuple_transform(Tuple&& t, Func&& f) {
    constexpr size_t size = tuple_size_v<remove_reference_t<Tuple>>;
    return transform_impl(forward<Tuple>(t), forward<Func>(f), make_index_sequence<size>{});
}

// 3. 编译时过滤tuple
template<typename Tuple, typename Pred, size_t... Is>
auto filter_impl(Tuple&& t, Pred&& p, index_sequence<Is...>) {
    return tuple_cat(conditional_t<
        invoke_result_t<Pred, decltype(get<Is>(forward<Tuple>(t)))>::value,
        tuple<decltype(get<Is>(forward<Tuple>(t)))>,
        tuple<>
    >{}...);
}

// 4. 编译时查找tuple元素类型
template<typename T, typename Tuple>
struct tuple_contains;

template<typename T, typename... Types>
struct tuple_contains<T, tuple<Types...>> 
    : integral_constant<bool, (is_same_v<T, Types> || ...)> {};

template<typename T, typename Tuple>
inline constexpr bool tuple_contains_v = tuple_contains<T, Tuple>::value;

// 5. 编译时获取tuple中类型的索引
template<typename T, typename Tuple>
struct tuple_index;

template<typename T, typename... Types>
struct tuple_index<T, tuple<T, Types...>> 
    : integral_constant<size_t, 0> {};

template<typename T, typename U, typename... Types>
struct tuple_index<T, tuple<U, Types...>> 
    : integral_constant<size_t, 1 + tuple_index<T, tuple<Types...>>::value> {};

template<typename T, typename Tuple>
inline constexpr size_t tuple_index_v = tuple_index<T, Tuple>::value;

int main() {
    cout << "=== 模板元编程与tuple结合示例 ===" << endl << endl;
    
    // 1. 编译时遍历tuple
    cout << "1. 编译时遍历tuple:" << endl;
    auto myTuple = make_tuple(1, 2.5, "Hello", 'A');
    tuple_for_each(myTuple, [](const auto& value) {
        cout << value << " ";
    });
    cout << endl << endl;
    
    // 2. 编译时转换tuple
    cout << "2. 编译时转换tuple:" << endl;
    auto transformed = tuple_transform(myTuple, [](const auto& value) {
        if constexpr (is_integral_v<decltype(value)>) {
            return value * 2;
        } else if constexpr (is_floating_point_v<decltype(value)>) {
            return value + 1.0;
        } else {
            return value;
        }
    });
    
    tuple_for_each(transformed, [](const auto& value) {
        cout << value << " ";
    });
    cout << endl << endl;
    
    // 3. 类型检查
    cout << "3. 类型检查:" << endl;
    using MyTuple = tuple<int, double, string, char>;
    cout << "tuple包含int: " << tuple_contains_v<int, MyTuple> << endl;
    cout << "tuple包含float: " << tuple_contains_v<float, MyTuple> << endl;
    cout << "string的索引: " << tuple_index_v<string, MyTuple> << endl;
    cout << endl;
    
    // 4. 使用tuple_size和tuple_element
    cout << "4. 使用tuple_size和tuple_element:" << endl;
    cout << "tuple大小: " << tuple_size_v<MyTuple> << endl;
    
    using FirstType = tuple_element_t<0, MyTuple>;
    using SecondType = tuple_element_t<1, MyTuple>;
    cout << "第一个元素的类型: " << typeid(FirstType).name() << endl;
    cout << "第二个元素的类型: " << typeid(SecondType).name() << endl;
    cout << endl;
    
    // 5. 高级应用: 实现一个简单的ORM映射
    cout << "5. 高级应用: 简单的ORM映射:" << endl;
    
    // 定义数据库表结构
    struct UserTable {
        int id;
        string name;
        string email;
        int age;
    };
    
    // 创建对应的tuple
    auto user = make_tuple(1, "Alice", "alice@example.com", 30);
    
    // 模拟SQL查询
    auto execute_query = [](const auto&... conditions) {
        cout << "执行查询: SELECT * FROM users WHERE ";
        ((cout << conditions << " AND "), ...);
        cout << "1=1" << endl;
        return make_tuple(1, "Alice", "alice@example.com", 30);
    };
    
    // 使用apply调用查询函数
    auto query_conditions = make_tuple("age > 25", "name LIKE 'A%'");
    apply(execute_query, query_conditions);
    
    return 0;
}
```

### (3) 与结构化绑定结合示例

```cpp
#include <iostream>
#include <tuple>
#include <vector>
#include <map>

using namespace std;

// 返回多个值的函数
tuple<string, int, vector<string>> getEmployeeDetails() {
    return make_tuple("John Doe", 35, vector<string>{"Project A", "Project B"});
}

// 多返回值示例
tuple<bool, string, int> processRequest(const string& request) {
    if (request == "success") {
        return make_tuple(true, "Request processed", 200);
    } else {
        return make_tuple(false, "Invalid request", 400);
    }
}

int main() {
    cout << "=== tuple与结构化绑定结合示例 ===" << endl << endl;
    
    // 1. 多返回值处理
    cout << "1. 多返回值处理:" << endl;
    auto [success, message, code] = processRequest("success");
    cout << "成功: " << success << ", 消息: " << message << ", 代码: " << code << endl;
    
    auto [success2, message2, code2] = processRequest("fail");
    cout << "成功: " << success2 << ", 消息: " << message2 << ", 代码: " << code2 << endl;
    cout << endl;
    
    // 2. 复杂数据结构处理
    cout << "2. 复杂数据结构处理:" << endl;
    auto [name, age, projects] = getEmployeeDetails();
    cout << "员工: " << name << ", 年龄: " << age << ", 项目: ";
    for (const auto& project : projects) {
        cout << project << " ";
    }
    cout << endl << endl;
    
    // 3. 与map结合使用
    cout << "3. 与map结合使用:" << endl;
    map<int, tuple<string, double>> productCatalog;
    productCatalog[1] = make_tuple("Laptop", 999.99);
    productCatalog[2] = make_tuple("Mouse", 25.50);
    productCatalog[3] = make_tuple("Keyboard", 75.00);
    
    for (const auto& [id, productInfo] : productCatalog) {
        auto [productName, price] = productInfo;
        cout << "ID: " << id << ", 产品: " << productName << ", 价格: $" << price << endl;
    }
    cout << endl;
    
    // 4. 函数参数打包
    cout << "4. 函数参数打包:" << endl;
    auto createPerson = [](const string& name, int age, const string& city) {
        cout << "创建人物: " << name << ", " << age << ", " << city << endl;
        return make_tuple(name, age, city);
    };
    
    auto personParams = make_tuple("Bob", 28, "New York");
    auto person = apply(createPerson, personParams);
    cout << "创建的人物: " << get<0>(person) << ", " << get<1>(person) << ", " << get<2>(person) << endl;
    
    return 0;
}
```

### (4) 总结

`std::tuple` 是 C++ 中非常强大的工具，它具有以下优势：

1. **异构容器**：可以存储不同类型的元素
2. **编译时特性**：大小和类型在编译时确定，没有运行时开销
3. **结构化绑定**：与 C++17 的结构化绑定完美配合
4. **函数多返回值**：可以轻松返回多个值
5. **模板元编程**：强大的编译时计算能力
6. **类型安全**：比传统方法（如结构体或可变参数）更安全

#### 常用场景：

1. **函数返回多个值**：替代通过引用参数返回多个值的方式
2. **通用编程**：在模板代码中处理未知类型集合
3. **编译时计算**：与模板元编程结合进行编译时计算
4. **数据打包**：将相关数据打包在一起传递
5. **替代结构体**：对于简单的数据聚合，可以替代简单的结构体

#### 注意事项：

1. **访问元素**：使用 `std::get` 或结构化绑定访问元素
2. **元素类型**：元素类型可以是任何可复制构造的类型
3. **性能**：tuple 的创建和访问通常没有运行时开销
4. **可读性**：对于复杂的数据结构，有时使用命名结构体可能更清晰

`std::tuple` 是现代 C++ 编程中不可或缺的工具，特别是在模板元编程和通用编程中。

## 2. [`<any>`](https://cppreference.cn/w/cpp/header/any) 和 [`<variant>`](https://cppreference.cn/w/cpp/header/variant) 标准库详解

### (1) 概述

`<any>` 和 `<variant>` 是 C++17 引入的两个重要类型安全容器，用于处理多态值和类型安全的联合体。

### (2) `<any>` 和 `<variant>` 对比

| 特性         | `std::any`               | `std::variant`                         |
| ------------ | ------------------------ | -------------------------------------- |
| **类型安全** | 是                       | 是                                     |
| **存储机制** | 类型擦除，动态分配       | 栈分配，大小足够容纳最大类型           |
| **类型集合** | 任何可复制构造类型       | 编译时确定的有限类型集合               |
| **访问方式** | `any_cast`（运行时检查） | `get`、`get_if`、`visit`（编译时检查） |
| **性能**     | 可能有动态分配开销       | 无动态分配，编译时确定                 |
| **异常**     | `bad_any_cast`           | `bad_variant_access`                   |
| **使用场景** | 需要存储任意类型的值     | 需要存储有限类型集合中的一种值         |
| **空状态**   | 可以为空                 | 必须有值（除非使用`monostate`）        |

### (3) 完整示例代码

```cpp
#include <iostream>
#include <any>
#include <variant>
#include <string>
#include <vector>
#include <type_traits>
#include <typeinfo>
#include <cxxabi.h> // 用于类型名称 demangle
#include <map>
#include <functional>

using namespace std;

// 辅助函数：获取可读的类型名称
string demangle(const char* mangled) {
    int status;
    char* demangled = abi::__cxa_demangle(mangled, nullptr, nullptr, &status);
    if (status == 0) {
        string result(demangled);
        free(demangled);
        return result;
    }
    return mangled;
}

template<typename T>
string type_name() {
    return demangle(typeid(T).name());
}

int main() {
    cout << "=== C++17 any 和 variant 示例 ===" << endl << endl;
    
    // 1. any 基本用法
    cout << "1. any 基本用法:" << endl;
    any a = 42;
    cout << "a 包含 int: " << any_cast<int>(a) << endl;
    
    a = string("Hello");
    cout << "a 包含 string: " << any_cast<string>(a) << endl;
    
    a = 3.14;
    cout << "a 包含 double: " << any_cast<double>(a) << endl;
    
    // 检查 any 是否包含值
    if (a.has_value()) {
        cout << "a 有值" << endl;
    }
    
    // 重置 any
    a.reset();
    if (!a.has_value()) {
        cout << "a 已被重置，无值" << endl;
    }
    cout << endl;
    
    // 2. any 异常处理
    cout << "2. any 异常处理:" << endl;
    any b = 100;
    try {
        auto value = any_cast<string>(b); // 错误转换
        cout << "值: " << value << endl;
    } catch (const bad_any_cast& e) {
        cout << "bad_any_cast 异常: " << e.what() << endl;
    }
    cout << endl;
    
    // 3. any 与 make_any
    cout << "3. any 与 make_any:" << endl;
    auto c = make_any<vector<int>>(3, 10); // 创建包含 vector 的 any
    auto& vec = any_cast<vector<int>&>(c);
    cout << "vector 内容: ";
    for (int num : vec) {
        cout << num << " ";
    }
    cout << endl << endl;
    
    // 4. variant 基本用法
    cout << "4. variant 基本用法:" << endl;
    variant<int, string, double> v = 42;
    cout << "v 包含 int: " << get<int>(v) << endl;
    
    v = "Hello";
    cout << "v 包含 string: " << get<string>(v) << endl;
    
    v = 3.14;
    cout << "v 包含 double: " << get<double>(v) << endl;
    cout << endl;
    
    // 5. variant 索引访问
    cout << "5. variant 索引访问:" << endl;
    cout << "v 的索引: " << v.index() << endl;
    
    // 使用 get 根据索引访问
    if (v.index() == 0) {
        cout << "值为 int: " << get<0>(v) << endl;
    } else if (v.index() == 1) {
        cout << "值为 string: " << get<1>(v) << endl;
    } else if (v.index() == 2) {
        cout << "值为 double: " << get<2>(v) << endl;
    }
    cout << endl;
    
    // 6. variant 异常处理
    cout << "6. variant 异常处理:" << endl;
    try {
        auto value = get<string>(v); // v 当前包含 double
        cout << "字符串值: " << value << endl;
    } catch (const bad_variant_access& e) {
        cout << "bad_variant_access 异常: " << e.what() << endl;
    }
    cout << endl;
    
    // 7. variant 与 get_if
    cout << "7. variant 与 get_if:" << endl;
    if (auto int_ptr = get_if<int>(&v)) {
        cout << "v 包含 int: " << *int_ptr << endl;
    } else if (auto str_ptr = get_if<string>(&v)) {
        cout << "v 包含 string: " << *str_ptr << endl;
    } else if (auto dbl_ptr = get_if<double>(&v)) {
        cout << "v 包含 double: " << *dbl_ptr << endl;
    }
    cout << endl;
    
    // 8. variant 与 visit
    cout << "8. variant 与 visit:" << endl;
    auto visitor = [](auto&& arg) {
        using T = decay_t<decltype(arg)>;
        cout << "访问的值: " << arg << " (类型: " << type_name<T>() << ")" << endl;
    };
    visit(visitor, v);
    cout << endl;
    
    // 9. variant 与 monostate
    cout << "9. variant 与 monostate:" << endl;
    variant<monostate, int, string> optional_value;
    cout << "optional_value 索引: " << optional_value.index() << endl; // 0, 表示 monostate
    
    optional_value = 42;
    cout << "optional_value 索引: " << optional_value.index() << endl; // 1, 表示 int
    
    optional_value = monostate{};
    cout << "optional_value 索引: " << optional_value.index() << endl; // 0, 表示 monostate
    cout << endl;
    
    // 10. variant 比较操作
    cout << "10. variant 比较操作:" << endl;
    variant<int, string> v1 = 10;
    variant<int, string> v2 = 20;
    variant<int, string> v3 = "hello";
    
    cout << "v1 < v2: " << (v1 < v2) << endl; // true
    cout << "v1 < v3: " << (v1 < v3) << endl; // true (int < string)
    cout << "v3 < v1: " << (v3 < v1) << endl; // false (string > int)
    cout << endl;
    
    return 0;
}
```

### (4) 模板元编程与 any/variant 结合示例

```cpp
#include <iostream>
#include <any>
#include <variant>
#include <type_traits>
#include <vector>
#include <map>
#include <functional>

using namespace std;

// 1. 类型安全的任意值存储系统
class AnyValueSystem {
private:
    map<string, any> values;
    
public:
    template<typename T>
    void store(const string& key, const T& value) {
        values[key] = value;
    }
    
    template<typename T>
    bool retrieve(const string& key, T& result) {
        auto it = values.find(key);
        if (it != values.end()) {
            try {
                result = any_cast<T>(it->second);
                return true;
            } catch (const bad_any_cast&) {
                return false;
            }
        }
        return false;
    }
    
    template<typename T>
    T retrieve_or_default(const string& key, const T& default_value) {
        T result;
        return retrieve(key, result) ? result : default_value;
    }
};

// 2. 基于 variant 的类型安全消息系统
struct LoginMessage { string username; string password; };
struct LogoutMessage { string username; };
struct ChatMessage { string from; string to; string content; };

using Message = variant<LoginMessage, LogoutMessage, ChatMessage>;

class MessageProcessor {
public:
    void process(const Message& msg) {
        visit([this](auto&& arg) {
            this->handle_message(forward<decltype(arg)>(arg));
        }, msg);
    }
    
private:
    void handle_message(const LoginMessage& msg) {
        cout << "处理登录消息: " << msg.username << endl;
    }
    
    void handle_message(const LogoutMessage& msg) {
        cout << "处理登出消息: " << msg.username << endl;
    }
    
    void handle_message(const ChatMessage& msg) {
        cout << "处理聊天消息: " << msg.from << " -> " << msg.to 
             << ": " << msg.content << endl;
    }
};

// 3. 编译时类型检查工具
template<typename... Types>
struct TypeChecker {
    template<typename T>
    static constexpr bool contains() {
        return (is_same_v<T, Types> || ...);
    }
    
    template<typename T>
    static constexpr size_t index_of() {
        size_t index = 0;
        bool found = false;
        
        ((is_same_v<T, Types> ? (found = true, false) : (index++, true)) && ...);
        
        return found ? index : static_cast<size_t>(-1);
    }
};

// 4. 基于 variant 的状态机
struct IdleState {};
struct RunningState { int progress; };
struct PausedState { int progress; };
struct FinishedState { string result; };

using State = variant<IdleState, RunningState, PausedState, FinishedState>;

class StateMachine {
private:
    State current_state;
    
public:
    StateMachine() : current_state(IdleState{}) {}
    
    void start() {
        current_state = visit([](auto&& state) -> State {
            using T = decay_t<decltype(state)>;
            
            if constexpr (is_same_v<T, IdleState>) {
                return RunningState{0};
            } else {
                cerr << "无效的状态转换" << endl;
                return state;
            }
        }, current_state);
    }
    
    void pause() {
        current_state = visit([](auto&& state) -> State {
            using T = decay_t<decltype(state)>;
            
            if constexpr (is_same_v<T, RunningState>) {
                return PausedState{state.progress};
            } else {
                cerr << "无效的状态转换" << endl;
                return state;
            }
        }, current_state);
    }
    
    void resume() {
        current_state = visit([](auto&& state) -> State {
            using T = decay_t<decltype(state)>;
            
            if constexpr (is_same_v<T, PausedState>) {
                return RunningState{state.progress};
            } else {
                cerr << "无效的状态转换" << endl;
                return state;
            }
        }, current_state);
    }
    
    void finish(const string& result) {
        current_state = visit([](auto&& state) -> State {
            using T = decay_t<decltype(state)>;
            
            if constexpr (is_same_v<T, RunningState> || is_same_v<T, PausedState>) {
                return FinishedState{result};
            } else {
                cerr << "无效的状态转换" << endl;
                return state;
            }
        }, current_state);
    }
    
    void print_state() {
        visit([](auto&& state) {
            using T = decay_t<decltype(state)>;
            
            if constexpr (is_same_v<T, IdleState>) {
                cout << "当前状态: 空闲" << endl;
            } else if constexpr (is_same_v<T, RunningState>) {
                cout << "当前状态: 运行中, 进度: " << state.progress << "%" << endl;
            } else if constexpr (is_same_v<T, PausedState>) {
                cout << "当前状态: 暂停, 进度: " << state.progress << "%" << endl;
            } else if constexpr (is_same_v<T, FinishedState>) {
                cout << "当前状态: 完成, 结果: " << state.result << endl;
            }
        }, current_state);
    }
};

int main() {
    cout << "=== 模板元编程与 any/variant 结合示例 ===" << endl << endl;
    
    // 1. AnyValueSystem 示例
    cout << "1. AnyValueSystem 示例:" << endl;
    AnyValueSystem system;
    system.store("name", string("Alice"));
    system.store("age", 30);
    system.store("score", 95.5);
    
    string name;
    int age;
    double score;
    
    if (system.retrieve("name", name)) {
        cout << "姓名: " << name << endl;
    }
    
    if (system.retrieve("age", age)) {
        cout << "年龄: " << age << endl;
    }
    
    score = system.retrieve_or_default("score", 0.0);
    cout << "分数: " << score << endl;
    
    auto missing = system.retrieve_or_default("missing", "默认值");
    cout << "缺失的值: " << missing << endl;
    cout << endl;
    
    // 2. MessageProcessor 示例
    cout << "2. MessageProcessor 示例:" << endl;
    MessageProcessor processor;
    
    Message login_msg = LoginMessage{"alice", "secret"};
    Message chat_msg = ChatMessage{"alice", "bob", "你好!"};
    Message logout_msg = LogoutMessage{"alice"};
    
    processor.process(login_msg);
    processor.process(chat_msg);
    processor.process(logout_msg);
    cout << endl;
    
    // 3. TypeChecker 示例
    cout << "3. TypeChecker 示例:" << endl;
    using Checker = TypeChecker<int, double, string, vector<int>>;
    
    cout << "包含 int: " << Checker::contains<int>() << endl;
    cout << "包含 float: " << Checker::contains<float>() << endl;
    cout << "string 的索引: " << Checker::index_of<string>() << endl;
    cout << "float 的索引: " << Checker::index_of<float>() << endl;
    cout << endl;
    
    // 4. StateMachine 示例
    cout << "4. StateMachine 示例:" << endl;
    StateMachine machine;
    machine.print_state();
    
    machine.start();
    machine.print_state();
    
    // 更新运行状态
    visit([](auto&& state) {
        using T = decay_t<decltype(state)>;
        if constexpr (is_same_v<T, RunningState>) {
            const_cast<RunningState&>(state).progress = 50;
        }
    }, machine.get_state());
    
    machine.pause();
    machine.print_state();
    
    machine.resume();
    machine.print_state();
    
    machine.finish("成功完成");
    machine.print_state();
    
    return 0;
}
```

### (5) 注意事项和最佳实践

#### `<any>` 注意事项：
1. **性能考虑**：`any` 使用类型擦除和小对象优化，但可能仍有动态分配开销
2. **类型安全**：使用 `any_cast` 时必须确保类型正确，否则抛出异常
3. **空状态**：`any` 可以为空，使用前应检查 `has_value()`
4. **内存管理**：存储大对象时可能涉及动态内存分配

#### `<variant>` 注意事项：
1. **类型集合**：必须在编译时确定类型集合
2. **默认构造**：`variant` 的默认构造函数会使用第一个可默认构造的类型
3. **访问安全**：使用 `visit` 是最安全的访问方式，可以处理所有可能的情况
4. **值语义**：`variant` 具有值语义，复制和移动操作会复制或移动存储的值
5. **monostate**：如果需要可默认构造但第一个类型不可默认构造，可以使用 `monostate`

#### 最佳实践：
1. 优先使用 `variant`，因为它提供更好的类型安全和编译时检查
2. 使用 `visit` 而不是 `get` 或 `get_if` 来访问 `variant`，以避免遗漏情况
3. 对于需要存储任意类型的场景，使用 `any`，但要小心类型安全问题
4. 考虑使用 `monostate` 作为 `variant` 的第一个类型，以支持空状态
5. 在性能关键代码中，谨慎使用 `any`，因为它可能涉及动态分配

### (6) 总结

`std::any` 和 `std::variant` 是 C++17 引入的两个强大工具，用于处理多态值和类型安全的联合体：

1. **`std::any`**：适用于需要存储任意类型的场景，但需要付出类型安全和性能的代价
2. **`std::variant`**：适用于需要存储有限类型集合中的一种值的场景，提供更好的类型安全和性能

两者都提供了类型安全的替代方案，可以替代传统的基于继承的多态或危险的类型转换。在实际开发中，应根据具体需求选择合适的工具：

- 当类型集合在编译时已知时，优先使用 `variant`
- 当需要存储任意类型时，使用 `any`
- 对于复杂的状态机或消息处理系统，`variant` 与 `visit` 的组合非常强大
- 对于配置系统或动态数据存储，`any` 可能更合适

通过结合模板元编程技术，可以构建出既类型安全又灵活的系统，如示例中的类型安全消息系统和状态机。

## 3. `<optional>` 标准库详解

`<optional>` 头文件提供了 `std::optional` 类模板，用于表示可能包含值也可能不包含值的包装器。它是处理可能缺失的值的类型安全方式，避免了使用特殊值（如 `nullptr`、`-1` 等）或额外的布尔标志来表示值的存在与否。

### (1) 基本用法示例

```cpp
#include <iostream>
#include <optional>
#include <string>
#include <vector>
#include <functional>
#include <algorithm>
#include <cmath>

using namespace std;

// 示例函数，可能返回有效值也可能不返回
optional<int> divide(int a, int b) {
    if (b == 0) {
        return nullopt; // 表示无值
    }
    return a / b;
}

// 示例函数，可能返回字符串
optional<string> find_name_by_id(int id) {
    if (id == 1) {
        return "Alice";
    } else if (id == 2) {
        return "Bob";
    }
    return nullopt; // 未找到
}

int main() {
    cout << "=== C++17 optional 基本用法示例 ===" << endl << endl;
    
    // 1. 创建 optional 对象
    cout << "1. 创建 optional 对象:" << endl;
    optional<int> opt1;           // 默认构造，不包含值
    optional<int> opt2 = 42;      // 从值构造
    optional<int> opt3 = nullopt; // 显式不包含值
    optional<string> opt4 = "Hello";
    
    cout << "opt1 有值: " << opt1.has_value() << endl;
    cout << "opt2 有值: " << opt2.has_value() << ", 值: " << *opt2 << endl;
    cout << "opt3 有值: " << opt3.has_value() << endl;
    cout << "opt4 有值: " << opt4.has_value() << ", 值: " << *opt4 << endl;
    cout << endl;
    
    // 2. 使用 make_optional
    cout << "2. 使用 make_optional:" << endl;
    auto opt5 = make_optional(3.14);
    auto opt6 = make_optional<string>("World");
    auto opt7 = make_optional<vector<int>>({1, 2, 3});
    
    cout << "opt5: " << *opt5 << endl;
    cout << "opt6: " << *opt6 << endl;
    cout << "opt7: ";
    for (int num : *opt7) {
        cout << num << " ";
    }
    cout << endl << endl;
    
    // 3. 访问 optional 中的值
    cout << "3. 访问 optional 中的值:" << endl;
    
    // 使用 operator* 和 operator->
    if (opt6.has_value()) {
        cout << "opt6 的长度: " << opt6->length() << endl;
    }
    
    // 使用 value() 方法（会检查是否有值）
    try {
        cout << "opt5 的值: " << opt5.value() << endl;
        cout << "opt1 的值: " << opt1.value() << endl; // 会抛出异常
    } catch (const bad_optional_access& e) {
        cout << "捕获异常: " << e.what() << endl;
    }
    
    // 使用 value_or 提供默认值
    cout << "opt1 的值或默认值: " << opt1.value_or(100) << endl;
    cout << "opt2 的值或默认值: " << opt2.value_or(100) << endl;
    cout << endl;
    
    // 4. 修改 optional 对象
    cout << "4. 修改 optional 对象:" << endl;
    
    // 赋值操作
    opt1 = 10;
    cout << "opt1 赋值后: " << *opt1 << endl;
    
    // 重置为无值
    opt1.reset();
    cout << "opt1 重置后是否有值: " << opt1.has_value() << endl;
    
    // 使用 emplace 就地构造
    opt4.emplace("New String");
    cout << "opt4 就地构造后: " << *opt4 << endl;
    
    // 使用 swap
    optional<string> opt8 = "Swapped";
    opt4.swap(opt8);
    cout << "交换后 opt4: " << *opt4 << ", opt8: " << *opt8 << endl;
    cout << endl;
    
    // 5. 比较操作
    cout << "5. 比较操作:" << endl;
    optional<int> a = 10;
    optional<int> b = 20;
    optional<int> c = nullopt;
    optional<int> d = 10;
    
    cout << "a == b: " << (a == b) << endl;
    cout << "a == d: " << (a == d) << endl;
    cout << "a < b: " << (a < b) << endl;
    cout << "c == nullopt: " << (c == nullopt) << endl;
    cout << "a.has_value() == b.has_value(): " << (a.has_value() == b.has_value()) << endl;
    cout << endl;
    
    // 6. 使用示例函数
    cout << "6. 使用示例函数:" << endl;
    auto result1 = divide(10, 2);
    auto result2 = divide(10, 0);
    
    if (result1) {
        cout << "10 / 2 = " << *result1 << endl;
    } else {
        cout << "除法失败: 除数为零" << endl;
    }
    
    if (result2) {
        cout << "10 / 0 = " << *result2 << endl;
    } else {
        cout << "除法失败: 除数为零" << endl;
    }
    
    auto name = find_name_by_id(1);
    if (name) {
        cout << "找到名字: " << *name << endl;
    } else {
        cout << "未找到名字" << endl;
    }
    
    name = find_name_by_id(99);
    if (name) {
        cout << "找到名字: " << *name << endl;
    } else {
        cout << "未找到名字" << endl;
    }
    cout << endl;
    
    return 0;
}
```

### (2) C++23 Monadic 操作示例

```cpp
#include <iostream>
#include <optional>
#include <string>
#include <functional>
#include <cmath>

using namespace std;

// 示例函数，用于演示 Monadic 操作
optional<int> square(int x) {
    return x * x;
}

optional<int> half(int x) {
    if (x % 2 == 0) {
        return x / 2;
    }
    return nullopt;
}

optional<string> to_string_opt(int x) {
    return to_string(x);
}

int main() {
    cout << "=== C++23 optional Monadic 操作示例 ===" << endl << endl;
    
    // 1. and_then - 链式操作，如果 optional 有值则应用函数
    cout << "1. and_then 操作:" << endl;
    optional<int> opt = 4;
    
    // 如果 opt 有值，则应用 square 函数
    auto result1 = opt.and_then(square);
    cout << "4 的平方: " << (result1 ? to_string(*result1) : "无值") << endl;
    
    // 链式调用
    auto result2 = opt.and_then(half).and_then(square);
    cout << "4 的一半的平方: " << (result2 ? to_string(*result2) : "无值") << endl;
    
    // 对于空 optional
    optional<int> empty_opt = nullopt;
    auto result3 = empty_opt.and_then(square);
    cout << "空 optional 的平方: " << (result3 ? to_string(*result3) : "无值") << endl;
    cout << endl;
    
    // 2. transform - 转换操作，如果 optional 有值则应用函数并包装结果
    cout << "2. transform 操作:" << endl;
    auto result4 = opt.transform([](int x) { return x * 2; });
    cout << "4 的两倍: " << (result4 ? to_string(*result4) : "无值") << endl;
    
    // 转换类型
    auto result5 = opt.transform(to_string_opt);
    cout << "4 的字符串: " << (result5 ? *result5 : "无值") << endl;
    
    // 对于空 optional
    auto result6 = empty_opt.transform([](int x) { return x * 2; });
    cout << "空 optional 的两倍: " << (result6 ? to_string(*result6) : "无值") << endl;
    cout << endl;
    
    // 3. or_else - 如果 optional 为空，则执行备用操作
    cout << "3. or_else 操作:" << endl;
    auto result7 = opt.or_else([] { 
        cout << "opt 有值，不会执行此函数" << endl;
        return optional<int>(100); 
    });
    cout << "结果: " << (result7 ? to_string(*result7) : "无值") << endl;
    
    auto result8 = empty_opt.or_else([] { 
        cout << "empty_opt 无值，执行备用函数" << endl;
        return optional<int>(100); 
    });
    cout << "结果: " << (result8 ? to_string(*result8) : "无值") << endl;
    cout << endl;
    
    // 4. 复杂的 Monadic 操作链
    cout << "4. 复杂的 Monadic 操作链:" << endl;
    
    // 创建一个处理管道
    auto process = [](optional<int> input) {
        return input
            .and_then(half)        // 尝试减半
            .transform([](int x) { return x + 10; }) // 加10
            .and_then(square)      // 平方
            .or_else([] { return optional<int>(0); }); // 如果任何步骤失败，返回0
    };
    
    cout << "处理 8: " << *process(8) << endl;    // ((8/2)+10)^2 = (4+10)^2 = 196
    cout << "处理 7: " << *process(7) << endl;    // 7不能被2整除，返回0
    cout << "处理 nullopt: " << *process(nullopt) << endl; // 空输入，返回0
    cout << endl;
    
    return 0;
}
```

### (3) 高级用法和模板元编程示例

```cpp
#include <iostream>
#include <optional>
#include <vector>
#include <algorithm>
#include <functional>
#include <type_traits>

using namespace std;

// 1. 使用 optional 作为函数返回值
optional<double> safe_sqrt(double x) {
    if (x >= 0) {
        return sqrt(x);
    }
    return nullopt;
}

// 2. 使用 optional 作为类成员
class UserProfile {
private:
    optional<string> nickname;
    optional<int> age;
    optional<string> email;
    
public:
    UserProfile() = default;
    
    void set_nickname(const string& name) { nickname = name; }
    void set_age(int a) { age = a; }
    void set_email(const string& e) { email = e; }
    
    optional<string> get_nickname() const { return nickname; }
    optional<int> get_age() const { return age; }
    optional<string> get_email() const { return email; }
    
    void print() const {
        cout << "用户信息:" << endl;
        if (nickname) cout << "  昵称: " << *nickname << endl;
        if (age) cout << "  年龄: " << *age << endl;
        if (email) cout << "  邮箱: " << *email << endl;
        
        // 检查是否有缺失的信息
        if (!nickname || !age || !email) {
            cout << "  (信息不完整)" << endl;
        }
    }
};

// 3. 使用 optional 与 STL 算法
template<typename T>
optional<T> find_first_positive(const vector<optional<T>>& values) {
    for (const auto& opt : values) {
        if (opt && *opt > 0) {
            return opt;
        }
    }
    return nullopt;
}

// 4. 编译时检查 optional 特性
template<typename T>
struct is_optional : false_type {};

template<typename T>
struct is_optional<optional<T>> : true_type {};

template<typename T>
inline constexpr bool is_optional_v = is_optional<T>::value;

// 5. 类型安全的配置系统
class Configuration {
private:
    using ConfigValue = variant<optional<int>, optional<string>, optional<double>, optional<bool>>;
    map<string, ConfigValue> settings;
    
public:
    template<typename T>
    void set(const string& key, const optional<T>& value) {
        settings[key] = value;
    }
    
    template<typename T>
    optional<T> get(const string& key) const {
        auto it = settings.find(key);
        if (it != settings.end()) {
            try {
                return get<optional<T>>(it->second);
            } catch (const bad_variant_access&) {
                return nullopt;
            }
        }
        return nullopt;
    }
};

// 6. 使用 optional 实现惰性求值
template<typename Fn>
class LazyValue {
private:
    mutable optional<invoke_result_t<Fn>> cached_value;
    Fn computation;
    
public:
    LazyValue(Fn fn) : computation(fn) {}
    
    auto& get() const {
        if (!cached_value) {
            cached_value = computation();
        }
        return *cached_value;
    }
    
    void reset() {
        cached_value.reset();
    }
};

int main() {
    cout << "=== optional 高级用法示例 ===" << endl << endl;
    
    // 1. 使用 optional 作为函数返回值
    cout << "1. 使用 optional 作为函数返回值:" << endl;
    auto result1 = safe_sqrt(9.0);
    auto result2 = safe_sqrt(-1.0);
    
    cout << "sqrt(9) = " << (result1 ? to_string(*result1) : "无效") << endl;
    cout << "sqrt(-1) = " << (result2 ? to_string(*result2) : "无效") << endl;
    cout << endl;
    
    // 2. 使用 optional 作为类成员
    cout << "2. 使用 optional 作为类成员:" << endl;
    UserProfile user;
    user.set_nickname("SuperUser");
    user.set_age(25);
    // 不设置邮箱
    
    user.print();
    cout << endl;
    
    // 3. 使用 optional 与 STL 算法
    cout << "3. 使用 optional 与 STL 算法:" << endl;
    vector<optional<int>> numbers = {nullopt, -5, 0, 10, nullopt, 3};
    auto first_positive = find_first_positive(numbers);
    
    if (first_positive) {
        cout << "第一个正数: " << *first_positive << endl;
    } else {
        cout << "没有找到正数" << endl;
    }
    cout << endl;
    
    // 4. 编译时检查 optional 特性
    cout << "4. 编译时检查 optional 特性:" << endl;
    cout << "is_optional_v<int>: " << is_optional_v<int> << endl;
    cout << "is_optional_v<optional<string>>: " << is_optional_v<optional<string>> << endl;
    cout << endl;
    
    // 5. 类型安全的配置系统
    cout << "5. 类型安全的配置系统:" << endl;
    Configuration config;
    config.set<int>("timeout", 30);
    config.set<string>("hostname", "example.com");
    config.set<double>("ratio", nullopt); // 未设置的配置
    
    auto timeout = config.get<int>("timeout");
    auto hostname = config.get<string>("hostname");
    auto ratio = config.get<double>("ratio");
    auto missing = config.get<int>("missing_key");
    
    cout << "timeout: " << (timeout ? to_string(*timeout) : "未设置") << endl;
    cout << "hostname: " << (hostname ? *hostname : "未设置") << endl;
    cout << "ratio: " << (ratio ? to_string(*ratio) : "未设置") << endl;
    cout << "missing_key: " << (missing ? to_string(*missing) : "未设置") << endl;
    cout << endl;
    
    // 6. 使用 optional 实现惰性求值
    cout << "6. 使用 optional 实现惰性求值:" << endl;
    int call_count = 0;
    LazyValue lazy_value([&call_count] {
        call_count++;
        cout << "计算值 (调用次数: " << call_count << ")" << endl;
        return 42;
    });
    
    cout << "第一次获取值: " << lazy_value.get() << endl;
    cout << "第二次获取值: " << lazy_value.get() << endl; // 不会重新计算
    
    lazy_value.reset();
    cout << "重置后获取值: " << lazy_value.get() << endl; // 重新计算
    cout << endl;
    
    return 0;
}
```

### (4) 注意事项和最佳实践

#### 注意事项：
1. **性能考虑**：`optional` 通常不会引入额外的动态内存分配，但会增加对象的大小（通常是一个字节的标志位加上对齐）
2. **异常安全**：使用 `value()` 方法访问值时，如果 `optional` 为空会抛出 `bad_optional_access` 异常
3. **默认构造**：默认构造的 `optional` 不包含值
4. **与指针的区别**：`optional` 管理值的生命周期，而指针只是引用值
5. **Monadic 操作**：C++23 的 Monadic 操作需要编译器支持

#### 最佳实践：
1. **优先使用 `optional` 而不是特殊值**：使用 `optional` 可以更清晰地表达值可能缺失的语义
2. **使用 `value_or` 提供默认值**：这是一种简洁的方式来处理可能缺失的值
3. **使用 `has_value()` 或布尔转换检查值的存在**：在访问值之前检查是否存在
4. **优先使用 `value()` 而不是 `operator*`**：`value()` 会进行存在性检查，更安全
5. **考虑使用结构化绑定**：C++17 的结构化绑定可以与 `optional` 很好地配合使用
6. **使用 Monadic 操作进行链式处理**：C++23 的 Monadic 操作可以使代码更简洁

#### 适用场景：
1. **函数可能无法返回有效值**：如查找操作、解析操作等
2. **可选的对象成员**：如用户配置中可选的项目
3. **延迟初始化**：只有在需要时才创建对象
4. **错误处理**：作为异常的一种替代方案，用于表示可恢复的错误
5. **API 设计**：使接口更清晰，明确表示哪些参数或返回值是可选的

### (5) 总结

`std::optional` 是 C++17 引入的一个重要特性，它提供了一种类型安全的方式来表示可能缺失的值。与使用特殊值（如 `nullptr`、`-1` 等）或额外的布尔标志相比，`optional` 具有以下优势：

1. **类型安全**：编译器可以检查是否正确处理了值缺失的情况
2. **表达力强**：代码更清晰地表达了值可能缺失的意图
3. **无需特殊值**：不需要为每种类型定义特殊的"无效"值
4. **易于使用**：提供了丰富的 API 来检查、访问和处理可能缺失的值
5. **性能良好**：通常不会引入运行时开销

C++23 进一步增强了 `optional` 的功能，引入了 Monadic 操作（`and_then`、`transform`、`or_else`），使得对 `optional` 值的链式处理更加简洁和表达力强。

在实际开发中，`optional` 可以广泛应用于各种场景，从简单的函数返回值到复杂的配置系统，都能提高代码的清晰度和安全性。

## 4. `<expected>` 标准库详解

`<expected>` 头文件是 C++23 引入的重要特性，提供了 `std::expected` 类模板，用于表示可能包含预期值或错误值的包装器。它是对 `std::optional` 的扩展，不仅能够表示值的存在与否，还能携带错误信息。

### (1) 底层实现对比

#### `std::expected` 底层实现（伪代码）：

```cpp
template<class T, class E>
class expected {
    union {
        T value;        // 预期值
        E error;        // 错误值
    };
    bool has_value;     // 标记是否包含预期值
    // ... 其他成员函数
};
```

#### `std::optional` 底层实现（伪代码）：
```cpp
struct _Nontrivial_dummy_type {
    constexpr _Nontrivial_dummy_type() noexcept {
        // This default constructor is user-provided to avoid zero-initialization when objects are value-initialized.
    }
};
template<class T>
class optional {
    union {
        _Nontrivial_dummy_type dummy;     // 空类占位符
        T value;        // 存储的值
    };
    bool has_value;     // 标记是否包含值
    // ... 其他成员函数
};
```

#### 主要区别：
1. **存储内容**：`expected` 可以存储两种类型（值或错误），而 `optional` 只能存储一种类型或空值
2. **错误处理**：`expected` 提供了更丰富的错误处理机制，可以携带详细的错误信息
3. **使用场景**：`expected` 适用于可能失败的操作，而 `optional` 适用于可能缺失的值

### (2) 完整示例代码

```cpp
#include <iostream>
#include <expected>
#include <string>
#include <vector>
#include <system_error>
#include <functional>
#include <cmath>

using namespace std;

// 1. 自定义错误类型
enum class MathError {
    DivisionByZero,
    NegativeSquareRoot,
    Overflow
};

string math_error_to_string(MathError err) {
    switch (err) {
        case MathError::DivisionByZero: return "Division by zero";
        case MathError::NegativeSquareRoot: return "Negative square root";
        case MathError::Overflow: return "Overflow";
        default: return "Unknown error";
    }
}

// 2. 使用 std::error_code 作为错误类型
enum class FileError {
    NotFound,
    PermissionDenied,
    AlreadyExists
};

namespace std {
    template<> struct is_error_code_enum<FileError> : true_type {};
}

error_code make_error_code(FileError e) {
    static const map<FileError, error_code> codes = {
        {FileError::NotFound, error_code(ENOENT, generic_category())},
        {FileError::PermissionDenied, error_code(EACCES, generic_category())},
        {FileError::AlreadyExists, error_code(EEXIST, generic_category())}
    };
    return codes.at(e);
}

// 3. 示例函数，返回 expected
expected<int, MathError> safe_divide(int a, int b) {
    if (b == 0) {
        return unexpected(MathError::DivisionByZero);
    }
    return a / b;
}

expected<double, MathError> safe_sqrt(double x) {
    if (x < 0) {
        return unexpected(MathError::NegativeSquareRoot);
    }
    return sqrt(x);
}

expected<string, error_code> read_file(const string& filename) {
    // 模拟文件读取操作
    if (filename == "missing.txt") {
        return unexpected(make_error_code(FileError::NotFound));
    }
    if (filename == "protected.txt") {
        return unexpected(make_error_code(FileError::PermissionDenied));
    }
    return "File content: Hello, World!";
}

int main() {
    cout << "=== C++23 expected 基本用法示例 ===" << endl << endl;
    
    // 1. 创建 expected 对象
    cout << "1. 创建 expected 对象:" << endl;
    expected<int, MathError> exp1 = 42; // 包含预期值
    expected<int, MathError> exp2 = unexpected(MathError::DivisionByZero); // 包含错误
    
    cout << "exp1 有值: " << exp1.has_value() << ", 值: " << *exp1 << endl;
    cout << "exp2 有值: " << exp2.has_value() << endl;
    if (!exp2.has_value()) {
        cout << "exp2 错误: " << math_error_to_string(exp2.error()) << endl;
    }
    cout << endl;
    
    // 2. 访问 expected 中的值
    cout << "2. 访问 expected 中的值:" << endl;
    
    // 使用 operator* 和 operator->
    if (exp1.has_value()) {
        cout << "exp1 的值: " << *exp1 << endl;
    }
    
    // 使用 value() 方法（会检查是否有值）
    try {
        cout << "exp1 的值: " << exp1.value() << endl;
        cout << "exp2 的值: " << exp2.value() << endl; // 会抛出异常
    } catch (const bad_expected_access<MathError>& e) {
        cout << "捕获异常: " << math_error_to_string(e.error()) << endl;
    }
    
    // 使用 value_or 提供默认值
    cout << "exp1 的值或默认值: " << exp1.value_or(100) << endl;
    cout << "exp2 的值或默认值: " << exp2.value_or(100) << endl;
    
    // 使用 error() 方法访问错误
    if (!exp2.has_value()) {
        cout << "exp2 的错误: " << math_error_to_string(exp2.error()) << endl;
    }
    
    // 使用 error_or 提供默认错误
    auto error_or_default = exp2.error_or(MathError::Overflow);
    cout << "exp2 的错误或默认错误: " << math_error_to_string(error_or_default) << endl;
    cout << endl;
    
    // 3. 使用示例函数
    cout << "3. 使用示例函数:" << endl;
    auto result1 = safe_divide(10, 2);
    auto result2 = safe_divide(10, 0);
    auto result3 = safe_sqrt(9.0);
    auto result4 = safe_sqrt(-1.0);
    
    cout << "10 / 2 = " << (result1 ? to_string(*result1) : "错误") << endl;
    cout << "10 / 0 = " << (result2 ? to_string(*result2) : math_error_to_string(result2.error())) << endl;
    cout << "sqrt(9) = " << (result3 ? to_string(*result3) : "错误") << endl;
    cout << "sqrt(-1) = " << (result4 ? to_string(*result4) : math_error_to_string(result4.error())) << endl;
    
    auto file_result = read_file("example.txt");
    if (file_result) {
        cout << "文件内容: " << *file_result << endl;
    } else {
        cout << "文件错误: " << file_result.error().message() << endl;
    }
    
    auto missing_file = read_file("missing.txt");
    if (missing_file) {
        cout << "文件内容: " << *missing_file << endl;
    } else {
        cout << "文件错误: " << missing_file.error().message() << endl;
    }
    cout << endl;
    
    // 4. Monadic 操作
    cout << "4. Monadic 操作:" << endl;
    
    // and_then - 如果包含预期值，则应用函数
    auto chain_result = safe_divide(20, 4)
        .and_then([](int x) { return safe_divide(x, 2); })
        .and_then([](int x) { return expected<int, MathError>(x * 3); });
    
    if (chain_result) {
        cout << "链式操作结果: " << *chain_result << endl;
    } else {
        cout << "链式操作错误: " << math_error_to_string(chain_result.error()) << endl;
    }
    
    // transform - 转换预期值
    auto transformed = safe_divide(10, 2)
        .transform([](int x) { return x * 2.0; });
    
    if (transformed) {
        cout << "转换结果: " << *transformed << endl;
    } else {
        cout << "转换错误: " << math_error_to_string(transformed.error()) << endl;
    }
    
    // or_else - 如果包含错误，则应用函数
    auto recovered = safe_divide(10, 0)
        .or_else([](MathError err) {
            cout << "恢复错误: " << math_error_to_string(err) << endl;
            return expected<int, MathError>(0); // 提供默认值
        });
    
    if (recovered) {
        cout << "恢复后的值: " << *recovered << endl;
    }
    
    // transform_error - 转换错误
    auto transformed_error = safe_divide(10, 0)
        .transform_error([](MathError err) {
            return MathError::Overflow; // 转换错误类型
        });
    
    if (!transformed_error.has_value()) {
        cout << "转换后的错误: " << math_error_to_string(transformed_error.error()) << endl;
    }
    cout << endl;
    
    // 5. 比较操作
    cout << "5. 比较操作:" << endl;
    expected<int, MathError> a = 10;
    expected<int, MathError> b = 20;
    expected<int, MathError> c = unexpected(MathError::DivisionByZero);
    expected<int, MathError> d = 10;
    
    cout << "a == d: " << (a == d) << endl;
    cout << "a == b: " << (a == b) << endl;
    cout << "a == c: " << (a == c) << endl;
    
    // 比较 expected 与值
    cout << "a == 10: " << (a == 10) << endl;
    cout << "b == 10: " << (b == 10) << endl;
    
    // 比较 expected 与错误
    cout << "c == MathError::DivisionByZero: " << (c == unexpected(MathError::DivisionByZero)) << endl;
    cout << endl;
    
    return 0;
}
```

### (3) 高级用法和模板元编程示例

```cpp
#include <iostream>
#include <expected>
#include <vector>
#include <functional>
#include <type_traits>

using namespace std;

// 1. 类型安全的配置解析器
enum class ConfigError {
    InvalidFormat,
    MissingKey,
    TypeMismatch
};

string config_error_to_string(ConfigError err) {
    switch (err) {
        case ConfigError::InvalidFormat: return "Invalid format";
        case ConfigError::MissingKey: return "Missing key";
        case ConfigError::TypeMismatch: return "Type mismatch";
        default: return "Unknown error";
    }
}

class ConfigParser {
private:
    map<string, string> config;
    
public:
    ConfigParser(initializer_list<pair<const string, string>> init) : config(init) {}
    
    expected<int, ConfigError> get_int(const string& key) {
        auto it = config.find(key);
        if (it == config.end()) {
            return unexpected(ConfigError::MissingKey);
        }
        
        try {
            return stoi(it->second);
        } catch (const exception&) {
            return unexpected(ConfigError::TypeMismatch);
        }
    }
    
    expected<double, ConfigError> get_double(const string& key) {
        auto it = config.find(key);
        if (it == config.end()) {
            return unexpected(ConfigError::MissingKey);
        }
        
        try {
            return stod(it->second);
        } catch (const exception&) {
            return unexpected(ConfigError::TypeMismatch);
        }
    }
    
    expected<string, ConfigError> get_string(const string& key) {
        auto it = config.find(key);
        if (it == config.end()) {
            return unexpected(ConfigError::MissingKey);
        }
        return it->second;
    }
};

// 2. 编译时类型检查工具
template<typename T, typename E>
struct is_expected : false_type {};

template<typename T, typename E>
struct is_expected<expected<T, E>, E> : true_type {};

template<typename T, typename E>
inline constexpr bool is_expected_v = is_expected<T, E>::value;

// 3. 使用 expected 实现组合操作
template<typename T, typename E>
expected<vector<T>, E> sequence(const vector<expected<T, E>>& expecteds) {
    vector<T> result;
    for (const auto& exp : expecteds) {
        if (!exp.has_value()) {
            return unexpected(exp.error());
        }
        result.push_back(*exp);
    }
    return result;
}

// 4. 使用 expected 实现事务操作
class Database {
private:
    map<string, int> data;
    
public:
    expected<void, string> begin_transaction() {
        cout << "开始事务" << endl;
        return {};
    }
    
    expected<void, string> commit() {
        cout << "提交事务" << endl;
        return {};
    }
    
    expected<void, string> rollback() {
        cout << "回滚事务" << endl;
        return {};
    }
    
    expected<int, string> get_value(const string& key) {
        auto it = data.find(key);
        if (it == data.end()) {
            return unexpected("Key not found: " + key);
        }
        return it->second;
    }
    
    expected<void, string> set_value(const string& key, int value) {
        data[key] = value;
        cout << "设置值: " << key << " = " << value << endl;
        return {};
    }
};

expected<void, string> perform_transaction(Database& db) {
    auto begin_result = db.begin_transaction();
    if (!begin_result) {
        return begin_result;
    }
    
    // 执行一系列操作
    auto set_result1 = db.set_value("a", 10);
    if (!set_result1) {
        db.rollback();
        return set_result1;
    }
    
    auto set_result2 = db.set_value("b", 20);
    if (!set_result2) {
        db.rollback();
        return set_result2;
    }
    
    // 尝试获取一个不存在的键，这会触发错误
    auto get_result = db.get_value("nonexistent");
    if (!get_result) {
        db.rollback();
        return get_result;
    }
    
    return db.commit();
}

int main() {
    cout << "=== expected 高级用法示例 ===" << endl << endl;
    
    // 1. 配置解析器示例
    cout << "1. 配置解析器示例:" << endl;
    ConfigParser config = {
        {"port", "8080"},
        {"timeout", "30.5"},
        {"hostname", "example.com"},
        {"invalid_int", "abc"}
    };
    
    auto port = config.get_int("port");
    auto timeout = config.get_double("timeout");
    auto hostname = config.get_string("hostname");
    auto missing = config.get_int("missing");
    auto invalid = config.get_int("invalid_int");
    
    cout << "端口: " << (port ? to_string(*port) : config_error_to_string(port.error())) << endl;
    cout << "超时: " << (timeout ? to_string(*timeout) : config_error_to_string(timeout.error())) << endl;
    cout << "主机名: " << (hostname ? *hostname : config_error_to_string(hostname.error())) << endl;
    cout << "缺失的键: " << (missing ? to_string(*missing) : config_error_to_string(missing.error())) << endl;
    cout << "无效的整数: " << (invalid ? to_string(*invalid) : config_error_to_string(invalid.error())) << endl;
    cout << endl;
    
    // 2. 编译时类型检查
    cout << "2. 编译时类型检查:" << endl;
    expected<int, string> exp_int = 42;
    optional<int> opt_int = 42;
    
    cout << "is_expected_v<expected<int, string>, string>: " 
         << is_expected_v<expected<int, string>, string> << endl;
    cout << "is_expected_v<optional<int>, string>: " 
         << is_expected_v<optional<int>, string> << endl;
    cout << endl;
    
    // 3. 序列操作示例
    cout << "3. 序列操作示例:" << endl;
    vector<expected<int, string>> numbers = {
        expected<int, string>(1),
        expected<int, string>(2),
        expected<int, string>(3)
    };
    
    vector<expected<int, string>> numbers_with_error = {
        expected<int, string>(1),
        expected<int, string>(unexpected("Error occurred")),
        expected<int, string>(3)
    };
    
    auto sequence_result = sequence(numbers);
    if (sequence_result) {
        cout << "序列操作成功: ";
        for (int num : *sequence_result) {
            cout << num << " ";
        }
        cout << endl;
    } else {
        cout << "序列操作失败: " << sequence_result.error() << endl;
    }
    
    auto sequence_error = sequence(numbers_with_error);
    if (sequence_error) {
        cout << "序列操作成功: ";
        for (int num : *sequence_error) {
            cout << num << " ";
        }
        cout << endl;
    } else {
        cout << "序列操作失败: " << sequence_error.error() << endl;
    }
    cout << endl;
    
    // 4. 事务操作示例
    cout << "4. 事务操作示例:" << endl;
    Database db;
    auto transaction_result = perform_transaction(db);
    
    if (transaction_result) {
        cout << "事务执行成功" << endl;
    } else {
        cout << "事务执行失败: " << transaction_result.error() << endl;
    }
    cout << endl;
    
    return 0;
}
```

### (4) 注意事项和最佳实践

#### 注意事项：

1. **性能考虑**：`expected` 的大小等于 `max(sizeof(T), sizeof(E)) + sizeof(bool)`，可能比 `optional` 大
2. **异常安全**：使用 `value()` 方法访问值时，如果 `expected` 包含错误会抛出 `bad_expected_access` 异常
3. **错误类型选择**：选择合适的错误类型，可以是枚举、字符串、`std::error_code` 或自定义类型
4. **默认构造**：`expected` 的默认构造函数要求 `T` 可默认构造，否则需要使用 `std::unexpect` 标记

#### 最佳实践：
1. **优先使用 `expected` 而不是异常**：对于可恢复的错误，`expected` 提供了更明确的错误处理方式
2. **使用 Monadic 操作**：利用 `and_then`、`transform`、`or_else` 和 `transform_error` 进行链式处理
3. **提供有意义的错误信息**：错误类型应该包含足够的信息来诊断和解决问题
4. **结合 `std::error_code`**：对于系统错误，使用 `std::error_code` 作为错误类型可以提供丰富的错误信息
5. **使用结构化绑定**：C++17 的结构化绑定可以与 `expected` 很好地配合使用

#### 适用场景：
1. **可能失败的操作**：如文件操作、网络请求、解析操作等
2. **错误需要详细信息的场景**：`expected` 可以携带详细的错误信息，而不仅仅是成功/失败
3. **避免异常的开销**：在性能敏感的代码中，使用 `expected` 可以避免异常处理的开销
4. **函数式编程风格**：Monadic 操作支持函数式编程风格，使代码更简洁和表达力强
5. **API 设计**：使接口更清晰，明确表示可能的结果和错误

### (5) 总结

`std::expected` 是 C++23 引入的一个重要特性，它扩展了 `std::optional` 的概念，不仅能够表示值的存在与否，还能携带详细的错误信息。与 `std::optional` 相比，`std::expected` 具有以下优势：

1. **更丰富的错误处理**：可以携带详细的错误信息，而不仅仅是表示值缺失
2. **更明确的语义**：明确区分成功值和错误值，使代码更清晰
3. **Monadic 操作**：提供了丰富的函数式编程操作，使错误处理更简洁
4. **类型安全**：编译器可以检查是否正确处理了成功和错误情况

#### 与 `std::optional` 的选择：

- 使用 `std::optional`：当只需要表示值可能存在或不存在，不需要额外的错误信息时
- 使用 `std::expected`：当操作可能失败，并且需要携带详细的错误信息时

#### 底层实现差异：

- `std::optional`：使用联合体存储值或占位符，加上一个布尔标志
- `std::expected`：使用联合体存储值或错误，加上一个布尔标志

`std::expected` 是现代 C++ 错误处理的重要工具，它提供了一种类型安全、表达力强的方式来处理可能失败的操作。通过结合 Monadic 操作和丰富的错误类型，可以构建出既健壮又易于维护的代码。

# 底层实现

## tuple

```c
// MSVC递归
template <>
class tuple<> { // empty tuple
};
template <class _This, class... _Rest>
class tuple<_This, _Rest...> : private tuple<_Rest...> { // recursive tuple definition
    using _This_type = _This;
    using _Mybase    = tuple<_Rest...>;
    _Tuple_val<_This> _Myfirst; // the stored element
};

// gcc索引接口
template<size_t _Idx, typename... _Elements>
struct _Tuple_impl;

template<>
class tuple<>{
};
  /// Primary class template, tuple
template<typename... _Elements>
class tuple : public _Tuple_impl<0, _Elements...>
{
    using _Inherited = _Tuple_impl<0, _Elements...>;
};
```

好的，我们来详细解析现代C++中 `std::tuple` 的底层实现原理，并对比 MSVC 和 GCC (libstdc++) 的实现差异。

### 核心原理：如何存储不同类型

`std::tuple` 能够存储不同类型数据的核心原理是 **递归模板继承（Recursive Template Inheritance）** 和 **编译期计算（Compile-time Computation）**。

1.  **类型安全与内存布局**： `tuple` 不是一种动态的、类型擦除的容器（如 `void*` 数组）。相反，它在编译期就完全确定了所有成员的类型和数量。每个成员都被存储在一个独立的、具有特定类型的非静态数据成员中。这些成员在内存中的布局通常是连续的（但可能存在对齐带来的填充），这与 `struct { T1 first; T2 second; T3 third; }` 类似。

2.  **编译期索引访问**： 通过 `std::get<N>(my_tuple)` 访问元素不是在运行时计算偏移量。编译器在编译时就知道第 `N` 个元素的类型和它在继承链或数据结构中的确切位置，并直接生成访问该特定成员的代码。

---

### MSVC 实现分析（递归继承模式）

微软MSVC标准库的实现采用了经典的**递归继承**模式。你提供的代码片段非常准确地描绘了其核心结构。

```cpp
// 基础 case：空 tuple 的特化
template <>
class tuple<> { // empty tuple
};

// 递归 case：将元组分解为“第一个元素”和“剩余元素包”
template <class _This, class... _Rest>
class tuple<_This, _Rest...> : private tuple<_Rest...> { // 递归继承自“剩余元素”的元组
    using _Mybase = tuple<_Rest...>;
    _Tuple_val<_This> _Myfirst; // 存储第一个元素
};
```

**工作原理：**

1.  **递归继承**： `tuple<int, double, std::string>` 的继承关系如下：
    *   `tuple<int, double, std::string>` **继承自** `tuple<double, std::string>`
    *   `tuple<double, std::string>` **继承自** `tuple<std::string>`
    *   `tuple<std::string>` **继承自** `tuple<>`
    *   `tuple<>` 是空基类。

2.  **成员分布**： 每个层级的派生类都存储着它自己的“第一个”元素。
    *   `tuple<std::string>` 层存储 `std::string` 元素。
    *   `tuple<double, std::string>` 层存储 `double` 元素。
    *   `tuple<int, double, std::string>` 层存储 `int` 元素。

3.  **内存布局**： 由于标准布局类（Standard-layout class）的规则和空基类优化（EBCO），所有元素在内存中通常是**从基类到派生类、从后往前**紧密排列的。一个 `tuple<int, double, std::string>` 在内存中的顺序可能是：`std::string` -> `double` -> `int`。

4.  **元素访问 (`get<N>`)**： 这是一个编译时的递归过程。
    ```cpp
    // get 的实现核心（概念简化）
    template <size_t _Index, class _Tuple>
    auto _Get_impl(_Tuple& _Tpl) {
        if constexpr (_Index == 0) {
            // 当前层级存储着所需的元素
            return _Tpl._Myfirst;
        } else {
            // 向上转型到基类（即“剩余元素”组成的tuple），然后查找 Index-1
            return _Get_impl<_Index - 1>(static_cast<_Tuple::_Mybase&>(_Tpl));
        }
    }
    ```
    对于 `get<1>(my_tuple)`，编译器会：
    *   在 `tuple<int, double, string>` 层发现 `1 != 0`，于是递归到其基类 `tuple<double, string>`。
    *   在 `tuple<double, string>` 层发现 `0 == 0`，返回该层存储的 `double` 成员。

**优点：** 实现相对直观，符合人们对递归模板的经典理解。

---

### GCC (libstdc++) 实现分析（索引接口模式）

GCC的libstdc++实现采用了**递归复合**而非递归继承，并使用了一个**索引接口**类模板 (`_Tuple_impl`) 来管理元素。这种方式更注重将实现细节与接口分离。

```cpp
// 基础 case：空 tuple 的特化
template<>
class tuple<> {};

// 主模板：tuple 继承自 _Tuple_impl
template<typename... _Elements>
class tuple : public _Tuple_impl<0, _Elements...> // 从索引 0 开始
{
    using _Inherited = _Tuple_impl<0, _Elements...>;
};
```

**`_Tuple_impl` 是真正的核心：**

```cpp
// _Tuple_impl 的定义
template<size_t _Idx, typename... _Elements>
struct _Tuple_impl;

// _Tuple_impl 的偏特化：处理至少一个元素的情况
template<size_t _Idx, typename _Head, typename... _Tail>
struct _Tuple_impl<_Idx, _Head, _Tail...> : public _Tuple_impl<_Idx + 1, _Tail...>
{
    _Head _M_head; // 存储当前索引对应的元素

    // ... 成员函数 ...
};

// _Tuple_impl 的终止特化：处理索引超出范围（元素包为空）
template<size_t _Idx>
struct _Tuple_impl<_Idx> {
    // 无数据成员
};
```

**工作原理：**

1.  **递归复合与继承**： `tuple<int, double, std::string>` 的继承关系如下：
    *   `tuple<int, double, std::string>` **继承自** `_Tuple_impl<0, int, double, std::string>`
    *   `_Tuple_impl<0, int, double, string>` **继承自** `_Tuple_impl<1, double, std::string>`
    *   `_Tuple_impl<1, double, std::string>` **继承自** `_Tuple_impl<2, std::string>`
    *   `_Tuple_impl<2, std::string>` **继承自** `_Tuple_impl<3>`（空基类）

2.  **成员分布**： 每个 `_Tuple_impl<_Idx, Head, Tail...>` 层级存储着它对应索引 `_Idx` 的元素 `_Head`。
    *   `_Tuple_impl<2, std::string>` 存储 `std::string` 元素。
    *   `_Tuple_impl<1, double, std::string>` 存储 `double` 元素。
    *   `_Tuple_impl<0, int, double, std::string>` 存储 `int` 元素。

3.  **内存布局**： 与MSVC类似，得益于EBCO，元素也是紧密排列的。但顺序是**从高索引到低索引、从基类到派生类**。一个 `tuple<int, double, std::string>` 在内存中的顺序可能是：`std::string` (索引2) -> `double` (索引1) -> `int` (索引0)。这与MSVC的结果是相同的。

4.  **元素访问 (`get<N>`)**: 直接利用编译期索引和继承关系。
    ```cpp
    // get 的实现核心（概念简化）
    template <size_t __i, typename... _Elements>
    auto& get(tuple<_Elements...>& __t) noexcept {
        // 直接转换到存储该元素的 _Tuple_impl 层级
        // _Tuple_impl<__i, ...> 中正好存储着我们要找的元素
        return static_cast<_Tuple_impl<__i, _Elements...>&>(__t)._M_head;
    }
    ```
    编译器知道 `tuple<int, double, string>` 继承自 `_Tuple_impl<0, int, double, string>`，而后者又继承自 `_Tuple_impl<1, double, string>`。当调用 `get<1>(t)` 时，它直接将 `t` 向上转换（`static_cast`）到 `_Tuple_impl<1, double, string>` 这个基类，然后访问其 `_M_head` 成员。**这是一个直接的转换，没有运行时递归开销。**

**优点：**
*   **接口清晰**： `tuple` 类本身非常干净，只是继承自实现类。
*   **访问效率高**： `get<N>` 通常可以编译为一次简单的指针偏移计算，因为对象布局在编译期是完全确定的。虽然MSVC的递归方式也能被优化，但GCC的这种设计更直接地暴露了元素的位置。

---

### MSVC 与 GCC 实现对比总结

| 特性              | MSVC (递归继承)                                              | GCC (索引接口/递归复合)                                      |
| :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **核心模式**      | **递归继承**：`tuple<A,B,C>` : private `tuple<B,C>`          | **递归复合+继承**：`tuple<A,B,C>` : public `_Tuple_impl<0, A,B,C>` |
| **实现主体**      | `tuple` 模板自身                                             | 辅助模板 `_Tuple_impl`                                       |
| **元素存储**      | 在每个 `tuple<Rest...>` 层级中的 `_Myfirst` 成员             | 在每个 `_Tuple_impl<Idx, Head, Tail...>` 层级中的 `_M_head` 成员 |
| **`get<N>` 原理** | **递归向下转型**：通过不断向基类转型并递减索引直到0          | **直接转型**：直接向上转型到包含第N个元素的 `_Tuple_impl<N, ...>` 基类 |
| **内存布局**      | 基本相同：元素从后往前（从最后一个到第一个）紧密排列，依赖EBCO | 基本相同：元素从后往前（从最后一个到第一个）紧密排列，依赖EBCO |
| **设计哲学**      | 更“传统”的元组实现方式，概念简单                             | 更“现代”，将接口与实现分离，**编译期索引的意识更强**         |

**关键区别：**
最大的区别在于 **`get<N>` 的访问策略**。MSVC的策略是“递归查找”，而GCC的策略是“直接定位”。虽然在优化的Release构建中，性能可能没有差异（编译器会优化掉所有递归），但GCC的设计在概念上更清晰，并且可能与编译器的内部机制结合得更好。

**结论：**
两种实现都完美地实现了C++标准要求的 `tuple` 功能，并且在内存效率和运行时性能上都是最优的。它们都深度依赖于模板元编程和空基类优化。GCC (libstdc++) 的实现通常被认为更现代、更清晰，它将存储和索引的逻辑完全委托给了 `_Tuple_impl` 这个辅助类，使得 `tuple` 主类非常简洁。而MSVC的实现则更加直接地将递归关系体现在 `tuple` 自身的继承体系上。对于普通开发者来说，这种差异是完全透明的。
