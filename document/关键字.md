# [`restrict`](https://cppreference.cn/w/c/language/restrict)

**在 ISO C++ 标准中，** `restrict` 是一个源自 C 语言（从 C99 标准开始）的关键字。

然而，主流的 C++ 编译器都提供了功能等价的、非标准的扩展来满足这一需求。因此，这个问题通常是在“如何使用 C++ 实现 C 中 `restrict` 的效果”的语境下被讨论的。

---

## 1. `restrict` 的核心思想与作用

`restrict` 是一个指针限定符（type qualifier）。它向编译器做出一个**承诺**：在该指针的生命周期内，**只有它本身（或者直接由它衍生的指针，如 `p+1`）是用于访问其所指向内存区域的唯一方式**。

换句话说，它告诉编译器：“我指向的这块内存，不会有其他任何指针来‘捣乱’（进行读写操作）。你可以放心地针对这一点进行激进的优化。”

**主要作用：解决指针别名问题，启用编译器优化。**

*   **指针别名**：指两块或多块不同的指针指向（或重叠于）同一片内存区域。
*   **问题所在**：当编译器看到通过指针 `a` 写内存，又通过指针 `b` 读内存时，由于无法确定 `a` 和 `b` 是否指向同一位置（即是否存在别名），编译器必须保守地假设它们**可能**指向同一位置。这意味着它不能将读写操作的顺序进行重排优化，也不能将变量缓存在寄存器中，必须频繁地、按代码顺序写回内存，导致性能下降。
*   **`restrict` 的解决方案**：程序员通过 `restrict` 关键字向编译器保证“**我承诺这两个指针不会指向重叠的内存！**”。编译器信任这个承诺，从而可以生成更高效的代码。

---

## 2. C++ 中的等价物（编译器扩展）

由于 C++ 标准没有定义 `restrict`，各大编译器提供了自己的版本：

1.  **GCC / Clang**: 使用 `__restrict__` 或 `__restrict`
2.  **Microsoft Visual C++**: 使用 `__restrict`

从 C++11 开始，你也可以考虑使用标准属性 **`[[gnu::restrict]]`**，但这仍然是编译器相关的，其可移植性依赖于其他编译器是否也选择支持这个 GNU 属性。

---

## 3. 代码示例：对比有无 `restrict` 的区别

让我们看一个经典的例子：计算两个向量的点积。

### 示例 1：没有使用 `restrict`（保守编译）

```cpp
void dot_product(const double* a, const double* b, double* result, size_t n) {
    double sum = 0.0;
    for (size_t i = 0; i < n; ++i) {
        sum += a[i] * b[i];
    }
    *result = sum;
}

// 调用示例
double arr1[1000] = {...};
double arr2[1000] = {...};
double res;

dot_product(arr1, arr2, &res, 1000); // 标准情况，没问题
// 但是，如果出现下面这种调用呢？
// dot_product(arr1, arr1, &res, 1000); // a 和 b 是同一个数组！存在别名！
```
**编译器视角**：编译器看到 `a[i]` 和 `b[i]` 的读写操作。它必须考虑最坏情况——`a` 和 `b` 可能指向同一数组（甚至是 `result` 可能指向 `a` 或 `b` 的某个元素）。因此，它不敢做任何激进的优化：
*   不能在循环开始前将 `a[i]` 和 `b[i]` 提前加载到寄存器。
*   每次写入 `sum` 后，必须确保内存中的值是最新的，因为 `a` 或 `b` 可能会修改 `sum` 所在的内存（虽然这个例子中不会，但编译器不知道）。
*   循环无法被充分向量化（SIMD）。

### 示例 2：使用 `__restrict__`（允许激进优化）

```cpp
// 使用 GCC/Clang 的扩展
void dot_product_optimized(const double* __restrict__ a,
                          const double* __restrict__ b,
                          double* __restrict__ result,
                          size_t n) {
    double sum = 0.0;
    for (size_t i = 0; i < n; ++i) {
        sum += a[i] * b[i];
    }
    *result = sum;
}
```
**编译器视角**：程序员已经用 `__restrict__` 承诺了 `a`、`b`、`result` 这三者指向的内存绝无重叠。编译器可以放心大胆地优化：
*   **循环展开和向量化**：编译器可以使用 SSE/AVX 指令一次处理 4 个或 8 个 double 值，极大提升性能。
*   **寄存器缓存**：可以将 `a[i]` 和 `b[i]` 的值长时间保留在 CPU 寄存器中，减少访问内存的次数。
*   **指令重排**：可以重新安排计算顺序以更好地利用 CPU 的流水线。

**生成的汇编代码差异**：如果你在编译器资源管理器（如 [Compiler Explorer](https://godbolt.org/)）上对比这两个函数，会发现 `dot_product_optimized` 的汇编代码中包含了 `vmulpd`、`vaddpd` 等 SIMD 指令，而第一个函数则可能是一串冗长而保守的标量指令。

### **非常重要的警告**

使用 `restrict` 是在和编译器做一个**契约**。如果你违背了这个契约（即指针确实存在别名），将会导致**未定义行为**。程序可能会产生错误的结果，甚至崩溃。

```cpp
double my_array[10] = {...};

// 这是错误的！违背了 restrict 承诺！
dot_product_optimized(my_array, my_array, &some_result, 10);
```
上面的错误调用会导致未定义行为，因为 `a` 和 `b` 都被限定为 `__restrict__`，但它们明显指向了同一块内存。

---

## 4. 常见应用场景

`restrict` 主要用于对性能有极致要求的底层代码中：

1.  **数值计算库**：如 BLAS、LAPACK 或其衍生库（如 Eigen、Armadillo）。矩阵和向量运算函数是使用 `restrict` 的绝佳场合。
2.  **图像/音频处理**：处理像素缓冲区或音频采样时，不同的缓冲区（如 RGB 通道）通常是不重叠的。
3.  **编译器自身和标准库实现**：在实现 `memcpy`、`memmove` 等函数时，`memcpy` 的源和目的指针被假定为不重叠（所以可以用 `restrict` 来优化），而 `memmove` 则必须处理重叠情况。
4.  **游戏引擎和物理仿真**：大量的 3D 向量、四元数、矩阵运算。
5.  **任何处理大型数组且循环密集的算法**。

## 5. 标准库提供——[std::valarray](./numeric.md)

## 总结

| 特性             | 描述                                                         |
| :--------------- | :----------------------------------------------------------- |
| **本质**         | 一个向编译器做出的关于指针无别名的**承诺**，用于启用优化。   |
| **C++ 中的状态** | **非标准**。但所有主流编译器都通过扩展提供支持：GCC/Clang 的 `__restrict__`，MSVC 的 `__restrict`。 |
| **好处**         | 允许编译器进行激进的优化，如循环向量化、指令重排、寄存器缓存，从而大幅提升性能。 |
| **风险**         | 如果违背承诺（指针实际存在别名），会导致**未定义行为**，是程序中的一个严重错误。 |
| **适用场景**     | 性能至关重要的底层计算库、数据处理、媒体处理等，处理大型非重叠数据块的循环。 |

**使用建议**：
*   只在性能分析（Profiling）确定瓶颈后再考虑使用。
*   仅在你能 100% 确定指针绝无别名时使用。
*   在函数注释中明确写明指针不能重叠的约定。
*   注意其编译器相关的特性，如果追求可移植性，可能需要用宏来包装不同编译器的关键字。

# `inline`

## 1. 内联命名空间（C++20）

在C++中，`inline`关键字用于命名空间是C++11引入的特性，它允许将内联命名空间中的内容视为其父命名空间的一部分。这主要用于版本控制和ABI兼容性。

## 作用与用途

1. **版本控制**：允许库开发者提供多个版本API，同时保持向后兼容
2. **透明嵌套**：内联命名空间中的成员可以直接被父命名空间访问
3. **ABI兼容性**：帮助管理不同版本的二进制接口

## 示例代码

```cpp
#include <iostream>
#include <string>

// 模拟一个反射库的不同版本
namespace reflect::inline v1_2_5 {
    void serialize(const std::string& data) {
        std::cout << "使用v1.2.5序列化: " << data << std::endl;
    }
    
    std::string deserialize() {
        return "v1.2.5反序列化数据";
    }
}

namespace reflect::v1_2_4 {
    void serialize(const std::string& data) {
        std::cout << "使用v1.2.4序列化: " << data << std::endl;
    }
    
    std::string deserialize() {
        return "v1.2.4反序列化数据";
    }
}

int main() {
    // 可以直接使用 reflect:: 访问内联命名空间中的内容
    reflect::serialize("测试数据");
    std::cout << reflect::deserialize() << std::endl;
    
    // 如果需要使用旧版本，需要明确指定版本
    reflect::v1_2_4::serialize("测试数据");
    std::cout << reflect::v1_2_4::deserialize() << std::endl;
    
    return 0;
}
```

## 更完整的示例

```cpp
#include <iostream>
#include <string>

// 主命名空间
namespace reflect {
    // 内联命名空间 - 当前默认版本
    inline namespace v1_2_5 {
        class Serializer {
        public:
            virtual void serialize(const std::string& data) {
                std::cout << "v1.2.5序列化: " << data << std::endl;
            }
            
            virtual std::string deserialize() {
                return "v1.2.5反序列化数据";
            }
        };
    }
    
    // 旧版本命名空间
    namespace v1_2_4 {
        class Serializer {
        public:
            void serialize(const std::string& data) {
                std::cout << "v1.2.4序列化: " << data << std::endl;
            }
            
            std::string deserialize() {
                return "v1.2.4反序列化数据";
            }
        };
    }
    
    // 新版本命名空间（尚未设为内联）
    namespace v2_0_0 {
        class Serializer {
        public:
            virtual void serialize(const std::string& data, int format = 0) {
                std::cout << "v2.0.0序列化 (格式" << format << "): " << data << std::endl;
            }
            
            virtual std::string deserialize(int format = 0) {
                return "v2.0.0反序列化数据 (格式" + std::to_string(format) + ")";
            }
        };
    }
}

int main() {
    // 使用当前默认版本（内联命名空间）
    reflect::Serializer current;
    current.serialize("默认数据");
    std::cout << current.deserialize() << std::endl;
    
    // 使用旧版本
    reflect::v1_2_4::Serializer old;
    old.serialize("旧版本数据");
    std::cout << old.deserialize() << std::endl;
    
    // 使用新版本（尚未设为默认）
    reflect::v2_0_0::Serializer newer;
    newer.serialize("新版本数据", 1);
    std::cout << newer.deserialize(1) << std::endl;
    
    return 0;
}
```

## 使用场景说明

1. **库版本升级**：当更新库时，可以将新版本设为内联命名空间，旧代码无需修改即可使用新实现
2. **ABI兼容性**：保持二进制兼容性，同时提供新功能
3. **实验性功能**：可以将实验性API放在非内联命名空间中，稳定后再移至内联命名空间

当使用`namespace reflect::inline v1_2_5`语法时，表示`v1_2_5`是`reflect`命名空间的内联命名空间，其中的内容可以直接通过`reflect::`访问，而不需要指定`v1_2_5`子命名空间。

# `explicit`

## 1. explicit(bool) （C++20）

在编译时有条件地选择构造函数是否为 `explicit`。`explicit(true)` 与指定 `explicit` 相同。

```C
struct foo {
  // 指定非整数类型（字符串、浮点数等）需要显式构造。
  template <typename T>
  explicit(!std::is_integral_v<T>) foo(T) {}
};

foo a = 123; // OK
foo b = "123"; // 错误：显式构造函数不是候选（explicit 指定符评估为 true）
foo c {"123"}; // OK
```



# `constexpr`、`consteval`(C++20)和 `constinit`(C++20)

在 C++20 中，编译期计算能力得到了显著增强，引入了 `consteval` 和 `constinit` 关键字来补充现有的 `constexpr`。这三个关键字共同构成了 C++ 编译期计算的核心机制。

## 1. `constexpr` - 常量表达式

### 功能说明
`constexpr` 用于声明可以在编译时求值的表达式、变量或函数。它既可以用于编译期上下文，也可以用于运行期上下文。

### 主要用途
- 编译期计算和优化
- 替代宏定义常量
- 在模板元编程中提供更清晰的语法

### 示例代码

```cpp
#include <iostream>
#include <array>

// 1. constexpr 变量
constexpr int max_size = 100; // 编译期常量

// 2. constexpr 函数 - 可以在编译期或运行期调用
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

// 3. constexpr 构造函数和类
class Point {
public:
    constexpr Point(double x, double y) : x_(x), y_(y) {}
    
    constexpr double x() const { return x_; }
    constexpr double y() const { return y_; }
    
    constexpr void set_x(double x) { x_ = x; } // C++14 起可以修改成员
    
private:
    double x_, y_;
};

int main() {
    // 编译期计算
    constexpr int fact_5 = factorial(5); // 在编译时计算
    std::cout << "5! = " << fact_5 << std::endl;
    
    // 编译期创建的数组大小
    std::array<int, factorial(5)> arr; // 使用编译期计算的值作为模板参数
    
    // 编译期创建的对象
    constexpr Point p(1.0, 2.0);
    std::cout << "Point: (" << p.x() << ", " << p.y() << ")" << std::endl;
    
    // 运行期调用 (仍然有效)
    int runtime_value = 6;
    std::cout << "Runtime factorial: " << factorial(runtime_value) << std::endl;
    
    return 0;
}
```

## 2. `consteval` - 立即函数 (C++20)

### 功能说明
`consteval` 用于声明**必须在编译时执行**的函数（立即函数）。如果 `consteval` 函数不能在编译时求值，会导致编译错误。

### 与 `constexpr` 的区别
- `constexpr` 函数：可以在编译期或运行期调用
- `consteval` 函数：必须在编译期调用

### 主要用途
- 确保某些计算绝对在编译期完成
- 防止运行时代码膨胀
- 强制编译期验证

### 示例代码

```cpp
#include <iostream>
#include <type_traits>

// consteval 函数 - 必须在编译期执行
consteval int compile_time_square(int n) {
    return n * n;
}

// 编译期类型特性检查
consteval bool is_integral_constant(auto value) {
    return requires { typename std::remove_cvref_t<decltype(value)>::value_type; };
}

// 编译期字符串操作 (简单示例)
consteval size_t string_length(const char* str) {
    size_t length = 0;
    while (str[length] != '\0') {
        ++length;
    }
    return length;
}

int main() {
    // 正确使用：编译期调用
    constexpr int result = compile_time_square(5);
    std::cout << "5 squared = " << result << std::endl;
    
    // 编译期字符串长度计算
    constexpr size_t len = string_length("Hello");
    std::cout << "String length: " << len << std::endl;
    
    // 编译期类型检查
    constexpr bool check1 = is_integral_constant(std::integral_constant<int, 42>{});
    constexpr bool check2 = is_integral_constant(42); // 普通整数，不是integral_constant
    std::cout << "Check1: " << check1 << ", Check2: " << check2 << std::endl;
    
    // 错误示例（取消注释会导致编译错误）：
    // int runtime_value = 10;
    // int bad_result = compile_time_square(runtime_value); // 错误：runtime_value不是编译期常量
    
    return 0;
}
```

## 3. `constinit` - 编译期初始化 (C++20)

### 功能说明
`constinit` 确保变量**在编译时进行初始化**，但不保证变量的不可变性（不像 `const` 或 `constexpr`）。

### 主要用途
- 解决静态初始化顺序问题（Static Initialization Order Fiasco）
- 确保全局和静态变量在编译期初始化
- 提高程序启动性能

### 示例代码

```cpp
#include <iostream>
#include <array>

// 1. constinit 全局变量
constinit int global_initialized = 42; // 编译期初始化

// 2. 使用 constexpr 函数初始化
constexpr int compute_value() {
    return 10 * 10;
}

constinit int computed_value = compute_value(); // 编译期初始化

// 3. 解决静态初始化顺序问题
struct Config {
    int value;
    const char* name;
};

// 使用 constinit 确保在编译期初始化
constinit Config global_config = {100, "default"};

// 4. constinit 用于静态局部变量
void process_data() {
    static constinit int call_count = 0; // 编译期初始化，避免运行时开销
    ++call_count;
    std::cout << "Called " << call_count << " times" << std::endl;
}

// 5. 注意：constinit 不意味着常量
constinit int mutable_value = 100; // 可以修改

int main() {
    std::cout << "Global initialized: " << global_initialized << std::endl;
    std::cout << "Computed value: " << computed_value << std::endl;
    std::cout << "Config: " << global_config.value << ", " << global_config.name << std::endl;
    
    // 可以修改 constinit 变量（除非同时声明为 const）
    mutable_value = 200;
    std::cout << "Modified value: " << mutable_value << std::endl;
    
    // 多次调用演示静态局部变量
    process_data();
    process_data();
    process_data();
    
    return 0;
}
```

## 三者的区别与联系

| 特性           | `constexpr`                | `consteval`              | `constinit`                |
| -------------- | -------------------------- | ------------------------ | -------------------------- |
| **用途**       | 编译期可求值的表达式       | 必须在编译期执行的函数   | 编译期初始化的变量         |
| **可变性**     | 默认不可变（可加 mutable） | 函数特性，不涉及可变性   | 变量可修改（除非加 const） |
| **应用对象**   | 变量、函数、构造函数       | 仅函数                   | 仅变量                     |
| **运行期使用** | 可以                       | 不可以                   | 可以（变量可在运行期修改） |
| **主要优势**   | 灵活，兼容编译期和运行期   | 强制编译期执行，确保优化 | 解决静态初始化顺序问题     |

## 综合应用示例

```cpp
#include <iostream>
#include <array>

// consteval 函数：强制编译期计算
consteval auto create_lookup_table() {
    std::array<int, 10> table{};
    for (int i = 0; i < 10; ++i) {
        table[i] = i * i; // 平方表
    }
    return table;
}

// constinit 确保编译期初始化
constinit auto square_table = create_lookup_table();

// constexpr 函数：可在编译期或运行期使用
constexpr int get_square(int index) {
    if (index >= 0 && index < 10) {
        return square_table[index];
    }
    return -1;
}

int main() {
    // 编译期使用
    constexpr int square_5 = get_square(5);
    std::cout << "5 squared = " << square_5 << std::endl;
    
    // 运行期使用
    for (int i = 0; i < 10; ++i) {
        std::cout << i << "² = " << get_square(i) << std::endl;
    }
    
    // 修改 constinit 变量（演示可变性）
    square_table[0] = 999; // 允许修改
    std::cout << "Modified first element: " << square_table[0] << std::endl;
    
    return 0;
}
```

## 最佳实践建议

1. **优先使用 `constexpr`**：对于大多数编译期计算需求
2. **需要强制编译期执行时使用 `consteval`**：当必须确保计算在编译期完成时
3. **解决初始化顺序问题时使用 `constinit`**：对于全局和静态变量
4. **组合使用**：`consteval` 函数可以返回 `constexpr` 值，`constinit` 变量可以用 `consteval` 函数初始化
5. **注意兼容性**：`consteval` 和 `constinit` 是 C++20 特性，确保你的编译器支持

这三个关键字共同提供了强大的编译期计算和初始化控制能力，是现代 C++ 高性能编程的重要组成部分。