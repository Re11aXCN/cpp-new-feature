# 头文件

```c
#include <new>
#include <memory>
#include <memory_resource>
#include <scoped_allocator>
```



# 一、`<new>`

## 1. `<new>` 头文件功能详细说明

### 1. 异常类

| 类名                   | 描述                                 |
| ---------------------- | ------------------------------------ |
| `bad_alloc`            | 当内存分配失败时抛出的异常           |
| `bad_array_new_length` | 当尝试分配无效长度的数组时抛出的异常 |

### 2. 类型定义

| 类型          | 描述                       |
| ------------- | -------------------------- |
| `new_handler` | new 处理函数的函数指针类型 |
| `align_val_t` | 用于传递对齐要求的枚举类型 |

### 3. 标签类

| 标签                  | 描述                                                  |
| --------------------- | ----------------------------------------------------- |
| `nothrow_t`           | 用于选择非抛出分配函数的标签                          |
| `destroying_delete_t` | 用于在 operator delete 的销毁删除重载中进行选择的标签 |

### 4. 常量

| 常量                                      | 描述                   |
| ----------------------------------------- | ---------------------- |
| `hardware_destructive_interference_size`  | 避免伪共享的最小偏移量 |
| `hardware_constructive_interference_size` | 促进真共享的最大偏移量 |

### 5. 函数

| 函数                | 描述                                         |
| ------------------- | -------------------------------------------- |
| `operator new`      | 分配单个对象的内存                           |
| `operator new[]`    | 分配数组的内存                               |
| `operator delete`   | 释放单个对象的内存                           |
| `operator delete[]` | 释放数组的内存                               |
| `set_new_handler`   | 注册新的 new 处理函数                        |
| `get_new_handler`   | 获取当前的 new 处理函数                      |
| `launder`           | 指针优化屏障，用于处理对象生命周期和内存重用 |

## 2. 功能详细说明

### 1. 内存分配和释放
- **基本分配**: 使用 `new` 和 `delete` 进行内存分配和释放
- **数组分配**: 使用 `new[]` 和 `delete[]` 进行数组内存分配和释放
- **非抛出分配**: 使用 `nothrow` 版本的 `new`，在分配失败时返回 `nullptr` 而不是抛出异常

### 2. 异常处理
- **bad_alloc**: 当内存分配失败时抛出
- **bad_array_new_length**: 当尝试分配无效长度的数组时抛出

### 3. 对齐分配 (C++17)
- 使用 `align_val_t` 和对应的 `operator new`/`operator delete` 重载进行对齐内存分配

### 4. 放置 new
- 在已分配的内存上构造对象，不进行实际的内存分配

### 5. new_handler
- 当 `operator new` 无法满足内存请求时调用的函数
- 可以使用 `set_new_handler` 设置自定义处理函数

### 6. std::launder (C++17)

blog：https://cppreference.cn/w/cpp/utility/launder

cpprefence：https://cppreference.cn/w/cpp/utility/launder

- 用于处理对象生命周期和内存重用的指针优化屏障
- 当在相同内存位置创建新对象时，用于获取指向新对象的有效指针

### 7. 硬件干扰大小 (C++17)
- 提供关于 CPU 缓存行大小的信息
- 用于优化多线程程序中的数据布局，避免伪共享

### 8. 销毁删除操作符 (C++20)
- 允许在 `operator delete` 中手动调用析构函数
- 提供更灵活的对象销毁和内存释放控制

## 3. 使用示例

下面是展示 C++ `<new>` 头文件中所有主要功能的完整示例：

```cpp
#include <iostream>
#include <new>
#include <cstdlib>
#include <cstring>

// 自定义 new_handler 函数
void my_new_handler() {
    std::cout << "自定义 new_handler: 内存分配失败，尝试释放一些内存...\n";
    // 这里可以尝试释放一些内存，然后重试分配
    // 如果无法释放足够内存，应该抛出 bad_alloc 或终止程序
    throw std::bad_alloc();
}

// 用于展示 destroying_delete 的类
class MyClass {
public:
    MyClass(int val) : value(val) {
        std::cout << "MyClass 构造函数，值: " << value << "\n";
    }
    
    ~MyClass() {
        std::cout << "MyClass 析构函数，值: " << value << "\n";
    }
    
    // C++20 销毁删除操作符
#if __cplusplus >= 202002L
    void operator delete(MyClass* ptr, std::destroying_delete_t) {
        std::cout << "使用销毁删除操作符\n";
        ptr->~MyClass(); // 手动调用析构函数
        ::operator delete(ptr); // 释放内存
    }
#endif
    
    void show() const {
        std::cout << "值: " << value << "\n";
    }
    
private:
    int value;
};

int main() {
    std::cout << "=== C++ <new> 头文件功能演示 ===\n\n";
    
    // 1. 设置和获取 new_handler
    std::cout << "1. new_handler 演示:\n";
    std::new_handler old_handler = std::set_new_handler(my_new_handler);
    std::cout << "之前的 new_handler: " << (old_handler ? "有" : "无") << "\n";
    std::cout << "当前的 new_handler: " << (std::get_new_handler() ? "有" : "无") << "\n\n";
    
    // 恢复原来的 new_handler
    std::set_new_handler(old_handler);
    
    // 2. 基本的 new 和 delete 操作符
    std::cout << "2. 基本的 new 和 delete 操作符:\n";
    int* ptr = new int(42);
    std::cout << "分配的内存值: " << *ptr << "\n";
    delete ptr;
    std::cout << "\n";
    
    // 3. 数组的 new 和 delete
    std::cout << "3. 数组的 new 和 delete:\n";
    int* arr = new int[5]{1, 2, 3, 4, 5};
    std::cout << "数组元素: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
    delete[] arr;
    std::cout << "\n";
    
    // 4. nothrow 版本的 new
    std::cout << "4. nothrow 版本的 new:\n";
    int* nothrow_ptr = new(std::nothrow) int(100);
    if (nothrow_ptr) {
        std::cout << "nothrow 分配成功: " << *nothrow_ptr << "\n";
        delete nothrow_ptr;
    } else {
        std::cout << "nothrow 分配失败\n";
    }
    std::cout << "\n";
    
    // 5. 对齐分配 (C++17)
    std::cout << "5. 对齐分配 (C++17):\n";
    alignas(64) int* aligned_ptr = new(std::align_val_t{64}) int(200);
    std::cout << "对齐分配的值: " << *aligned_ptr << "\n";
    std::cout << "地址: " << aligned_ptr << "\n";
    std::cout << "地址对齐: " << (reinterpret_cast<uintptr_t>(aligned_ptr) % 64) << "\n";
    operator delete(aligned_ptr, std::align_val_t{64});
    std::cout << "\n";
    
    // 6. 异常处理 - bad_alloc
    std::cout << "6. bad_alloc 异常处理:\n";
    try {
        // 尝试分配一个非常大的内存块，可能会失败
        size_t huge_size = static_cast<size_t>(-1);
        char* huge_memory = new char[huge_size];
        delete[] huge_memory;
    } catch (const std::bad_alloc& e) {
        std::cout << "捕获到 bad_alloc 异常: " << e.what() << "\n";
    }
    std::cout << "\n";
    
    // 7. 异常处理 - bad_array_new_length (C++11)
    std::cout << "7. bad_array_new_length 异常处理:\n";
    try {
        // 尝试分配一个无效长度的数组
        size_t invalid_size = -1;
        int* invalid_array = new int[invalid_size];
        delete[] invalid_array;
    } catch (const std::bad_array_new_length& e) {
        std::cout << "捕获到 bad_array_new_length 异常: " << e.what() << "\n";
    }
    std::cout << "\n";
    
    // 8. 放置 new (placement new)
    std::cout << "8. 放置 new (placement new):\n";
    // 先分配原始内存
    void* raw_memory = ::operator new(sizeof(MyClass));
    std::cout << "原始内存地址: " << raw_memory << "\n";
    
    // 在已分配的内存上构造对象
    MyClass* obj = new(raw_memory) MyClass(999);
    obj->show();
    
    // 手动调用析构函数
    obj->~MyClass();
    
    // 释放原始内存
    ::operator delete(raw_memory);
    std::cout << "\n";
    
    // 9. 硬件干扰大小常量 (C++17)
    std::cout << "9. 硬件干扰大小常量 (C++17):\n";
    std::cout << "hardware_destructive_interference_size: " 
              << std::hardware_destructive_interference_size << "\n";
    std::cout << "hardware_constructive_interference_size: " 
              << std::hardware_constructive_interference_size << "\n";
    std::cout << "\n";
    
    // 10. std::launder (C++17) - 指针优化屏障
    std::cout << "10. std::launder 演示 (C++17):\n";
    struct X { 
        const int n; 
        X(int n) : n(n) {} 
    };
    
    X* x = new X(10);
    std::cout << "原始值: " << x->n << "\n";
    
    // 在同一内存位置创建新对象
    X* new_x = new(x) X(20);
    std::cout << "新值: " << new_x->n << "\n";
    
    // 使用 std::launder 获取指向新对象的指针
    X* laundered_x = std::launder(x);
    std::cout << "清洗后的值: " << laundered_x->n << "\n";
    
    laundered_x->~X();
    ::operator delete(x);
    std::cout << "\n";
    
    // 11. 自定义分配和释放函数
    std::cout << "11. 自定义分配和释放函数:\n";
    void* custom_mem = ::operator new(100);
    std::cout << "自定义分配的内存地址: " << custom_mem << "\n";
    ::operator delete(custom_mem);
    std::cout << "自定义释放完成\n";
    std::cout << "\n";
    
#if __cplusplus >= 202002L
    // 12. C++20 销毁删除操作符
    std::cout << "12. C++20 销毁删除操作符:\n";
    MyClass* dc_obj = new MyClass(1234);
    delete dc_obj; // 这会调用我们定义的销毁删除操作符
    std::cout << "\n";
#endif
    
    std::cout << "=== 演示结束 ===\n";
    
    return 0;
}
```

## 4. new/delete 和 ::operator new/delete区别

好的，这是一个非常深入的C++问题。简单来说，**有区别，而且是非常重要的区别**。

直接使用 `delete` 是标准且正确的做法，而直接调用 `::operator delete` 是一种特殊情况，通常应该避免。

下面我们来详细分解它们的区别。

### 1. `delete` 表达式 (The `delete` Expression)

当你写 `delete ptr;` 时，你并不是直接调用内存释放函数。你是在使用一个叫做 `delete` **表达式** 的东西。这个表达式会执行两个关键步骤：

1.  **调用析构函数**：首先，它会根据指针 `ptr` 的类型，调用指向对象的析构函数。这确保了对象所使用的任何资源（如内存、文件句柄、锁等）都能被正确清理。
2.  **释放内存**：然后，它**间接地**调用合适的 `operator delete` 函数来释放该对象所占用的内存。

**重要特性**：
*   `delete` 是**与 `new` 配对使用**的。你用 `new` 创建，就用 `delete` 销毁。
*   它会自动处理析构函数的调用，这是确保资源不泄漏的关键。
*   它知道该调用哪个 `operator delete`（全局的还是类特定的），你不需要关心。

**示例**：
```cpp
class MyClass {
public:
    MyClass() { std::cout << "Constructor\n"; }
    ~MyClass() { std::cout << "Destructor\n"; } // 析构函数
    void* operator new(size_t size) {
        std::cout << "Custom new\n";
        return ::operator new(size);
    }
    void operator delete(void* ptr) {
        std::cout << "Custom delete\n";
        ::operator delete(ptr);
    }
};

int main() {
    MyClass* obj = new MyClass; // 输出: Custom new, Constructor
    delete obj; // 输出: Destructor, Custom delete
    // 步骤：1. 调用 ~MyClass()  2. 调用 MyClass::operator delete
    return 0;
}
```

### 2. `::operator delete` 函数 (The `::operator delete` Function)

`::operator delete` 是一个**单纯的内存释放函数**。它的功能非常单一：释放之前由 `::operator new` 分配的一块原始内存。

*   `::` 作用域解析运算符意味着它明确指定调用**全局版本**的 `operator delete`，而不是某个类可能重载的版本。
*   它**只负责释放内存，不会调用任何析构函数**。

**直接调用 `::operator delete` 的危险性**：
如果你对一个拥有非平凡析构函数（non-trivial destructor）的对象直接使用 `::operator delete`，会导致**资源泄漏**。因为对象的析构函数永远不会被调用。

```cpp
int main() {
    MyClass* obj = new MyClass; // 输出: Custom new, Constructor

    // 错误做法！
    ::operator delete(obj); // 仅仅释放了内存！
    // 输出：什么都没有（没有调用析构函数和自定义的delete）
    // 后果：如果 MyClass 在构造函数中分配了其他内存或资源，这些资源将会泄漏。

    return 0;
}
```

### 3. 对比表格

| 特性                | `delete ptr;` (表达式)                           | `::operator delete(ptr);` (函数)                             |
| :------------------ | :----------------------------------------------- | :----------------------------------------------------------- |
| **主要功能**        | 销毁对象并释放内存                               | **仅释放内存**                                               |
| **析构函数**        | **会调用**                                       | **不会调用**                                                 |
| **选择机制**        | 自动选择正确的 `operator delete`（全局或类特定） | 强制使用**全局**版本的 `operator delete`                     |
| **使用场景**        | **99% 的情况**，用于销毁由 `new` 创建的动态对象  | 极少数特殊情况，需要与直接调用 `::operator new` 分配的**原始内存**配对 |
| **安全性**          | 安全，是标准做法                                 | **危险**，容易导致资源泄漏                                   |
| **与 `new` 的配对** | `new`                                            | `::operator new`                                             |

---

### 4. 什么时候应该直接使用 `::operator new` 和 `::operator delete`？

几乎从不。它们只在非常底层的编程中出现，例如：

1.  **编写自定义的内存分配器/池**：你可能会重载类的 `operator new`/`operator delete`，在你自定义的实现中，你最终仍然需要分配原始的、未初始化的内存块，这时你可能会调用 `::operator new` 和 `::operator delete`。
    ```cpp
    void* MyClass::operator new(size_t size) {
        // 你的自定义分配逻辑...
        // 最终需要一块原始内存，向全局内存池申请
        return ::operator new(size);
    }
    ```
2.  **处理原始内存**：如果你只是分配了一块没有任何构造对象的原始内存（比如，分配一个 `char` 数组用于缓冲区），并且使用的是 `::operator new`，那么释放时应该用 `::operator delete`。但请注意，这种情况通常使用 `new char[...]` 和 `delete[]` 会更简单、更安全。

### 5. 总结与最佳实践

*   **永远使用 `delete` 来销毁由 `new` 创建的对象**。这是黄金法则。
*   **永远不要直接调用 `::operator delete` 来替代 `delete`**。这样做会跳过析构函数，是严重的错误。
*   直接调用 `::operator delete` 是一个**底层操作**，它只应与直接调用 `::operator new` 的**上层操作**配对使用，并且你要非常清楚自己只是在操作原始内存，而不是具有生命周期的对象。

可以把 `new`/`delete` 理解为高级的、安全的“对象管理器”，而把 `::operator new`/`::operator delete` 理解为低级的、原始的“内存管理器”。在绝大多数情况下，你应该使用高级的接口。

### 6. 同样new 和 ::operator new 区别

new 需要进行new一个对象，它是调用一个结构体或者类的构造函数，然后分配内存，而::operator new则是申请一块区域大小的内存进行使用

```c
    // 1. 标准分配器使用
    std::cout << "1. 标准分配器:\n";
    std::allocator<int> alloc;
    int* arr = alloc.allocate(5); // 只分配内存
    
    // 构造对象
    for (int i = 0; i < 5; ++i) {
        std::construct_at(arr + i, i * 10);
    }
    
    /*
    // 使用 new
    int* arr_new = new int[5]; // 内存已分配，所有元素已默认构造
    // 可以直接使用
    for (int i = 0; i < 5; i++) {
        arr_new[i] = i * 10; // 只是赋值，不是构造
    }*/
    
    std::cout << "分配的内容: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    for (int i = 0; i < 5; ++i) {
        std::destroy_at(arr + i);
    }
    alloc.deallocate(arr, 5);
```



# 二、`<memory>`

## 1. 概述

| 包含                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ ](https://cppreference.cn/w/cpp/header/compare)(C++20)     | [三路比较运算符](https://cppreference.cn/w/cpp/language/operator_comparison#Three-way_comparison)支持 |
| 类                                                           |                                                              |
| 指针特性                                                     |                                                              |
| [ pointer_traits](https://cppreference.cn/w/cpp/memory/pointer_traits)(C++11) | 提供有关类指针类型的信息  (类模板)                           |
| 垃圾回收器支持                                               |                                                              |
| [ pointer_safety](https://cppreference.cn/w/cpp/memory/gc/pointer_safety)(C++11)(在 C++23 中已移除) | 列出指针安全模型  (枚举)                                     |
| 分配器                                                       |                                                              |
| [ allocator](https://cppreference.cn/w/cpp/memory/allocator) | 默认分配器  (类模板)                                         |
| [ allocator_traits](https://cppreference.cn/w/cpp/memory/allocator_traits)(C++11) | 提供关于分配器类型的信息  (类模板)                           |
| [ allocation_result](https://cppreference.cn/w/cpp/memory/allocation_result)(C++23) | 记录 `allocate_at_least` 分配的存储地址和实际大小  (类模板)  |
| [ uses_allocator](https://cppreference.cn/w/cpp/memory/uses_allocator)(C++11) | 检查指定类型是否支持 uses-allocator 构造  (类模板)           |
| 未初始化存储                                                 |                                                              |
| [ raw_storage_iterator](https://cppreference.cn/w/cpp/memory/raw_storage_iterator)(在 C++17 中已弃用)(在 C++20 中已移除) | 一个迭代器，允许标准算法将结果存储在未初始化内存中  (类模板) |
| 智能指针                                                     |                                                              |
| [ unique_ptr](https://cppreference.cn/w/cpp/memory/unique_ptr)(C++11) | 具有唯一对象所有权语义的智能指针  (类模板)                   |
| [ shared_ptr](https://cppreference.cn/w/cpp/memory/shared_ptr)(C++11) | 具有共享对象所有权语义的智能指针  (类模板)                   |
| [ weak_ptr](https://cppreference.cn/w/cpp/memory/weak_ptr)(C++11) | 对由 [std::shared_ptr](https://cppreference.cn/w/cpp/memory/shared_ptr) 管理的对象的弱引用  (类模板) |
| [ auto_ptr](https://cppreference.cn/w/cpp/memory/auto_ptr)(C++11 中已废弃)(C++17 中已移除) | 具有严格对象所有权语义的智能指针  (类模板)                   |
| 辅助类                                                       |                                                              |
| [ std::atomic](https://cppreference.cn/w/cpp/memory/shared_ptr/atomic2)(C++20) | 原子共享指针  (类模板特化)                                   |
| [ std::atomic](https://cppreference.cn/w/cpp/memory/weak_ptr/atomic2)(C++20) | 原子弱指针  (类模板特化)                                     |
| [ owner_less](https://cppreference.cn/w/cpp/memory/owner_less)(C++11) | 提供基于所有者的共享指针和弱指针的混合类型排序  (类模板)     |
| [ owner_hash](https://cppreference.cn/w/cpp/memory/owner_hash)(C++26) | 为共享指针和弱指针提供基于所有者的哈希  (类)                 |
| [ owner_equal](https://cppreference.cn/w/cpp/memory/owner_equal)(C++26) | 提供基于所有者的共享指针和弱指针的混合类型相等比较  (类)     |
| [ enable_shared_from_this](https://cppreference.cn/w/cpp/memory/enable_shared_from_this)(C++11) | 允许对象创建指向自身的 `shared_ptr`  (类模板)                |
| [ bad_weak_ptr](https://cppreference.cn/w/cpp/memory/bad_weak_ptr)(C++11) | 访问已销毁对象的 `weak_ptr` 时抛出的异常  (类)               |
| [ default_delete](https://cppreference.cn/w/cpp/memory/default_delete)(C++11) | [unique_ptr](https://cppreference.cn/w/cpp/memory/unique_ptr) 的默认删除器  (类模板) |
| [ std::hash](https://cppreference.cn/w/cpp/memory/unique_ptr/hash)(C++11) | [`std::unique_ptr`](https://cppreference.cn/w/cpp/memory/unique_ptr) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/memory/shared_ptr/hash)(C++11) | [`std::shared_ptr`](https://cppreference.cn/w/cpp/memory/shared_ptr) 的哈希支持  (类模板特化) |
| 智能指针适配器                                               |                                                              |
| [ out_ptr_t](https://cppreference.cn/w/cpp/memory/out_ptr_t)(C++23) | 与外部指针设置器交互，并在销毁时重置智能指针  (类模板)       |
| [ inout_ptr_t](https://cppreference.cn/w/cpp/memory/inout_ptr_t)(C++23) | 与外部指针设置器交互，从智能指针获取初始指针值，并在销毁时重置它  (类模板) |
| 前向声明                                                     |                                                              |
| 定义于头文件 `<functional>`                                  |                                                              |
| [ hash](https://cppreference.cn/w/cpp/utility/hash)(C++11)   | 哈希函数对象  (类模板)                                       |
| 定义于头文件 `<atomic>`                                      |                                                              |
| [ atomic](https://cppreference.cn/w/cpp/atomic/atomic)(C++11) | atomic 类模板和针对 bool、整型、浮点型(C++20 起) 和指针类型的特化  (类模板) |
| 标签                                                         |                                                              |
| [ allocator_argallocator_arg_t](https://cppreference.cn/w/cpp/memory/allocator_arg)(C++11) | 用于选择分配器感知构造函数的标记 (标签)                      |
| 函数                                                         |                                                              |
| 使用分配器构造                                               |                                                              |
| [ uses_allocator_construction_args](https://cppreference.cn/w/cpp/memory/uses_allocator_construction_args)(C++20) | 准备与给定类型所需的使用分配器构造方式匹配的参数列表  (函数模板) |
| [ make_obj_using_allocator](https://cppreference.cn/w/cpp/memory/make_obj_using_allocator)(C++20) | 通过 uses-allocator 构造创建给定类型的对象  (函数模板)       |
| [ uninitialized_construct_using_allocator](https://cppreference.cn/w/cpp/memory/uninitialized_construct_using_allocator)(C++20) | 通过使用分配器构造在指定内存位置创建给定类型的对象  (函数模板) |
| 杂项                                                         |                                                              |
| [ to_address](https://cppreference.cn/w/cpp/memory/to_address)(C++20) | 从类指针类型获取原始指针  (函数模板)                         |
| [ addressof](https://cppreference.cn/w/cpp/memory/addressof)(C++11) | 获取对象的实际地址，即使 `**&**` 运算符被重载  (函数模板)    |
| [ align](https://cppreference.cn/w/cpp/memory/align)(C++11)  | 在缓冲区中对齐指针  (函数)                                   |
| [ assume_aligned](https://cppreference.cn/w/cpp/memory/assume_aligned)(C++20) | 通知编译器指针已对齐  (函数模板)                             |
| [ is_sufficiently_aligned](https://cppreference.cn/w/cpp/memory/is_sufficiently_aligned)(C++26) | 检查指针是否指向对齐值至少为给定值的对象  (函数模板)         |
| 显式生命周期管理                                             |                                                              |
| [ start_lifetime_asstart_lifetime_as_array](https://cppreference.cn/w/cpp/memory/start_lifetime_as)(C++23) | 在给定存储中隐式创建对象，并重用对象表示  (函数模板)         |
| 垃圾回收器支持                                               |                                                              |
| [ declare_reachable](https://cppreference.cn/w/cpp/memory/gc/declare_reachable)(C++11)(在 C++23 中已移除) | 声明一个对象不能被回收  (函数)                               |
| [ undeclare_reachable](https://cppreference.cn/w/cpp/memory/gc/undeclare_reachable)(C++11)(在 C++23 中已移除) | 声明一个对象可以被回收  (函数模板)                           |
| [ declare_no_pointers](https://cppreference.cn/w/cpp/memory/gc/declare_no_pointers)(C++11)(在 C++23 中已移除) | 声明一个内存区域不包含可追溯指针  (函数)                     |
| [ undeclare_no_pointers](https://cppreference.cn/w/cpp/memory/gc/undeclare_no_pointers)(C++11)(在 C++23 中已移除) | 取消 [std::declare_no_pointers](https://cppreference.cn/w/cpp/memory/gc/declare_no_pointers) 的效果  (函数) |
| [ get_pointer_safety](https://cppreference.cn/w/cpp/memory/gc/get_pointer_safety)(C++11)(在 C++23 中已移除) | 返回当前指针安全模型  (函数)                                 |
| 未初始化存储                                                 |                                                              |
| [ uninitialized_copy](https://cppreference.cn/w/cpp/memory/uninitialized_copy) | 将对象范围复制到未初始化内存区域  (函数模板)                 |
| [ uninitialized_copy_n](https://cppreference.cn/w/cpp/memory/uninitialized_copy_n)(C++11) | 将一定数量的对象复制到未初始化内存区域  (函数模板)           |
| [ uninitialized_fill](https://cppreference.cn/w/cpp/memory/uninitialized_fill) | 将对象复制到由范围定义的未初始化内存区域  (函数模板)         |
| [ uninitialized_fill_n](https://cppreference.cn/w/cpp/memory/uninitialized_fill_n) | 将对象复制到由起始和计数定义的未初始化内存区域  (函数模板)   |
| [ uninitialized_move](https://cppreference.cn/w/cpp/memory/uninitialized_move)(C++17) | 将一系列对象移动到未初始化内存区域  (函数模板)               |
| [ uninitialized_move_n](https://cppreference.cn/w/cpp/memory/uninitialized_move_n)(C++17) | 将多个对象移动到未初始化内存区域  (函数模板)                 |
| [ uninitialized_default_construct](https://cppreference.cn/w/cpp/memory/uninitialized_default_construct)(C++17) | 通过[默认初始化](https://cppreference.cn/w/cpp/language/default_initialization)在由范围定义的未初始化内存区域中构造对象  (函数模板) |
| [ uninitialized_default_construct_n](https://cppreference.cn/w/cpp/memory/uninitialized_default_construct_n)(C++17) | 在由起始和计数定义的未初始化内存区域中，通过[默认初始化](https://cppreference.cn/w/cpp/language/default_initialization)构造对象  (函数模板) |
| [ uninitialized_value_construct](https://cppreference.cn/w/cpp/memory/uninitialized_value_construct)(C++17) | 在由范围定义的未初始化内存区域中，通过[值初始化](https://cppreference.cn/w/cpp/language/value_initialization)构造对象  (函数模板) |
| [ uninitialized_value_construct_n](https://cppreference.cn/w/cpp/memory/uninitialized_value_construct_n)(C++17) | 在由起始和计数定义的未初始化内存区域中，通过[值初始化](https://cppreference.cn/w/cpp/language/value_initialization)构造对象  (函数模板) |
| [ construct_at](https://cppreference.cn/w/cpp/memory/construct_at)(C++20) | 在给定地址创建对象  (函数模板)                               |
| [ destroy_at](https://cppreference.cn/w/cpp/memory/destroy_at)(C++17) | 销毁给定地址处的对象  (函数模板)                             |
| [ destroy](https://cppreference.cn/w/cpp/memory/destroy)(C++17) | 销毁对象范围  (函数模板)                                     |
| [ destroy_n](https://cppreference.cn/w/cpp/memory/destroy_n)(C++17) | 销毁范围内的多个对象  (函数模板)                             |
| [ get_temporary_buffer](https://cppreference.cn/w/cpp/memory/get_temporary_buffer)(在 C++17 中已弃用)(在 C++20 中已移除) | 获取未初始化存储  (函数模板)                                 |
| [ return_temporary_buffer](https://cppreference.cn/w/cpp/memory/return_temporary_buffer)(在 C++17 中已弃用)(在 C++20 中已移除) | 释放未初始化存储  (函数模板)                                 |
| 智能指针非成员操作                                           |                                                              |
| [ make_uniquemake_unique_for_overwrite](https://cppreference.cn/w/cpp/memory/unique_ptr/make_unique)(C++14)(C++20) | 创建一个管理新对象的唯一指针  (函数模板)                     |
| [ operator==operator!=operatoroperator>=operator<=>](https://cppreference.cn/w/cpp/memory/unique_ptr/operator_cmp)(C++20 中移除)(C++20) | 与另一个 `unique_ptr` 或 nullptr 比较  (函数模板)            |
| [ make_sharedmake_shared_for_overwrite](https://cppreference.cn/w/cpp/memory/shared_ptr/make_shared)(C++20 起) | 创建一个管理新对象的共享指针  (函数模板)                     |
| [ allocate_sharedallocate_shared_for_overwrite](https://cppreference.cn/w/cpp/memory/shared_ptr/allocate_shared)(C++20 起) | 创建一个共享指针，该指针管理使用分配器分配的新对象  (函数模板) |
| [ static_pointer_castdynamic_pointer_castconst_pointer_castreinterpret_pointer_cast](https://cppreference.cn/w/cpp/memory/shared_ptr/pointer_cast)(C++17) | 对存储的指针应用 [`static_cast`](https://cppreference.cn/w/cpp/language/static_cast)、[`dynamic_cast`](https://cppreference.cn/w/cpp/language/dynamic_cast)、[`const_cast`](https://cppreference.cn/w/cpp/language/const_cast) 或 [`reinterpret_cast`](https://cppreference.cn/w/cpp/language/reinterpret_cast)  (函数模板) |
| [ get_deleter](https://cppreference.cn/w/cpp/memory/shared_ptr/get_deleter) | 如果拥有，则返回指定类型的删除器  (函数模板)                 |
| [ operator==operator!=operatoroperator>=operator<=>](https://cppreference.cn/w/cpp/memory/shared_ptr/operator_cmp)(C++20 中移除)(C++20 中移除)(C++20 中移除)(C++20 中移除)(C++20 中移除)(C++20) | 与另一个 `shared_ptr` 或 nullptr 比较  (函数模板)            |
| [ operator<<(std::shared_ptr)](https://cppreference.cn/w/cpp/memory/shared_ptr/operator_ltlt) | 将存储的指针值输出到输出流  (函数模板)                       |
| [ operator<<(std::unique_ptr)](https://cppreference.cn/w/cpp/memory/unique_ptr/operator_ltlt)(C++20) | 将管理的指针值输出到输出流  (函数模板)                       |
| [ std::swap(std::unique_ptr)](https://cppreference.cn/w/cpp/memory/unique_ptr/swap2)(C++11) | 特化 [std::swap](https://cppreference.cn/w/cpp/algorithm/swap) 算法  (函数模板) |
| [ std::swap(std::shared_ptr)](https://cppreference.cn/w/cpp/memory/shared_ptr/swap2)(C++11) | 特化 [std::swap](https://cppreference.cn/w/cpp/algorithm/swap) 算法  (函数模板) |
| [ std::swap(std::weak_ptr)](https://cppreference.cn/w/cpp/memory/weak_ptr/swap2)(C++11) | 特化 [std::swap](https://cppreference.cn/w/cpp/algorithm/swap) 算法  (函数模板) |
| 智能指针适配器创建                                           |                                                              |
| [ out_ptr](https://cppreference.cn/w/cpp/memory/out_ptr_t/out_ptr)(C++23) | 创建带有相关智能指针和重置参数的 `out_ptr_t`  (函数模板)     |
| [ inout_ptr](https://cppreference.cn/w/cpp/memory/inout_ptr_t/inout_ptr)(C++23) | 创建一个带有关联智能指针和重置参数的 `inout_ptr_t`  (函数模板) |

| [ std::atomic_is_lock_free(std::shared_ptr)std::atomic_load(std::shared_ptr)std::atomic_load_explicit(std::shared_ptr)std::atomic_store(std::shared_ptr)std::atomic_store_explicit(std::shared_ptr)std::atomic_exchange(std::shared_ptr)std::atomic_exchange_explicit(std::shared_ptr)std::atomic_compare_exchange_weak(std::shared_ptr)std::atomic_compare_exchange_strong(std::shared_ptr)std::atomic_compare_exchange_weak_explicit(std::shared_ptr)std::atomic_compare_exchange_strong_explicit(std::shared_ptr)](https://cppreference.cn/w/cpp/memory/shared_ptr/atomic)(C++20 中已弃用)(C++26 中移除) | 特化 `std::shared_ptr` 的原子操作  (函数模板) |
| ------------------------------------------------------------ | --------------------------------------------- |
|                                                              |                                               |



| 类函数实体                                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间`std::ranges`                                  |                                                              |
| 未初始化存储                                                 |                                                              |
| [ ranges::uninitialized_copy](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_copy)(C++20) | 将对象范围复制到未初始化内存区域 (算法函数对象)              |
| [ ranges::uninitialized_copy_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_copy_n)(C++20) | 将一定数量的对象复制到未初始化内存区域 (算法函数对象)        |
| [ ranges::uninitialized_fill](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_fill)(C++20) | 将对象复制到由范围定义的未初始化内存区域 (算法函数对象)      |
| [ ranges::uninitialized_fill_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_fill_n)(C++20) | 将对象复制到由起始和计数定义的未初始化内存区域 (算法函数对象) |
| [ ranges::uninitialized_move](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_move)(C++20) | 将一系列对象移动到未初始化内存区域 (算法函数对象)            |
| [ ranges::uninitialized_move_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_move_n)(C++20) | 将多个对象移动到未初始化内存区域 (算法函数对象)              |
| [ ranges::uninitialized_default_construct](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_default_construct)(C++20) | 通过[默认初始化](https://cppreference.cn/w/cpp/language/default_initialization)在由范围定义的未初始化内存区域中构造对象 (算法函数对象) |
| [ ranges::uninitialized_default_construct_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_default_construct_n)(C++20) | 通过[默认初始化](https://cppreference.cn/w/cpp/language/default_initialization)在由起始和计数定义的未初始化内存区域中构造对象 (算法函数对象) |
| [ ranges::uninitialized_value_construct](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_value_construct)(C++20) | 在由范围定义的未初始化内存区域中，通过[值初始化](https://cppreference.cn/w/cpp/language/value_initialization)构造对象 (算法函数对象) |
| [ ranges::uninitialized_value_construct_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_value_construct_n)(C++20) | 在由起始和计数定义的未初始化内存区域中，通过[值初始化](https://cppreference.cn/w/cpp/language/value_initialization)构造对象 (算法函数对象) |
| [ ranges::construct_at](https://cppreference.cn/w/cpp/memory/ranges/construct_at)(C++20) | 在给定地址创建对象 (算法函数对象)                            |
| [ ranges::destroy_at](https://cppreference.cn/w/cpp/memory/ranges/destroy_at)(C++20) | 销毁给定地址处的对象 (算法函数对象)                          |
| [ ranges::destroy](https://cppreference.cn/w/cpp/memory/ranges/destroy)(C++20) | 销毁对象范围 (算法函数对象)                                  |
| [ ranges::destroy_n](https://cppreference.cn/w/cpp/memory/ranges/destroy_n)(C++20) | 销毁范围内的多个对象 (算法函数对象)                          |

## 2. C++ 分配器底层实现

C++ 标准库的 `std::allocator` 通常使用全局的 `::operator new` 和 `::operator delete` 来分配和释放内存。这意味着：

1. 每次分配都会调用系统调用，可能效率较低
2. 频繁的小内存分配可能导致内存碎片
3. 没有内置的内存池或缓存机制

## 3. 常用方法示例

下面是 `<memory>` 头文件中四个主要模块的详细说明和代码示例：

### 1. 未初始化存储模块

提供在未初始化内存中构造、复制、移动和销毁对象的函数，用于低级内存管理。

**核心功能：**

- `uninitialized_copy`/`uninitialized_copy_n`: 复制对象到未初始化内存
- `uninitialized_fill`/`uninitialized_fill_n`: 用特定值填充未初始化内存
- `uninitialized_move`/`uninitialized_move_n`: 移动对象到未初始化内存
- `construct_at`: 在指定地址构造对象
- `destroy`/`destroy_at`/`destroy_n`: 销毁对象
- `uninitialized_default_construct`/`uninitialized_value_construct`: 默认构造和值构造

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>

int main() {
    std::cout << "=== 未初始化存储模块示例 ===\n\n";
    
    // 1. uninitialized_copy - 复制对象到未初始化内存
    std::cout << "1. uninitialized_copy:\n";
    std::vector<int> source = {1, 2, 3, 4, 5};
    // 分配未初始化内存
    void* raw_memory = operator new(source.size() * sizeof(int));
    int* dest = static_cast<int*>(raw_memory);
    
    // 复制到未初始化内存
    std::uninitialized_copy(source.begin(), source.end(), dest);
    
    std::cout << "复制的内容: ";
    for (size_t i = 0; i < source.size(); ++i) {
        std::cout << dest[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    std::destroy(dest, dest + source.size());
    operator delete(raw_memory);
    
    // 2. uninitialized_fill - 填充未初始化内存
    std::cout << "\n2. uninitialized_fill:\n";
    const size_t count = 5;
    int* filled_memory = static_cast<int*>(operator new(count * sizeof(int)));
    
    // 用特定值填充未初始化内存
    std::uninitialized_fill(filled_memory, filled_memory + count, 42);
    
    std::cout << "填充的内容: ";
    for (size_t i = 0; i < count; ++i) {
        std::cout << filled_memory[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    std::destroy(filled_memory, filled_memory + count);
    operator delete(filled_memory);
    
    // 3. uninitialized_move - 移动对象到未初始化内存
    std::cout << "\n3. uninitialized_move:\n";
    std::vector<std::string> move_source = {"Hello", "World", "C++"};
    std::string* move_dest = static_cast<std::string*>(
        operator new(move_source.size() * sizeof(std::string))
    );
    
    // 移动到未初始化内存
    std::uninitialized_move(move_source.begin(), move_source.end(), move_dest);
    
    std::cout << "移动的内容: ";
    for (size_t i = 0; i < move_source.size(); ++i) {
        std::cout << move_dest[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    std::destroy(move_dest, move_dest + move_source.size());
    operator delete(move_dest);
    
    // 4. construct_at 和 destroy_at - 在特定地址构造和销毁对象
    std::cout << "\n4. construct_at 和 destroy_at:\n";
    alignas(std::string) char buffer[sizeof(std::string)];
    
    // 在指定地址构造对象
    std::string* str_ptr = std::construct_at(reinterpret_cast<std::string*>(buffer), "Constructed at address");
    std::cout << *str_ptr << "\n";
    
    // 在指定地址销毁对象
    std::destroy_at(str_ptr);
    
    // 5. uninitialized_default_construct 和 uninitialized_value_construct
    std::cout << "\n5. 默认构造和值构造:\n";
    constexpr size_t arr_size = 3;
    int* default_arr = static_cast<int*>(operator new(arr_size * sizeof(int)));
    int* value_arr = static_cast<int*>(operator new(arr_size * sizeof(int)));
    
    // 默认构造（不初始化）
    std::uninitialized_default_construct_n(default_arr, arr_size);
    std::cout << "默认构造的值（未定义）: " 
              << default_arr[0] << " " << default_arr[1] << " " << default_arr[2] << "\n";
    
    // 值构造（初始化为0）
    std::uninitialized_value_construct_n(value_arr, arr_size);
    std::cout << "值构造的值（初始化为0）: " 
              << value_arr[0] << " " << value_arr[1] << " " << value_arr[2] << "\n";
    
    // 销毁对象并释放内存
    std::destroy_n(default_arr, arr_size);
    std::destroy_n(value_arr, arr_size);
    operator delete(default_arr);
    operator delete(value_arr);
    
    std::cout << "\n=== 未初始化存储模块示例结束 ===\n";
    return 0;
}
```

### 2. 分配器模块

提供内存分配和释放的抽象，支持自定义内存管理策略。

**核心功能：**

- `allocator`: 标准分配器
- `allocator_traits`: 提供分配器类型信息
- 自定义分配器实现
- `uses_allocator`: 检查类型是否支持使用分配器
- `allocate_at_least` (C++23): 分配至少指定大小的内存

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <cstdlib>

// 自定义分配器示例
template<typename T>
class SimpleAllocator {
public:
    using value_type = T;
    
    SimpleAllocator() = default;
    
    template<typename U>
    SimpleAllocator(const SimpleAllocator<U>&) {}
    
    T* allocate(std::size_t n) {
        std::cout << "分配 " << n << " 个 " << typeid(T).name() << " 对象\n";
        return static_cast<T*>(std::malloc(n * sizeof(T)));
    }
    
    void deallocate(T* p, std::size_t n) {
        std::cout << "释放 " << n << " 个 " << typeid(T).name() << " 对象\n";
        std::free(p);
    }
};

// 支持分配器感知的类型
template<typename T, typename Allocator = std::allocator<T>>
class AllocatorAwareContainer {
public:
    using allocator_type = Allocator;
    
    explicit AllocatorAwareContainer(const Allocator& alloc = Allocator())
        : alloc_(alloc), data_(alloc_) {}
    
    void add(const T& value) {
        data_.push_back(value);
    }
    
    void show() const {
        for (const auto& item : data_) {
            std::cout << item << " ";
        }
        std::cout << "\n";
    }
    
private:
    Allocator alloc_;
    std::vector<T, Allocator> data_;
};

int main() {
    std::cout << "=== 分配器模块示例 ===\n\n";
    
    // 1. 标准分配器使用
    std::cout << "1. 标准分配器:\n";
    std::allocator<int> alloc;
    int* arr = alloc.allocate(5); // 只分配内存
    
    // 构造对象
    for (int i = 0; i < 5; ++i) {
        std::construct_at(arr + i, i * 10);
    }
    
    /*
    // 使用 new
    int* arr_new = new int[5]; // 内存已分配，所有元素已默认构造
    // 可以直接使用
    for (int i = 0; i < 5; i++) {
        arr_new[i] = i * 10; // 只是赋值，不是构造
    }*/
    
    std::cout << "分配的内容: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    for (int i = 0; i < 5; ++i) {
        std::destroy_at(arr + i);
    }
    alloc.deallocate(arr, 5);
    
    // 2. 自定义分配器
    std::cout << "\n2. 自定义分配器:\n";
    SimpleAllocator<double> custom_alloc;
    double* custom_arr = custom_alloc.allocate(3);
    
    for (int i = 0; i < 3; ++i) {
        std::construct_at(custom_arr + i, i + 0.5);
    }
    
    std::cout << "自定义分配的内容: ";
    for (int i = 0; i < 3; ++i) {
        std::cout << custom_arr[i] << " ";
    }
    std::cout << "\n";
    
    for (int i = 0; i < 3; ++i) {
        std::destroy_at(custom_arr + i);
    }
    custom_alloc.deallocate(custom_arr, 3);
    
    // 3. allocator_traits 使用
    std::cout << "\n3. allocator_traits:\n";
    using AllocTraits = std::allocator_traits<SimpleAllocator<int>>;//使用allocator_traits统一自定义的allocator接口
    SimpleAllocator<int> int_alloc;
    
    int* traits_arr = AllocTraits::allocate(int_alloc, 4);
    
    for (int i = 0; i < 4; ++i) {
        AllocTraits::construct(int_alloc, traits_arr + i, i * 2);
        //SimpleAllocator<int>::construct // 错误没有这个方法
    }
    
    std::cout << "使用 allocator_traits 分配的内容: ";
    for (int i = 0; i < 4; ++i) {
        std::cout << traits_arr[i] << " ";
    }
    std::cout << "\n";
    
    for (int i = 0; i < 4; ++i) {
        AllocTraits::destroy(int_alloc, traits_arr + i);
    }
    AllocTraits::deallocate(int_alloc, traits_arr, 4);
    
    // 4. 分配器感知的容器
    std::cout << "\n4. 分配器感知的容器:\n";
    SimpleAllocator<int> container_alloc;
    AllocatorAwareContainer<int, SimpleAllocator<int>> container(container_alloc);
    
    container.add(10);
    container.add(20);
    container.add(30);
    
    std::cout << "容器内容: ";
    container.show();
    
    // 5. uses_allocator 检查
    std::cout << "\n5. uses_allocator 检查:\n";
    bool uses_alloc = std::uses_allocator<
        AllocatorAwareContainer<int, SimpleAllocator<int>>, 
        SimpleAllocator<int>>::value;
    
    std::cout << "容器是否使用分配器: " << std::boolalpha << uses_alloc << "\n";
    
    // 6. C++23 allocation_result (如果编译器支持)
    #if __cplusplus >= 202302L
    std::cout << "\n6. C++23 allocation_result:\n";
    std::allocator<int> new_alloc;
    auto result = new_alloc.allocate_at_least(10);
    std::cout << "请求大小: 10, 实际分配大小: " << result.count << "\n";
    new_alloc.deallocate(result.ptr, result.count);
    #endif
    
    std::cout << "\n=== 分配器模块示例结束 ===\n";
    return 0;
}
```

### 3. 杂项模块

提供各种有用的内存相关工具函数。

**核心功能：**

- `addressof`: 获取对象实际地址（即使&运算符被重载）
- `to_address`: 从类似指针的类型获取原始指针
- `align`: 对齐指针
- `assume_aligned`: 通知编译器指针已对齐
- `is_sufficiently_aligned` (C++23): 检查对齐是否足够
- `start_lifetime_as` (C++23): 在存储中开始对象生命周期

```cpp
#include <iostream>
#include <memory>
#include <vector>

struct OverloadedAddress {
    int value;
    
    // 重载 & 运算符
    OverloadedAddress* operator&() {
        std::cout << "重载的 & 运算符被调用\n";
        return this + 100; // 返回错误地址
    }
    
    const OverloadedAddress* operator&() const {
        std::cout << "重载的 & 运算符被调用\n";
        return this + 100; // 返回错误地址
    }
};

int main() {
    std::cout << "=== 杂项模块示例 ===\n\n";
    
    // 1. addressof - 获取对象实际地址
    std::cout << "1. addressof:\n";
    OverloadedAddress obj{42};
    
    std::cout << "使用 & 运算符: " << &obj << "\n";
    std::cout << "使用 addressof: " << std::addressof(obj) << "\n";
    std::cout << "实际值: " << std::addressof(obj)->value << "\n\n";
    
    // 2. to_address - 从指针类获取原始指针
    std::cout << "2. to_address:\n";
    int x = 100;
    int* ptr = &x;
    std::shared_ptr<int> shared_ptr = std::make_shared<int>(200);
    
    std::cout << "原始指针: " << std::to_address(ptr) << "\n";
    std::cout << "共享指针: " << std::to_address(shared_ptr) << "\n";
    std::cout << "共享指针值: " << *std::to_address(shared_ptr) << "\n\n";
    
    // 3. align - 对齐指针
    std::cout << "3. align:\n";
    char buffer[100];
    std::size_t space = sizeof(buffer);
    
    void* original_ptr = buffer;
    void* aligned_ptr = std::align(16, 50, original_ptr, space);
    
    std::cout << "原始指针: " << (void*)buffer << "\n";
    std::cout << "对齐后指针: " << aligned_ptr << "\n";
    std::cout << "剩余空间: " << space << "\n\n";
    
    // 4. assume_aligned - 通知编译器指针已对齐
    std::cout << "4. assume_aligned:\n";
    alignas(16) int aligned_arr[4] = {1, 2, 3, 4};
    int* arr_ptr = aligned_arr;
    
    // 通知编译器指针已对齐，允许编译器进行优化
    int* assumed_aligned = std::assume_aligned<16>(arr_ptr);
    
    std::cout << "假设对齐的指针: " << assumed_aligned << "\n";
    std::cout << "值: ";
    for (int i = 0; i < 4; ++i) {
        std::cout << assumed_aligned[i] << " ";
    }
    std::cout << "\n\n";
    
    // 5. C++23 is_sufficiently_aligned (如果编译器支持)
    #if __cplusplus >= 202302L
    std::cout << "5. is_sufficiently_aligned:\n";
    alignas(32) char highly_aligned[64];
    bool is_aligned = std::is_sufficiently_aligned(highly_aligned, 32);
    std::cout << "是否至少32字节对齐: " << std::boolalpha << is_aligned << "\n\n";
    #endif
    
    // 6. C++23 start_lifetime_as (如果编译器支持)
    #if __cplusplus >= 202302L
    std::cout << "6. start_lifetime_as:\n";
    alignas(std::string) char str_storage[sizeof(std::string)];
    std::string* str_ptr = std::start_lifetime_as<std::string>(str_storage);
    new(str_ptr) std::string("C++23 生命周期开始");
    std::cout << *str_ptr << "\n";
    str_ptr->~std::string();
    #endif
    
    std::cout << "\n=== 杂项模块示例结束 ===\n";
    return 0;
}
```

### 4. 智能指针非成员操作模块

提供创建和管理智能指针的辅助函数。

**核心功能：**

- `make_shared`/`make_shared_for_overwrite`: 创建共享指针
- `allocate_shared`/`allocate_shared_for_overwrite`: 使用分配器创建共享指针
- `static_pointer_cast`/`dynamic_pointer_cast`: 共享指针类型转换
- `const_pointer_cast`/`reinterpret_pointer_cast`: 共享指针常量性和类型重新解释

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Base {
public:
    virtual ~Base() = default;
    virtual void print() const { std::cout << "Base\n"; }
};

class Derived : public Base {
public:
    void print() const override { std::cout << "Derived\n"; }
    void derivedMethod() const { std::cout << "Derived特有方法\n"; }
};

class AnotherClass {
public:
    void print() const { std::cout << "AnotherClass\n"; }
};

int main() {
    std::cout << "=== 智能指针非成员操作模块示例 ===\n\n";
    
    // 1. make_shared - 创建共享指针
    std::cout << "1. make_shared:\n";
    auto shared_int = std::make_shared<int>(42);
    std::cout << "值: " << *shared_int << ", 引用计数: " << shared_int.use_count() << "\n";
    
    auto shared_vec = std::make_shared<std::vector<int>>(5, 10);
    std::cout << "向量大小: " << shared_vec->size() << "\n\n";
    
    // 2. make_shared_for_overwrite - C++20 创建未初始化的共享指针
    std::cout << "2. make_shared_for_overwrite (C++20):\n";
    #if __cplusplus >= 202002L
    auto shared_uninit = std::make_shared_for_overwrite<int>();
    // 需要后续初始化
    *shared_uninit = 100;
    std::cout << "未初始化共享指针的值: " << *shared_uninit << "\n\n";
    #endif
    
    // 3. allocate_shared - 使用分配器创建共享指针
    std::cout << "3. allocate_shared:\n";
    std::allocator<int> alloc;
    auto allocated_shared = std::allocate_shared<int>(alloc, 999);
    std::cout << "使用分配器创建的共享指针值: " << *allocated_shared << "\n\n";
    
    // 4. allocate_shared_for_overwrite - C++20 使用分配器创建未初始化的共享指针
    std::cout << "4. allocate_shared_for_overwrite (C++20):\n";
    #if __cplusplus >= 202002L
    auto allocated_uninit = std::allocate_shared_for_overwrite<int>(alloc);
    // 需要后续初始化
    *allocated_uninit = 777;
    std::cout << "使用分配器创建的未初始化共享指针值: " << *allocated_uninit << "\n\n";
    #endif
    
    // 5. 指针转换函数
    std::cout << "5. 指针转换函数:\n";
    
    // 创建派生类共享指针
    std::shared_ptr<Derived> derived_ptr = std::make_shared<Derived>();
    
    // static_pointer_cast - 静态向下转换
    std::shared_ptr<Base> base_ptr = std::static_pointer_cast<Base>(derived_ptr);
    base_ptr->print();
    
    // dynamic_pointer_cast - 动态向下转换
    std::shared_ptr<Derived> back_to_derived = 
        std::dynamic_pointer_cast<Derived>(base_ptr);
    if (back_to_derived) {
        back_to_derived->derivedMethod();
    }
    
    // const_pointer_cast - 移除const
    const std::shared_ptr<const int> const_ptr = std::make_shared<const int>(123);
    std::shared_ptr<int> non_const_ptr = std::const_pointer_cast<int>(const_ptr);
    *non_const_ptr = 456;
    std::cout << "修改后的值: " << *non_const_ptr << "\n";
    
    // reinterpret_pointer_cast - 重新解释指针类型
    std::shared_ptr<AnotherClass> another_ptr = 
        std::reinterpret_pointer_cast<AnotherClass>(derived_ptr);
    another_ptr->print();
    
    std::cout << "\n=== 智能指针非成员操作模块示例结束 ===\n";
    return 0;
}
```

## 4. allocate/deallocate和::operator new/delete

* `std::allocator` 的 `allocate()` 和 `deallocate()` 方法本质上是 `::operator new` 和 `::operator delete` 的封装，但提供了更高级的、类型安全的接口。

* 虽然功能上等价，但 `std::allocator` 提供了几个重要优势：
  * **类型安全**：`alloc.allocate(5)` 明确表示分配5个 `int` 对象，而不需要手动计算字节数。
  * **可移植性**：`std::allocator` 是标准库的一部分，保证了跨平台的兼容性。
  * **可自定义**：可以创建自定义分配器，实现特定的内存管理策略，同时保持相同的接口。
  * **与STL容器集成**：STL容器（如 `vector`、`list` 等）使用分配器接口，因此可以轻松替换为自定义分配器。
  * **异常安全**：标准分配器提供了更强的异常安全保证。
  * **调试支持**：在某些实现中，标准分配器可能包含额外的调试和边界检查功能。

* 何时选择直接使用 `::operator new/delete
  * 需要分配原始内存（不涉及对象构造）
  * 实现极低级别的内存管理
  * 与C代码交互，需要与 `malloc/free` 兼容的接口

## 5. std::aloocate_traits作用

`std::allocator_traits` 是一个非常重要的 C++ 标准库组件，它提供了**统一的方式**来与各种类型的分配器（allocators）进行交互，<u>无论这些分配器是否实现了所有可能的方法</u>。

`std::allocator_traits` 的主要作用总结为：

1. **提供统一接口**：让代码能够以一致的方式使用任何类型的分配器
2. **提供默认实现**：为分配器可能缺少的方法提供合理的默认行为
3. **简化代码**：避免了复杂的 SFINAE 或模板元编程来检查方法是否存在
4. **增强灵活性**：允许创建最小化的分配器，同时保持与标准库的兼容性

### （1）为什么需要 `std::allocator_traits`？

在 C++ 中，分配器可以有不同的实现方式：
1. **最小分配器**：只实现 `allocate()` 和 `deallocate()`
2. **完整分配器**：实现所有可选方法（如 `construct()`, `destroy()`, `max_size()` 等）

如果没有 `std::allocator_traits`，使用分配器的代码需要检查每个方法是否存在，这会非常复杂且容易出错。

### （2）`std::allocator_traits` 的主要功能

#### a. 提供统一的接口
无论分配器是否实现了某个方法，`std::allocator_traits` 都提供一个统一的调用方式：

```cpp
template<typename Alloc>
void use_allocator(Alloc& alloc) {
    // 使用 traits 而不是直接调用分配器方法
    typename std::allocator_traits<Alloc>::pointer p = 
        std::allocator_traits<Alloc>::allocate(alloc, 1);
    
    // 构造对象（即使分配器没有 construct() 方法）
    std::allocator_traits<Alloc>::construct(alloc, p, 42);
    
    // 销毁对象（即使分配器没有 destroy() 方法）
    std::allocator_traits<Alloc>::destroy(alloc, p);
    
    // 释放内存
    std::allocator_traits<Alloc>::deallocate(alloc, p, 1);
}
```

#### b. 提供默认实现
对于分配器可能没有实现的方法，`std::allocator_traits` 提供了合理的默认实现：

| 方法                                      | 默认行为                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| `construct()`                             | 使用 placement new                                           |
| `destroy()`                               | 直接调用析构函数                                             |
| `max_size()`                              | 返回 `std::numeric_limits<size_type>::max() / sizeof(value_type)` |
| `select_on_container_copy_construction()` | 返回分配器的副本                                             |

#### c. 类型萃取

`std::allocator_traits` 提供了与分配器相关的类型信息：

```cpp
std::allocator<int> alloc;
using traits = std::allocator_traits<decltype(alloc)>;

// 获取指针类型
traits::pointer p;
// 获取常量指针类型
traits::const_pointer cp;
// 获取大小类型
traits::size_type size;
// 获取差值类型
traits::difference_type diff;
```

### （3）实际示例

#### a. 没有 `std::allocator_traits` 的复杂代码：

```cpp
template<typename Alloc, typename... Args>
void construct_if_available(Alloc& alloc, typename Alloc::pointer p, Args&&... args) {
    // 需要检查分配器是否有 construct 方法
    if constexpr (std::is_invocable_v<decltype(&Alloc::construct), Alloc, decltype(p), Args...>) {
        alloc.construct(p, std::forward<Args>(args)...);
    } else {
        // 手动实现
        ::new (static_cast<void*>(p)) typename Alloc::value_type(std::forward<Args>(args)...);
    }
}
```

#### b. 使用 `std::allocator_traits` 的简洁代码：

```cpp
template<typename Alloc, typename... Args>
void construct_with_traits(Alloc& alloc, typename std::allocator_traits<Alloc>::pointer p, Args&&... args) {
    // 无论分配器如何实现，都使用统一的接口
    std::allocator_traits<Alloc>::construct(alloc, p, std::forward<Args>(args)...);
}
```

#### c. 在容器中的使用

标准库容器（如 `vector`, `list`, `map` 等）都使用 `std::allocator_traits` 来与分配器交互：

```cpp
template<typename T, typename Alloc = std::allocator<T>>
class vector {
private:
    using traits = std::allocator_traits<Alloc>;
    Alloc alloc_;
    T* data_;
    size_t size_, capacity_;
    
public:
    void push_back(const T& value) {
        if (size_ == capacity_) {
            // 扩容...
        }
        // 使用 traits 来构造对象
        traits::construct(alloc_, data_ + size_, value);
        size_++;
    }
    
    ~vector() {
        // 使用 traits 来销毁对象
        for (size_t i = 0; i < size_; i++) {
            traits::destroy(alloc_, data_ + i);
        }
        // 释放内存
        traits::deallocate(alloc_, data_, capacity_);
    }
};
```



# 三、`<memory_resource>` 

## 1. 概述

C++17 引入了多态内存资源（Polymorphic Memory Resources）的概念，通过 `<memory_resource>` 头文件提供了一套灵活的内存管理工具。这些工具允许开发者在运行时选择不同的内存分配策略，而不需要改变代码结构。

### （1）`std::pmr::memory_resource`

这是所有内存资源的抽象基类，定义了内存分配的接口。

```cpp
class memory_resource {
public:
    virtual ~memory_resource() = default;
    
    void* allocate(size_t bytes, size_t alignment = alignof(max_align_t));
    void deallocate(void* p, size_t bytes, size_t alignment = alignof(max_align_t));
    bool is_equal(const memory_resource& other) const noexcept;
    
protected:
    virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
    virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0;
    virtual bool do_is_equal(const memory_resource& other) const noexcept = 0;
};
```

### （2）`std::pmr::polymorphic_allocator`

这是一个模板类，包装了 `memory_resource`，提供了标准分配器接口。

```cpp
template <class T>
class polymorphic_allocator {
public:
    using value_type = T;
    
    polymorphic_allocator(memory_resource* r) noexcept;
    
    T* allocate(size_t n);
    void deallocate(T* p, size_t n);
    
    memory_resource* resource() const;
};
```

### （3）预定义的内存资源

#### `std::pmr::synchronized_pool_resource`
线程安全的内存池资源，管理不同大小的内存块池。

#### `std::pmr::unsynchronized_pool_resource`
非线程安全的内存池资源，性能更高但不适合多线程环境。

#### `std::pmr::monotonic_buffer_resource`
单调缓冲区资源，只在资源被销毁时才释放所有内存，性能最高。

### （4）工具函数

- `new_delete_resource()`: 返回使用全局 `operator new` 和 `operator delete` 的内存资源
- `null_memory_resource()`: 返回不执行任何分配的内存资源（总是抛出 `bad_alloc`）
- `get_default_resource()`: 获取默认的内存资源
- `set_default_resource()`: 设置默认的内存资源

## 2. 代码示例

blog https://cloud.tencent.com/developer/article/2382749

### （1）基本使用示例

```cpp
#include <iostream>
#include <memory_resource>
#include <vector>
#include <array>

int main() {
    // 使用默认的内存资源（通常是 new_delete_resource）
    std::pmr::vector<int> vec1;
    for (int i = 0; i < 10; ++i) {
        vec1.push_back(i);
    }
    
    // 使用单调缓冲区资源
    std::array<std::byte, 1024> buffer;
    std::pmr::monotonic_buffer_resource pool{
        buffer.data(), buffer.size(), 
        std::pmr::new_delete_resource()
    };
    
    std::pmr::vector<int> vec2(&pool);
    for (int i = 0; i < 10; ++i) {
        vec2.push_back(i);
    }
    
    std::cout << "Vector 1 size: " << vec1.size() << std::endl;
    std::cout << "Vector 2 size: " << vec2.size() << std::endl;
    
    return 0;
}
```

### （2）自定义内存资源示例

```cpp
#include <iostream>
#include <memory_resource>
#include <vector>
#include <cstdlib>

// 简单的自定义内存资源
class custom_memory_resource : public std::pmr::memory_resource {
private:
    struct allocation {
        void* ptr;
        size_t size;
        size_t alignment;
    };
    
    std::pmr::vector<allocation> allocations;
    
protected:
    void* do_allocate(size_t bytes, size_t alignment) override {
        void* ptr;
        if (alignment > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
            ptr = ::operator new(bytes, std::align_val_t{ alignment });
        }

        ptr = ::operator new(bytes);
        if (!ptr) {
            throw std::bad_alloc();
        }
        allocations.emplace_back(ptr, bytes, alignment);
        std::cout << "Allocated " << bytes << " bytes with alignment " 
                  << alignment << " at " << ptr << std::endl;
        return ptr;
    }
    
    void do_deallocate(void* p, size_t bytes, size_t alignment) override {
        for (auto it = allocations.begin(); it != allocations.end(); ++it) {
            if (it->ptr == p) {
                std::free(p);
                allocations.erase(it);
                std::cout << "Deallocated " << bytes << " bytes at " << p << std::endl;
                return;
            }
        }
        // 如果没找到，可能是其他地方分配的，直接释放
        std::free(p);
    }
    
    bool do_is_equal(const memory_resource& other) const noexcept override {
        return this == &other;
    }
    
public:
    ~custom_memory_resource() override {
        for (const auto& alloc : allocations) {
            std::free(alloc.ptr);
            std::cout << "Freed " << alloc.size << " bytes at " 
                      << alloc.ptr << " in destructor" << std::endl;
        }
    }

    auto* address() const {
        return std::addressof(allocations);
    }
};
int main() {
    custom_memory_resource custom_resource;
    std::cout << custom_resource.address() << " " << std::addressof(custom_resource) << "\n";

    // 使用自定义内存资源
    std::pmr::vector<int> vec(&custom_resource);
    
    for (int i = 0; i < 5; ++i) {
        vec.push_back(i);
        std::cout << "vec adddress: " << vec.data() << "\n";
    }

    return 0;
}
```

### （3）内存池示例

```cpp
#include <iostream>
#include <memory_resource>
#include <vector>

int main() {
    // 创建同步池资源
    std::pmr::synchronized_pool_resource pool;
    
    // 使用池资源
    std::pmr::vector<int> vec1(&pool);
    std::pmr::vector<double> vec2(&pool);
    
    for (int i = 0; i < 100; ++i) {
        vec1.push_back(i);
        vec2.push_back(i * 1.1);
    }
    
    std::cout << "Vector 1 size: " << vec1.size() << std::endl;
    std::cout << "Vector 2 size: " << vec2.size() << std::endl;
    
    return 0;
}
```

### （4）性能对比示例

```cpp
#include <iostream>
#include <memory_resource>
#include <vector>
#include <chrono>

constexpr size_t NUM_ELEMENTS = 100000;

void test_standard_allocator() {
    auto start = std::chrono::high_resolution_clock::now();
    
    std::vector<int> vec;
    for (int i = 0; i < NUM_ELEMENTS; ++i) {
        vec.push_back(i);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Standard allocator: " << duration.count() << " μs" << std::endl;
}

void test_pool_allocator() {
    std::pmr::unsynchronized_pool_resource pool;
    
    auto start = std::chrono::high_resolution_clock::now();
    
    std::pmr::vector<int> vec(&pool);
    for (int i = 0; i < NUM_ELEMENTS; ++i) {
        vec.push_back(i);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Pool allocator: " << duration.count() << " μs" << std::endl;
}

void test_monotonic_allocator() {
    // 使用足够大的缓冲区
    constexpr size_t BUFFER_SIZE = NUM_ELEMENTS * sizeof(int) * 2;
    std::unique_ptr<std::byte[]> buffer(new std::byte[BUFFER_SIZE]);
    std::pmr::monotonic_buffer_resource pool(buffer.get(), BUFFER_SIZE);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    std::pmr::vector<int> vec(&pool);
    for (int i = 0; i < NUM_ELEMENTS; ++i) {
        vec.push_back(i);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Monotonic allocator: " << duration.count() << " μs" << std::endl;
}

int main() {
    std::cout << "Performance comparison for " << NUM_ELEMENTS << " elements:" << std::endl;
    
    test_standard_allocator();
    test_pool_allocator();
    test_monotonic_allocator();
    
    return 0;
}
```

### C++17 前后内存池实现对比

#### C++17 之前使用 `std::allocator` 实现内存池

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <cstdlib>

// 简单的内存池分配器（C++17之前）
template <typename T>
class pool_allocator {
private:
    struct chunk {
        chunk* next;
    };
    
    chunk* free_list = nullptr;
    size_t chunk_size;
    
    void expand_pool(size_t n) {
        size_t size = (sizeof(T) > sizeof(chunk)) ? sizeof(T) : sizeof(chunk);
        chunk_size = n * size;
        
        char* memory = static_cast<char*>(std::malloc(chunk_size));
        if (!memory) {
            throw std::bad_alloc();
        }
        
        for (size_t i = 0; i < n; ++i) {
            chunk* c = reinterpret_cast<chunk*>(memory + i * size);
            c->next = free_list;
            free_list = c;
        }
    }
    
public:
    using value_type = T;
    
    pool_allocator() noexcept = default;
    
    template <typename U>
    pool_allocator(const pool_allocator<U>&) noexcept {}
    
    T* allocate(size_t n) {
        if (n != 1) {
            // 对于非单个元素的分配，回退到全局operator new
            return static_cast<T*>(std::malloc(n * sizeof(T)));
        }
        
        if (!free_list) {
            expand_pool(32); // 扩展池
        }
        
        chunk* c = free_list;
        free_list = free_list->next;
        return reinterpret_cast<T*>(c);
    }
    
    void deallocate(T* p, size_t n) {
        if (n != 1) {
            std::free(p);
            return;
        }
        
        chunk* c = reinterpret_cast<chunk*>(p);
        c->next = free_list;
        free_list = c;
    }
};

template <typename T, typename U>
bool operator==(const pool_allocator<T>&, const pool_allocator<U>&) {
    return true;
}

template <typename T, typename U>
bool operator!=(const pool_allocator<T>&, const pool_allocator<U>&) {
    return false;
}

int main() {
    std::vector<int, pool_allocator<int>> vec;
    for (int i = 0; i < 100; ++i) {
        vec.push_back(i);
    }
    
    std::cout << "Vector size: " << vec.size() << std::endl;
    return 0;
}
```

#### C++17 使用 `memory_resource` 实现内存池

```cpp
#include <iostream>
#include <memory_resource>
#include <vector>

int main() {
    // 使用标准库提供的池资源
    std::pmr::unsynchronized_pool_resource pool;
    
    std::pmr::vector<int> vec(&pool);
    for (int i = 0; i < 100; ++i) {
        vec.push_back(i);
    }
    
    std::cout << "Vector size: " << vec.size() << std::endl;
    return 0;
}
```

#### 对比表格

| 特性             | C++17 之前（自定义分配器） | C++17（memory_resource）        |
| ---------------- | -------------------------- | ------------------------------- |
| **实现复杂度**   | 高，需要手动实现所有功能   | 低，标准库提供完整实现          |
| **线程安全**     | 需要手动实现同步机制       | 提供同步和非同步版本            |
| **内存策略**     | 需要手动实现不同策略       | 提供多种预定义策略              |
| **灵活性**       | 修改策略需要修改代码       | 运行时动态选择策略              |
| **标准兼容性**   | 需要实现完整的分配器接口   | 与标准容器无缝集成              |
| **性能优化**     | 需要手动优化               | 标准库实现已经过优化            |
| **内存监控**     | 需要手动添加               | 可以通过继承memory_resource实现 |
| **代码可维护性** | 低，每个分配器需要单独维护 | 高，统一接口和实现              |

## 3. 总结

C++17 的 `<memory_resource>` 头文件引入了多态内存资源的概念，极大地简化了内存管理的复杂性。主要优势包括：

1. **运行时多态性**：可以在运行时选择不同的内存分配策略
2. **预定义策略**：提供了多种高效的内存资源实现
3. **简化接口**：通过 `polymorphic_allocator` 提供统一接口
4. **性能优化**：标准库实现经过高度优化
5. **线程安全**：提供线程安全和非线程安全的版本

相比于 C++17 之前需要手动实现分配器的方式，`memory_resource` 提供了更简洁、更灵活、更高效的内存管理解决方案。特别是对于需要高性能内存分配的场景，如游戏开发、高频交易等，这些工具可以显著提高应用程序的性能和可维护性。

使用 `memory_resource` 的主要步骤：
1. 选择合适的内存资源类型
2. 创建内存资源实例
3. 创建使用该资源的 `polymorphic_allocator`
4. 将分配器传递给容器

这种设计使得内存策略的选择成为运行时决策，而不是编译时决策，大大提高了代码的灵活性和可配置性。
