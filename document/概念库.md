# 一、C++20 `<concepts>` 概念库详解



**视频详细介绍**

https://www.bilibili.com/list/watchlater/?bvid=BV1pH9SYnEji&oid=114121727089552&watchlater_cfg=%7B%22viewed%22%3A0%2C%22key%22%3A%22%E6%A6%82%E5%BF%B5%22%2C%22asc%22%3Afalse%7D



`<concepts>` 头文件是 C++20 标准库的重要组成部分，它提供了一组预定义的概念（concepts），用于约束模板参数，使模板编程更加直观、安全且易于调试。

## 1. 概念定义方式

### (1) 使用 `concept` 关键字定义概念

```cpp
template<typename T>
concept MyConcept = requires(T a, T b) {
    { a + b } -> std::same_as<T>;
    { a == b } -> std::convertible_to<bool>;
};
```

### (2) 使用 `requires` 子句定义概念

```cpp
template<typename T>
concept Addable = requires(T x, T y) {
    x + y;
};
```

### (3) 组合现有概念定义新概念

```cpp
template<typename T>
concept Numeric = std::integral<T> || std::floating_point<T>;
```

### (4) 嵌套概念定义

```cpp
template<typename T>
concept ComplexConcept = requires(T t) {
    requires std::default_initializable<T>;
    requires std::copyable<T>;
    { t.process() } -> std::same_as<void>;
};
```

## 2. 概念与 SFINAE 的对比

| 特性       | 概念 (Concepts)    | SFINAE                 |
| ---------- | ------------------ | ---------------------- |
| 语法简洁性 | 简洁直观           | 复杂冗长               |
| 可读性     | 高，自文档化       | 低，难以理解           |
| 错误信息   | 清晰明确           | 晦涩难懂               |
| 编译速度   | 通常更快           | 通常较慢               |
| 组合能力   | 强大，支持逻辑运算 | 有限，需要复杂技巧     |
| 维护难度   | 低                 | 高                     |
| 表达能力   | 强，支持多种约束   | 有限，主要基于类型特征 |

## 3. 完整示例代码

```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <functional>
#include <type_traits>
#include <memory>
#include <algorithm>

// 1. 核心语言概念示例
template<std::same_as<int> T>
void process_same_as_int(T value) {
    std::cout << "Processing int: " << value << std::endl;
}

template<std::derived_from<std::exception> T>
void handle_exception(const T& ex) {
    std::cout << "Exception derived from std::exception: " << ex.what() << std::endl;
}

template<std::convertible_to<std::string> T>
void print_convertible_to_string(const T& value) {
    std::string str = value;
    std::cout << "Converted to string: " << str << std::endl;
}

template<typename T, typename U>
requires std::common_with<T, U>
auto find_common_type(const T& a, const U& b) {
    using CommonType = std::common_type_t<T, U>;
    return CommonType(a) + CommonType(b);
}

// 2. 类型特征概念示例
template<std::integral T>
T multiply_integral(T a, T b) {
    return a * b;
}

template<std::signed_integral T>
T negate_signed(T value) {
    return -value;
}

template<std::unsigned_integral T>
T increment_unsigned(T value) {
    return value + 1;
}

template<std::floating_point T>
T square_floating(T value) {
    return value * value;
}

// 3. 构造和赋值概念示例
template<std::default_initializable T>
T create_default() {
    return T{};
}

template<std::move_constructible T>
void move_to_vector(std::vector<T>& vec, T&& value) {
    vec.push_back(std::move(value));
}

template<std::copy_constructible T>
void copy_to_vector(std::vector<T>& vec, const T& value) {
    vec.push_back(value);
}

template<std::assignable_from<int> T>
void assign_int_value(T& obj, int value) {
    obj = value;
}

// 4. 交换概念示例
template<std::swappable T>
void swap_values(T& a, T& b) {
    std::swap(a, b);
}

template<typename T, typename U>
requires std::swappable_with<T, U>
void swap_different(T& a, U& b) {
    using std::swap;
    swap(a, b);
}

// 5. 比较概念示例
template<std::equality_comparable T>
bool are_equal(const T& a, const T& b) {
    return a == b;
}

template<typename T, typename U>
requires std::equality_comparable_with<T, U>
bool are_equal_different(const T& a, const U& b) {
    return a == b;
}

template<std::totally_ordered T>
T get_min(const T& a, const T& b) {
    return a < b ? a : b;
}

template<typename T, typename U>
requires std::totally_ordered_with<T, U>
auto get_min_different(const T& a, const U& b) {
    return a < b ? a : b;
}

// 6. 对象概念示例
template<std::movable T>
void process_movable(T&& value) {
    T moved = std::move(value);
    std::cout << "Processed movable object" << std::endl;
}

template<std::copyable T>
void process_copyable(const T& value) {
    T copy = value;
    std::cout << "Processed copyable object" << std::endl;
}

template<std::semiregular T>
void process_semiregular() {
    T obj1; // 默认构造
    T obj2 = obj1; // 拷贝构造
    obj1 = obj2; // 拷贝赋值
    std::cout << "Processed semiregular object" << std::endl;
}

template<std::regular T>
void process_regular(const T& a, const T& b) {
    // 常规类型支持所有值语义操作和等价比较
    T default_obj;
    T copy = a;
    bool equal = (a == b);
    std::cout << "Processed regular object, equality: " << equal << std::endl;
}

// 7. 可调用概念示例
template<std::invocable F>
auto call_invocable(F&& func) {
    return std::forward<F>(func)();
}

template<std::predicate P, typename T>
bool check_predicate(P&& pred, const T& value) {
    return std::forward<P>(pred)(value);
}

template<std::relation R, typename T, typename U>
bool check_relation(R&& rel, const T& a, const U& b) {
    return std::forward<R>(rel)(a, b);
}

template<std::equivalence_relation R, typename T>
bool check_equivalence(R&& rel, const T& a, const T& b) {
    return std::forward<R>(rel)(a, b);
}

template<std::strict_weak_order R, typename T>
bool check_strict_weak_order(R&& rel, const T& a, const T& b) {
    return std::forward<R>(rel)(a, b);
}

// 8. 自定义概念示例
template<typename T>
concept Printable = requires(std::ostream& os, const T& value) {
    { os << value } -> std::same_as<std::ostream&>;
};

template<Printable T>
void print(const T& value) {
    std::cout << value << std::endl;
}

template<typename T>
concept HasSize = requires(const T& container) {
    { container.size() } -> std::integral;
};

template<HasSize Container>
auto get_size(const Container& container) {
    return container.size();
}

// 9. 复杂概念组合示例
template<typename T>
concept Container = requires(T container) {
    requires std::default_initializable<T>;
    requires HasSize<T>;
    requires std::equality_comparable<T>;
    typename T::value_type;
    { container.begin() } -> std::same_as<typename T::iterator>;
    { container.end() } -> std::same_as<typename T::iterator>;
};

template<Container C>
void process_container(const C& container) {
    std::cout << "Container size: " << container.size() << std::endl;
    for (const auto& item : container) {
        std::cout << item << " ";
    }
    std::cout << std::endl;
}

// 10. 自定义点对象示例
struct MyType {
    int value;
    
    friend void swap(MyType& a, MyType& b) {
        std::swap(a.value, b.value);
        std::cout << "Custom swap called" << std::endl;
    }
};

// 自定义类型示例
class MyException : public std::exception {
public:
    const char* what() const noexcept override {
        return "MyException";
    }
};

class MyString {
public:
    MyString(const char* str) : data(str) {}
    operator std::string() const { return data; }
    
private:
    std::string data;
};

// 主函数
int main() {
    std::cout << "=== C++20 <concepts> 概念库示例 ===\n\n";
    
    // 1. 核心语言概念示例
    std::cout << "1. 核心语言概念:\n";
    process_same_as_int(42); // OK
    
    MyException ex;
    handle_exception(ex); // OK
    
    MyString my_str("Hello");
    print_convertible_to_string(my_str); // OK
    
    auto common_result = find_common_type(10, 3.14);
    std::cout << "Common type result: " << common_result << std::endl;
    std::cout << std::endl;
    
    // 2. 类型特征概念示例
    std::cout << "2. 类型特征概念:\n";
    std::cout << "Multiply integral: " << multiply_integral(5, 3) << std::endl;
    std::cout << "Negate signed: " << negate_signed(-10) << std::endl;
    std::cout << "Increment unsigned: " << increment_unsigned(5u) << std::endl;
    std::cout << "Square floating: " << square_floating(3.14) << std::endl;
    std::cout << std::endl;
    
    // 3. 构造和赋值概念示例
    std::cout << "3. 构造和赋值概念:\n";
    int default_int = create_default<int>();
    std::cout << "Default int: " << default_int << std::endl;
    
    std::vector<std::string> strings;
    std::string str = "Hello";
    copy_to_vector(strings, str);
    move_to_vector(strings, std::string("World"));
    
    int assignable_value = 0;
    assign_int_value(assignable_value, 42);
    std::cout << "Assigned value: " << assignable_value << std::endl;
    std::cout << std::endl;
    
    // 4. 交换概念示例
    std::cout << "4. 交换概念:\n";
    int a = 5, b = 10;
    swap_values(a, b);
    std::cout << "Swapped values: " << a << ", " << b << std::endl;
    
    long c = 15;
    swap_different(b, c);
    std::cout << "Swapped different types: " << b << ", " << c << std::endl;
    std::cout << std::endl;
    
    // 5. 比较概念示例
    std::cout << "5. 比较概念:\n";
    std::cout << "Are equal: " << are_equal(5, 5) << std::endl;
    std::cout << "Are equal different: " << are_equal_different(5, 5.0) << std::endl;
    std::cout << "Get min: " << get_min(3, 7) << std::endl;
    std::cout << "Get min different: " << get_min_different(3.5, 2) << std::endl;
    std::cout << std::endl;
    
    // 6. 对象概念示例
    std::cout << "6. 对象概念:\n";
    std::string movable_str = "Movable";
    process_movable(std::move(movable_str));
    
    std::string copyable_str = "Copyable";
    process_copyable(copyable_str);
    
    process_semiregular<std::string>();
    process_regular(std::string("hello"), std::string("hello"));
    std::cout << std::endl;
    
    // 7. 可调用概念示例
    std::cout << "7. 可调用概念:\n";
    auto lambda = []() { return 42; };
    std::cout << "Invocable result: " << call_invocable(lambda) << std::endl;
    
    auto is_even = [](int x) { return x % 2 == 0; };
    std::cout << "Predicate check: " << check_predicate(is_even, 4) << std::endl;
    
    auto less_than = [](int a, int b) { return a < b; };
    std::cout << "Relation check: " << check_relation(less_than, 3, 5) << std::endl;
    
    auto equivalent = [](int a, int b) { return a % 2 == b % 2; };
    std::cout << "Equivalence relation: " << check_equivalence(equivalent, 2, 4) << std::endl;
    
    std::cout << "Strict weak order: " << check_strict_weak_order(less_than, 3, 5) << std::endl;
    std::cout << std::endl;
    
    // 8. 自定义概念示例
    std::cout << "8. 自定义概念:\n";
    print("Printable string");
    print(42);
    
    std::vector<int> numbers = {1, 2, 3};
    std::cout << "Container size: " << get_size(numbers) << std::endl;
    std::cout << std::endl;
    
    // 9. 复杂概念组合示例
    std::cout << "9. 复杂概念组合:\n";
    process_container(numbers);
    std::cout << std::endl;
    
    // 10. 自定义点对象示例
    std::cout << "10. 自定义点对象:\n";
    MyType x{1}, y{2};
    std::ranges::swap(x, y); // 使用自定义点对象
    std::cout << "After swap: " << x.value << ", " << y.value << std::endl;
    
    return 0;
}
```

## 4. 概念的优势总结

1. **更清晰的错误信息**：当模板参数不满足概念约束时，编译器会提供更具体、更易理解的错误信息。

2. **更简洁的语法**：概念提供了比 SFINAE 更简洁、更直观的语法来表达约束条件。

3. **更好的代码可读性**：概念使模板代码更易于理解和维护，因为它们明确表达了模板参数的期望。

4. **更强的表达能力**：概念支持逻辑组合（与、或、非），可以表达复杂的约束条件。

5. **编译时性能提升**：概念可以在编译早期检查约束条件，避免不必要的实例化。

6. **更好的工具支持**：IDE 和静态分析工具可以更好地理解和使用概念。

## 
