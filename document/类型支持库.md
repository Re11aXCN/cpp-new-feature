# 头文件

```c
#include <typeindex>
#include <typeinfo>
#include <type_traits>
#include <cstddef>
#include <stdfloat>
```



# `typeid` 运算符

查询类型的相关信息。

在必须得知[多态对象](https://cppreference.cn/w/cpp/language/type#Dynamic_type)的[动态类型](https://cppreference.cn/w/cpp/language/object#Polymorphic_objects)，以及用于静态类型标识时使用。

##  语法

|                                   |      |      |
| --------------------------------- | ---- | ---- |
| `**typeid (**` type `**)**`       | (1)  |      |
|                                   |      |      |
| `**typeid (**` expression `**)**` | (2)  |      |
|                                   |      |      |

typeid 表达式是[左值表达式](https://cppreference.cn/w/cpp/language/value_category)，它引用具有[静态存储期](https://cppreference.cn/w/cpp/language/static)的对象，该对象是多态类型 [std::type_info](https://cppreference.cn/w/cpp/types/type_info) 或其派生类型的 const 限定版本。

如果使用 typeid 时，[std::type_info](https://cppreference.cn/w/cpp/types/type_info) 的标准库定义不可见，则程序是非良构的。

##  解释

如果 type 或 expression 的类型是类类型或类类型的引用，则该类类型不能是[不完整类型](https://cppreference.cn/w/cpp/language/incomplete_type)。

\1) 引用代表 type 的 [std::type_info](https://cppreference.cn/w/cpp/types/type_info) 对象。如果 type 是引用类型，则结果引用代表被引用类型的 cv 无限定版本的 [std::type_info](https://cppreference.cn/w/cpp/types/type_info) 对象。

\2) 检查 expression

- 如果 expression 是标识[多态类型](https://cppreference.cn/w/cpp/language/object#Polymorphic_objects)（即声明或继承至少一个[虚函数](https://cppreference.cn/w/cpp/language/virtual)的类）[左值](https://cppreference.cn/w/cpp/language/value_category#lvalue)(直到 C++11)标识[多态类型](https://cppreference.cn/w/cpp/language/object#Polymorphic_objects)（即声明或继承至少一个[虚函数](https://cppreference.cn/w/cpp/language/virtual)的类）对象的 [泛左值](https://cppreference.cn/w/cpp/language/value_category#glvalue)(自 C++11 起)表达式，则 typeid 表达式求值该表达式，然后引用代表表达式的动态类型的 [std::type_info](https://cppreference.cn/w/cpp/types/type_info) 对象。



- 否则，typeid [不对表达式求值](https://cppreference.cn/w/cpp/language/expressions#Potentially-evaluated_expressions)，并且它标识的 [std::type_info](https://cppreference.cn/w/cpp/types/type_info) 对象代表表达式的静态类型。不执行左值到右值、数组到指针或函数到指针的转换。
- 然而，对于纯右值参数，会（形式上）执行[临时量实质化](https://cppreference.cn/w/cpp/language/implicit_conversion#Temporary_materialization)：实参必须在 typeid 表达式出现的语境中可析构。(自 C++17)



如果 type 或 expression 的类型是 cv 限定的，则 typeid 的结果引用代表 cv 无限定类型的 [std::type_info](https://cppreference.cn/w/cpp/types/type_info) 对象（即 typeid(const T) == typeid(T)）。

如果在构造或析构期间（在析构函数或构造函数中，包括构造函数的[初始化器列表](https://cppreference.cn/w/cpp/language/initializer_list)或[默认成员初始化器](https://cppreference.cn/w/cpp/language/data_members#Member_initialization)）对对象使用 typeid，则此 typeid 引用的 [std::type_info](https://cppreference.cn/w/cpp/types/type_info) 对象代表正在构造或析构的类，即使它不是最派生类。

1. [↑](https://cppreference.cn/w/cpp/language/typeid#cite_ref-1) 在其他语境中，对此类 expression 求值会导致未定义行为。

##  注意事项

当应用于多态类型的表达式时，**typeid 表达式的求值可能涉及运行时开销（虚函数表查找）**，否则 typeid 表达式在编译时解析。

未指明是否在程序结束时执行 typeid 引用的对象的析构函数。

不保证对同一类型的所有 typeid 表达式求值都将引用相同的 [std::type_info](https://cppreference.cn/w/cpp/types/type_info) 对象，尽管它们将比较相等，但这些 `type_info` 对象的 [std::type_info::hash_code](https://cppreference.cn/w/cpp/types/type_info/hash_code) 将是相同的，它们的 [std::type_index](https://cppreference.cn/w/cpp/types/type_index) 也将是相同的。

```c
const std::type_info& ti1 = typeid(A);
const std::type_info& ti2 = typeid(A);
 
assert(&ti1 == &ti2); // not guaranteed
assert(ti1 == ti2); // guaranteed
assert(ti1.hash_code() == ti2.hash_code()); // guaranteed
assert(std::type_index(ti1) == std::type_index(ti2)); // guaranteed
```

##  关键词

[`typeid`](https://cppreference.cn/w/cpp/keyword/typeid)

##  示例

示例展示了使用 type_info::name 返回完整类型名称的实现之一的输出；如果使用 gcc 或类似工具，请通过 c++filt -t 过滤。

运行此代码



```c
#include <iostream>
#include <string>
#include <typeinfo>
 
struct Base {}; // non-polymorphic
struct Derived : Base {};
 
struct Base2 { virtual void foo() {} }; // polymorphic
struct Derived2 : Base2 {};
 
int main()
{
    int myint = 50;
    std::string mystr = "string";
    double *mydoubleptr = nullptr;
 
    std::cout << "myint has type: " << typeid(myint).name() << '\n'
              << "mystr has type: " << typeid(mystr).name() << '\n'
              << "mydoubleptr has type: " << typeid(mydoubleptr).name() << '\n';
 
    // std::cout << myint is a glvalue expression of polymorphic type; it is evaluated
    const std::type_info& r1 = typeid(std::cout << myint); // side-effect: prints 50
    std::cout << '\n' << "std::cout<<myint has type : " << r1.name() << '\n';
 
    // std::printf() is not a glvalue expression of polymorphic type; NOT evaluated
    const std::type_info& r2 = typeid(std::printf("%d\n", myint));
    std::cout << "printf(\"%d\\n\",myint) has type : " << r2.name() << '\n';
 
    // Non-polymorphic lvalue is a static type
    Derived d1;
    Base& b1 = d1;
    std::cout << "reference to non-polymorphic base: " << typeid(b1).name() << '\n';
 
    Derived2 d2;
    Base2& b2 = d2;
    std::cout << "reference to polymorphic base: " << typeid(b2).name() << '\n';
 
    try
    {
        // dereferencing a null pointer: okay for a non-polymorphic expression
        std::cout << "mydoubleptr points to " << typeid(*mydoubleptr).name() << '\n'; 
        // dereferencing a null pointer: not okay for a polymorphic lvalue
        Derived2* bad_ptr = nullptr;
        std::cout << "bad_ptr points to... ";
        std::cout << typeid(*bad_ptr).name() << '\n';
    }
    catch (const std::bad_typeid& e)
    {
        std::cout << " caught " << e.what() << '\n';
    }
}
```



可能的输出

```c
======== output from Clang ========
myint has type: i
mystr has type: NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE
mydoubleptr has type: Pd
50
std::cout<<myint has type : NSt3__113basic_ostreamIcNS_11char_traitsIcEEEE
printf("%d\n",myint) has type : i
reference to non-polymorphic base: 4Base
reference to polymorphic base: 8Derived2
mydoubleptr points to d
bad_ptr points to...  caught std::bad_typeid
 
======== output from MSVC ========
myint has type: int
mystr has type: class std::basic_string<char,struct std::char_traits<char>,⮠
class std::allocator<char> >
mydoubleptr has type: double * __ptr64
50
std::cout<<myint has type : class std::basic_ostream<char,struct std::char_traits<char> >
printf("%d\n",myint) has type : int
reference to non-polymorphic base: struct Base
reference to polymorphic base: struct Derived2
mydoubleptr points to double
bad_ptr points to...  caught Attempted a typeid of nullptr pointer!
```



# <type_info>

类 `type_info` 存储关于类型的实现特定信息，包括类型的名称以及比较两个类型是否相等或排序顺序的方法。这是 [`typeid`](https://cppreference.cn/w/cpp/language/typeid) 运算符返回的类。

`type_info` 类既不是 [*CopyConstructible*](https://cppreference.cn/w/cpp/named_req/CopyConstructible) 也不是 [*CopyAssignable*](https://cppreference.cn/w/cpp/named_req/CopyAssignable)。

##  成员函数

| (构造函数)[已删除]                                           | 既没有默认构造函数也没有复制构造函数  (公共成员函数)         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ (析构函数)](https://cppreference.cn/w/cpp/types/type_info/~type_info)[虚函数] | 虚析构函数使 `type_info` 成为多态类  (虚公共成员函数)        |
| operator=[已删除]                                            | 不能被复制赋值  (公共成员函数)                               |
| [ operator==operator!=](https://cppreference.cn/w/cpp/types/type_info/operator_cmp)(在 C++20 中移除) | 检查对象是否引用同一类型  (公共成员函数)                     |
| [ before](https://cppreference.cn/w/cpp/types/type_info/before) | 检查被引用类型是否在实现定义的顺序中先于另一个 `type_info` 对象的被引用类型，即对被引用类型进行排序 对象在实现定义的顺序中，即对被引用类型进行排序  (公共成员函数) |
| [ hash_code](https://cppreference.cn/w/cpp/types/type_info/hash_code)(C++11) | 返回对于相同类型是相同的值  (公共成员函数)                   |
| [ name](https://cppreference.cn/w/cpp/types/type_info/name)  | 类型实现的定义名称  (公共成员函数)                           |

##  参见

| [ type_index](https://cppreference.cn/w/cpp/types/type_index)(C++11) | 围绕 `type_info` 对象的包装器，可以用作关联和无序关联容器中的索引  (类) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [`**typeid**`](https://cppreference.cn/w/cpp/language/typeid) | 查询类型的信息，返回表示该类型的 `std::type_info` 对象 (内置运算符) |

## name方法注意事项

* 返回一个实现定义的空终止字符字符串，其中包含类型的名称。 不提供任何保证； 特别是，对于几种类型，返回的字符串可能相同，并且在同一程序的多次调用之间可能会更改。

* 返回指针指向的数组的生命周期未指定，但实际上，**只要给定类型的 RTTI 数据结构存在，它就会持续存在**，除非从可以卸载的动态库加载，否则**它具有应用程序生命周期**。

* 一些实现（例如 MSVC、IBM、Oracle）生成人类可读的类型名称。 其他实现，最值得注意的是 gcc 和 clang，返回 mangled  name，这由 Itanium C++ ABI 指定。 可以使用特定于实现的 API（例如 `abi::__cxa_demangle` 直接或通过  `boost::core::demangle`）将 mangled name 转换为人类可读的形式。 它也可以通过命令行实用程序 `c++filt -t` 管道传输。



详细关于demangle 的博客解析，https://www.cnblogs.com/BloodAndBone/p/7912179.html



1. gcc、使用平台特定 API（abi::__cxa_demangle）反修饰。

```c

#include <iostream>
#include <typeinfo>
#include <cxxabi.h>

template <typename T>
std::string demangle() {
    int status;
    char* demangled = abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, &status);
    if (demangled) {
        std::string result(demangled);
        free(demangled);
        return result;
    }
    return typeid(T).name();
}

int main() {
    std::cout << demangle<std::vector<int>>() << '\n'; // 输出 "std::vector<int, std::allocator<int>>"
}
```

2. 使用boost/core/demangle.hpp、`c++filt -t`

```c
#include <boost/core/demangle.hpp>
#include <cstdlib>
#include <iostream>
#include <string>
#include <typeinfo>
 
struct Base { virtual ~Base() = default; };
struct Derived : Base {};
 
int main()
{
    Base b1;
    Derived d1;
 
    const Base* pb = &b1;
    std::cout << typeid(*pb).name() << '\n';
    pb = &d1;
    std::cout << typeid(*pb).name() << '\n';
 
    std::string real_name = boost::core::demangle(typeid(pb).name());
    std::cout << typeid(pb).name() << " => " << real_name << '\n';
 
    std::cout << "c++filt => " << std::flush;
    std::string s = typeid(pb).name();
    std::system(("c++filt -t " + s).data());
}
```



# <type_index>（type_info的包装类）

`type_index` 类是 [std::type_info](https://cppreference.cn/w/cpp/types/type_info) 对象的包装类，可以**<u>用作关联容器和无序关联容器的索引</u>**。与 `type_info` 对象的关联通过指针维护，因此 `type_index` 是 [*可复制构造 (CopyConstructible)*](https://cppreference.cn/w/cpp/named_req/CopyConstructible) 且 [*可复制赋值 (CopyAssignable)*](https://cppreference.cn/w/cpp/named_req/CopyAssignable) 的。

```c
#include <iostream>
#include <memory>
#include <string>
#include <typeindex>
#include <typeinfo>
#include <unordered_map>
 
struct A
{
    virtual ~A() {}
};
 
struct B : A {};
struct C : A {};
 
int main()
{
    std::unordered_map<std::type_index, std::string> type_names;
 
    type_names[std::type_index(typeid(int))] = "int";
    type_names[std::type_index(typeid(double))] = "double";
    type_names[std::type_index(typeid(A))] = "A";
    type_names[std::type_index(typeid(B))] = "B";
    type_names[std::type_index(typeid(C))] = "C";
 
    int i;
    double d;
    A a;
 
    // note that we're storing pointer to type A
    std::unique_ptr<A> b(new B);
    std::unique_ptr<A> c(new C);
 
    std::cout << "i is " << type_names[std::type_index(typeid(i))] << '\n';
    std::cout << "d is " << type_names[std::type_index(typeid(d))] << '\n';
    std::cout << "a is " << type_names[std::type_index(typeid(a))] << '\n';
    std::cout << "*b is " << type_names[std::type_index(typeid(*b))] << '\n';
    std::cout << "*c is " << type_names[std::type_index(typeid(*c))] << '\n';
}
```

# <type_traits>

## 元编程辅助方法定义

| 类                                                           |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 辅助类                                                       |                                                              |
| [ integral_constantbool_constant](https://cppreference.cn/w/cpp/types/integral_constant)(C++11)(C++17) | 具有指定值的指定类型的编译时常量  (类模板)                   |
| `true_type`                                                  | [std::integral_constant](https://cppreference.cn/w/cpp/types/integral_constant)<bool, true> |
| `false_type`                                                 | [std::integral_constant](https://cppreference.cn/w/cpp/types/integral_constant)<bool, false> |
| 基本类型类别                                                 |                                                              |
| [ is_void](https://cppreference.cn/w/cpp/types/is_void)(C++11) | 检查类型是否为 void  (类模板)                                |
| [ is_null_pointer](https://cppreference.cn/w/cpp/types/is_null_pointer)(C++11)(DR*) | 检查类型是否为 [std::nullptr_t](https://cppreference.cn/w/cpp/types/nullptr_t)  (类模板) |
| [ is_integral](https://cppreference.cn/w/cpp/types/is_integral)(C++11) | 检查类型是否为整型  (类模板)                                 |
| [ is_floating_point](https://cppreference.cn/w/cpp/types/is_floating_point)(C++11) | 检查类型是否为浮点类型  (类模板)                             |
| [ is_array](https://cppreference.cn/w/cpp/types/is_array)(C++11) | 检查类型是否为数组类型  (类模板)                             |
| [ is_enum](https://cppreference.cn/w/cpp/types/is_enum)(C++11) | 检查类型是否为枚举类型  (类模板)                             |
| [ is_union](https://cppreference.cn/w/cpp/types/is_union)(C++11) | 检查类型是否为联合体类型  (类模板)                           |
| [ is_class](https://cppreference.cn/w/cpp/types/is_class)(C++11) | 检查类型是否为非联合体类类型  (类模板)                       |
| [ is_function](https://cppreference.cn/w/cpp/types/is_function)(C++11) | 检查类型是否为函数类型  (类模板)                             |
| [ is_pointer](https://cppreference.cn/w/cpp/types/is_pointer)(C++11) | 检查类型是否为指针类型  (类模板)                             |
| [ is_lvalue_reference](https://cppreference.cn/w/cpp/types/is_lvalue_reference)(C++11) | 检查类型是否为*左值引用*  (类模板)                           |
| [ is_rvalue_reference](https://cppreference.cn/w/cpp/types/is_rvalue_reference)(C++11) | 检查类型是否为*右值引用*  (类模板)                           |
| [ is_member_object_pointer](https://cppreference.cn/w/cpp/types/is_member_object_pointer)(C++11) | 检查类型是否为非静态成员对象指针  (类模板)                   |
| [ is_member_function_pointer](https://cppreference.cn/w/cpp/types/is_member_function_pointer)(C++11) | 检查类型是否为非静态成员函数指针  (类模板)                   |
| 复合类型类别                                                 |                                                              |
| [ is_fundamental](https://cppreference.cn/w/cpp/types/is_fundamental)(C++11) | 检查类型是否为基本类型  (类模板)                             |
| [ is_arithmetic](https://cppreference.cn/w/cpp/types/is_arithmetic)(C++11) | 检查类型是否为算术类型  (类模板)                             |
| [ is_scalar](https://cppreference.cn/w/cpp/types/is_scalar)(C++11) | 检查类型是否为标量类型  (类模板)                             |
| [ is_object](https://cppreference.cn/w/cpp/types/is_object)(C++11) | 检查类型是否为对象类型  (类模板)                             |
| [ is_compound](https://cppreference.cn/w/cpp/types/is_compound)(C++11) | 检查类型是否为复合类型  (类模板)                             |
| [ is_reference](https://cppreference.cn/w/cpp/types/is_reference)(C++11) | 检查类型是否为*左值引用*或*右值引用*  (类模板)               |
| [ is_member_pointer](https://cppreference.cn/w/cpp/types/is_member_pointer)(C++11) | 检查类型是否为指向非静态成员函数或对象的指针  (类模板)       |
| 类型属性                                                     |                                                              |
| [ is_const](https://cppreference.cn/w/cpp/types/is_const)(C++11) | 检查类型是否带有 const 限定符  (类模板)                      |
| [ is_volatile](https://cppreference.cn/w/cpp/types/is_volatile)(C++11) | 检查类型是否带有 volatile 限定符  (类模板)                   |
| [ is_trivial](https://cppreference.cn/w/cpp/types/is_trivial)(C++11)(C++26 中已弃用) | 检查类型是否为平凡类型  (类模板)                             |
| [ is_trivially_copyable](https://cppreference.cn/w/cpp/types/is_trivially_copyable)(C++11) | 检查类型是否为可平凡复制类型  (类模板)                       |
| [ is_standard_layout](https://cppreference.cn/w/cpp/types/is_standard_layout)(C++11) | 检查类型是否为[标准布局](https://cppreference.cn/w/cpp/language/data_members#Standard-layout)类型  (类模板) |
| [ is_pod](https://cppreference.cn/w/cpp/types/is_pod)(C++11)(C++20 中已弃用) | 检查类型是否为 Plain-Old Data (POD) 类型  (类模板)           |
| [ is_literal_type](https://cppreference.cn/w/cpp/types/is_literal_type)(C++11)(C++17 中已弃用)(C++20 中已移除) | 检查类型是否为字面类型  (类模板)                             |
| [ has_unique_object_representations](https://cppreference.cn/w/cpp/types/has_unique_object_representations)(C++17) | 检查类型对象表示中的每个位是否对其值有贡献  (类模板)         |
| [ is_empty](https://cppreference.cn/w/cpp/types/is_empty)(C++11) | 检查类型是否为类（但不是联合体）类型且没有非静态数据成员  (类模板) |
| [ is_polymorphic](https://cppreference.cn/w/cpp/types/is_polymorphic)(C++11) | 检查类型是否为多态类类型  (类模板)                           |
| [ is_abstract](https://cppreference.cn/w/cpp/types/is_abstract)(C++11) | 检查类型是否为抽象类类型  (类模板)                           |
| [ is_final](https://cppreference.cn/w/cpp/types/is_final)(C++14) | 检查类型是否为 final 类类型  (类模板)                        |
| [ is_aggregate](https://cppreference.cn/w/cpp/types/is_aggregate)(C++17) | 检查类型是否为聚合类型  (类模板)                             |
| [ is_implicit_lifetime](https://cppreference.cn/w/cpp/types/is_implicit_lifetime)(C++23) | 检查类型是否为隐式生命周期类型  (类模板)                     |
| [ is_signed](https://cppreference.cn/w/cpp/types/is_signed)(C++11) | 检查类型是否为有符号算术类型  (类模板)                       |
| [ is_unsigned](https://cppreference.cn/w/cpp/types/is_unsigned)(C++11) | 检查类型是否为无符号算术类型  (类模板)                       |
| [ is_bounded_array](https://cppreference.cn/w/cpp/types/is_bounded_array)(C++20) | 检查类型是否为已知边界的数组类型  (类模板)                   |
| [ is_unbounded_array](https://cppreference.cn/w/cpp/types/is_unbounded_array)(C++20) | 检查类型是否为未知边界的数组类型  (类模板)                   |
| [ is_scoped_enum](https://cppreference.cn/w/cpp/types/is_scoped_enum)(C++23) | 检查类型是否为作用域枚举类型  (类模板)                       |

| 支持的操作                                                   |                                                            |
| ------------------------------------------------------------ | ---------------------------------------------------------- |
| [ is_constructibleis_trivially_constructibleis_nothrow_constructible](https://cppreference.cn/w/cpp/types/is_constructible)(C++11)(C++11)(C++11) | 检查类型是否具有特定参数的构造函数  (类模板)               |
| [ is_default_constructibleis_trivially_default_constructibleis_nothrow_default_constructible](https://cppreference.cn/w/cpp/types/is_default_constructible)(C++11)(C++11)(C++11) | 检查类型是否具有默认构造函数  (类模板)                     |
| [ is_copy_constructibleis_trivially_copy_constructibleis_nothrow_copy_constructible](https://cppreference.cn/w/cpp/types/is_copy_constructible)(C++11)(C++11)(C++11) | 检查类型是否具有复制构造函数  (类模板)                     |
| [ is_move_constructibleis_trivially_move_constructibleis_nothrow_move_constructible](https://cppreference.cn/w/cpp/types/is_move_constructible)(C++11)(C++11)(C++11) | 检查类型是否可以从右值引用构造  (类模板)                   |
| [ is_assignableis_trivially_assignableis_nothrow_assignable](https://cppreference.cn/w/cpp/types/is_assignable)(C++11)(C++11)(C++11) | 检查类型是否具有特定参数的赋值运算符  (类模板)             |
| [ is_copy_assignableis_trivially_copy_assignableis_nothrow_copy_assignable](https://cppreference.cn/w/cpp/types/is_copy_assignable)(C++11)(C++11)(C++11) | 检查类型是否具有复制赋值运算符  (类模板)                   |
| [ is_move_assignableis_trivially_move_assignableis_nothrow_move_assignable](https://cppreference.cn/w/cpp/types/is_move_assignable)(C++11)(C++11)(C++11) | 检查类型是否具有移动赋值运算符  (类模板)                   |
| [ is_destructibleis_trivially_destructibleis_nothrow_destructible](https://cppreference.cn/w/cpp/types/is_destructible)(C++11)(C++11)(C++11) | 检查类型是否具有非删除的析构函数  (类模板)                 |
| [ has_virtual_destructor](https://cppreference.cn/w/cpp/types/has_virtual_destructor)(C++11) | 检查类型是否具有虚析构函数  (类模板)                       |
| [ is_swappable_withis_swappableis_nothrow_swappable_withis_nothrow_swappable](https://cppreference.cn/w/cpp/types/is_swappable)(C++17)(C++17)(C++17)(C++17) | 检查类型的对象是否可以与相同或不同类型的对象交换  (类模板) |
| [ reference_converts_from_temporary](https://cppreference.cn/w/cpp/types/reference_converts_from_temporary)(C++23) | 检查引用是否在复制初始化中绑定到临时对象  (类模板)         |
| [ reference_constructs_from_temporary](https://cppreference.cn/w/cpp/types/reference_constructs_from_temporary)(C++23) | 检查引用是否在直接初始化中绑定到临时对象  (类模板)         |



| 属性查询                                                     |                                        |
| ------------------------------------------------------------ | -------------------------------------- |
| [ alignment_of](https://cppreference.cn/w/cpp/types/alignment_of)(C++11) | 获取类型的对齐要求  (类模板)           |
| [ rank](https://cppreference.cn/w/cpp/types/rank)(C++11)     | 获取数组类型的维度数量  (类模板)       |
| [ extent](https://cppreference.cn/w/cpp/types/extent)(C++11) | 获取数组类型沿指定维度的尺寸  (类模板) |

| 类型关系                                                     |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ is_same](https://cppreference.cn/w/cpp/types/is_same)(C++11) | 检查两个类型是否相同  (类模板)                               |
| [ is_base_of](https://cppreference.cn/w/cpp/types/is_base_of)(C++11) | 检查一个类型是否为另一个类型的基类  (类模板)                 |
| [ is_virtual_base_of](https://cppreference.cn/w/cpp/types/is_virtual_base_of)(C++26) | 检查一个类型是否为另一个类型的虚基类  (类模板)               |
| [ is_convertibleis_nothrow_convertible](https://cppreference.cn/w/cpp/types/is_convertible)(C++11)(C++20) | 检查一个类型是否可以转换为另一个类型  (类模板)               |
| [ is_layout_compatible](https://cppreference.cn/w/cpp/types/is_layout_compatible)(C++20) | 检查两个类型是否[*布局兼容*](https://cppreference.cn/w/cpp/language/data_members#Standard_layout)  (类模板) |
| [ is_pointer_interconvertible_base_of](https://cppreference.cn/w/cpp/types/is_pointer_interconvertible_base_of)(C++20) | 检查一个类型是否为另一类型的*[指针可互转换](https://cppreference.cn/w/cpp/language/static_cast#pointer-interconvertible)*的（初始）基类  (类模板) |
| [ is_invocableis_invocable_ris_nothrow_invocableis_nothrow_invocable_r](https://cppreference.cn/w/cpp/types/is_invocable)(C++17) | 检查是否可以使用给定的参数类型调用某个类型（如同通过 [std::invoke](https://cppreference.cn/w/cpp/utility/functional/invoke) 调用）  (类模板) |
| Const-volatile 限定符                                        |                                                              |
| [ remove_cvremove_constremove_volatile](https://cppreference.cn/w/cpp/types/remove_cv)(C++11)(C++11)(C++11) | 从给定类型移除 const 和/或 volatile 限定符  (类模板)         |
| [ add_cvadd_constadd_volatile](https://cppreference.cn/w/cpp/types/add_cv)(C++11)(C++11)(C++11) | 向给定类型添加 const 和/或 volatile 限定符  (类模板)         |
| 引用                                                         |                                                              |
| [ remove_reference](https://cppreference.cn/w/cpp/types/remove_reference)(C++11) | 从给定类型移除引用  (类模板)                                 |
| [ add_lvalue_referenceadd_rvalue_reference](https://cppreference.cn/w/cpp/types/add_reference)(C++11 起)(C++11 起) | 向给定类型添加*左值*或*右值*引用  (类模板)                   |
| 指针                                                         |                                                              |
| [ remove_pointer](https://cppreference.cn/w/cpp/types/remove_pointer)(C++11) | 从给定类型移除指针  (类模板)                                 |
| [ add_pointer](https://cppreference.cn/w/cpp/types/add_pointer)(C++11) | 向给定类型添加指针  (类模板)                                 |
| 符号修饰符                                                   |                                                              |
| [ make_signed](https://cppreference.cn/w/cpp/types/make_signed)(C++11) | 获取给定整型类型对应的有符号类型  (类模板)                   |
| [ make_unsigned](https://cppreference.cn/w/cpp/types/make_unsigned)(C++11) | 获取给定整型类型对应的有符号类型  (类模板)                   |
| 数组                                                         |                                                              |
| [ remove_extent](https://cppreference.cn/w/cpp/types/remove_extent)(C++11) | 从给定数组类型移除一个维度  (类模板)                         |
| [ remove_all_extents](https://cppreference.cn/w/cpp/types/remove_all_extents)(C++11) | 从给定数组类型移除所有维度  (类模板)                         |
| 其他变换                                                     |                                                              |
| [ aligned_storage](https://cppreference.cn/w/cpp/types/aligned_storage)(C++11 起)(C++23 中已弃用) | 定义适合用作给定大小类型的未初始化存储的类型  (类模板)       |
| [ aligned_union](https://cppreference.cn/w/cpp/types/aligned_union)(C++11 起)(C++23 中已弃用) | 定义适合用作所有给定类型的未初始化存储的类型  (类模板)       |
| [ decay](https://cppreference.cn/w/cpp/types/decay)(C++11)   | 应用类型变换，如同按值传递函数参数时一样  (类模板)           |
| [ remove_cvref](https://cppreference.cn/w/cpp/types/remove_cvref)(C++20) | 组合了 [std::remove_cv](https://cppreference.cn/w/cpp/types/remove_cv) 和 [std::remove_reference](https://cppreference.cn/w/cpp/types/remove_reference)  (类模板) |
| [ enable_if](https://cppreference.cn/w/cpp/types/enable_if)(C++11) | 有条件地从重载决议中[移除](https://cppreference.cn/w/cpp/language/sfinae)函数重载或模板特化  (类模板) |
| [ conditional](https://cppreference.cn/w/cpp/types/conditional)(C++11) | 根据编译时布尔值选择一个类型或另一个类型  (类模板)           |
| [ common_type](https://cppreference.cn/w/cpp/types/common_type)(C++11) | 确定一组类型的公共类型  (类模板)                             |
| [ common_referencebasic_common_reference](https://cppreference.cn/w/cpp/types/common_reference)(C++20) | 确定一组类型的公共引用类型  (类模板)                         |
| [ underlying_type](https://cppreference.cn/w/cpp/types/underlying_type)(C++11) | 获取给定枚举类型的底层整数类型  (类模板)                     |
| [ result_ofinvoke_result](https://cppreference.cn/w/cpp/types/result_of)(C++11 起)(C++20 中移除)(C++17 起) | 推导使用一组参数调用可调用对象的结果类型  (类模板)           |
| [ void_t](https://cppreference.cn/w/cpp/types/void_t)(C++17) | void 可变参数别名模板 (别名模板)                             |
| [ type_identity](https://cppreference.cn/w/cpp/types/type_identity)(C++20) | 返回未更改的类型参数  (类模板)                               |
| [ unwrap_referenceunwrap_ref_decay](https://cppreference.cn/w/cpp/utility/functional/unwrap_reference)(C++20 起)(C++20 起) | 获取包装在 [std::reference_wrapper](https://cppreference.cn/w/cpp/utility/functional/reference_wrapper) 中的引用类型  (类模板) |
| 特性操作                                                     |                                                              |
| [ conjunction](https://cppreference.cn/w/cpp/types/conjunction)(C++17) | 可变参数逻辑 AND 元函数  (类模板)                            |
| [ disjunction](https://cppreference.cn/w/cpp/types/disjunction)(C++17) | 可变参数逻辑 OR 元函数  (类模板)                             |
| [ negation](https://cppreference.cn/w/cpp/types/negation)(C++17) | 逻辑 NOT 元函数  (类模板)                                    |
| 函数                                                         |                                                              |
| 成员关系                                                     |                                                              |
| [ is_pointer_interconvertible_with_class](https://cppreference.cn/w/cpp/types/is_pointer_interconvertible_with_class)(C++20) | 检查一个类型的对象是否与该类型的指定子对象*[指针可互转换](https://cppreference.cn/w/cpp/language/static_cast#pointer-interconvertible)*  (函数模板) |
| [ is_corresponding_member](https://cppreference.cn/w/cpp/types/is_corresponding_member)(C++20) | 检查两个指定类型的公共初始序列中，两个指定的成员是否彼此对应  (函数模板) |
| 常量求值语境                                                 |                                                              |
| [ is_constant_evaluated](https://cppreference.cn/w/cpp/types/is_constant_evaluated)(C++20) | 检测调用是否发生在常量求值语境内  (函数)                     |
| [ is_within_lifetime](https://cppreference.cn/w/cpp/types/is_within_lifetime)(C++26) | 在编译时检查指针是否在对象的生命周期内  (函数)               |

## 使用示例

### 常用功能

```c
#include <print>
#include <iostream>
#include <type_traits>
int gfunc(int x) { return x * 2; }

int main() {
    int max = INT_MAX + 100;
    std::println("overflow: max = {}", max);

    const unsigned v = max;
    std::println("v = {}", v);
    const unsigned& u = std::make_unsigned_t<int>(max);
    std::println("u = {}", u);

    volatile int x = 10;

    auto func = [](int x) -> int { return x * 2; };
    
    {
        // decltype(auto) 类型说明符也像 auto 一样推导类型。然而，它在推导返回类型时会保留引用和 cv 限定符，而 auto 则不会。
        const int x = 0;
        auto x1 = x; // int
        decltype(auto) x2 = x; // const int
        int y = 0;
        int& y1 = y;
        auto y2 = y1; // int
        decltype(auto) y3 = y1; // int&
        int&& z = 0;
        auto z1 = std::move(z); // int
        decltype(auto) z2 = std::move(z); // int&&

        static_assert(std::is_same_v<decltype(x), decltype(x2)>);
    }

    // std::remove_extent_t 只能移除C风格数组的extent，不能移除std::array的extent
    // std::remove_reference_t
    // std::remove_pointer_t
    // std::remove_cv_t
    // std::remove_volatile_t
    // std::remove_const_t
    // std::remove_cvref  // C++20
    // std::decay_t     数组提升为数组指针，函数提升为函数指针
    // 能够区分 有无符号、const/volatile/指针/应用修饰的类型
    static_assert(
        !std::is_same_v<int, unsigned> and 
        !std::is_same_v<const int, int> and 
        !std::is_same_v<volatile int, int> and
        !std::is_same_v<char[], char*> and
        !std::is_same_v<decltype(v), unsigned> and
        !std::is_same_v<decltype(u), const unsigned * const> and
         std::is_same_v<std::add_const_t<unsigned>&, decltype(u)> and
         std::is_same_v<std::remove_reference_t<decltype(u)>, const unsigned> and
         std::is_same_v<std::remove_volatile_t<decltype(x)>, int> and
         std::is_same_v<std::remove_pointer_t<std::decay_t<char[]>>, char> and
         std::is_same_v<std::decay_t<decltype(v)>, unsigned> and 
         std::is_same_v<std::decay_t<char[]>, char*> and 
         std::is_same_v<std::decay_t<decltype(func(10))>, int> and
         std::is_same_v<std::decay_t<decltype(func.operator()(10))>, int> and
         std::is_same_v<decltype(gfunc), int(int)> and
         std::is_same_v<std::decay_t<decltype(gfunc)>, int(*)(int)> and
        !std::is_same_v<decltype(func), decltype([](int x) -> int {})> and
         std::is_same_v<std::remove_extent_t<int[][3]>, int[3]> and
        !std::is_same_v<std::remove_extent_t<std::array<std::array<int, 1>, 3>>, std::array<int, 1>>);
    
     struct Point {
     	int x, y;
     };
     Point points[10];
     auto p = auto{ points };
     static_assert(std::is_same_v<Point*, decltype(p)>); 
     // 等价于 static_assert(std::is_same_v<Point*, decay_t<decltype(p)>>);

    // std::is_pointer_interconvertible_with_class
    {
        //个特征用于检查给定类型的成员是否可以通过 reinterpret_cast 安全地与其包含类进行指针互转换。
        struct Foo { int x; };
        struct Bar { int y; };

        struct Baz : Foo, Bar {}; // not standard-layout

        struct Base {
            int x;
        };

        struct Derived : Base {
            int y;
        };

        static_assert(not std::is_same_v<decltype(&Baz::x), int Baz::*>);
        static_assert(std::is_pointer_interconvertible_with_class(&Baz::x));
        static_assert(not std::is_pointer_interconvertible_with_class<Baz, int>(&Baz::x));
        std::cout.setf(std::ios::boolalpha);

        // 检查 Base::x 是否与 Base 指针互转换
        std::cout << "Base::x is pointer interconvertible with Base: "
            << std::is_pointer_interconvertible_with_class(&Base::x) << '\n';

        // 检查 Derived::y 是否与 Derived 指针互转换
        std::cout << "Derived::y is pointer interconvertible with Derived: "
            << std::is_pointer_interconvertible_with_class(&Derived::y) << '\n';

        // 检查 Base::x 是否与 Derived 指针互转换
        std::cout << "Base::x is pointer interconvertible with Derived: "
            << std::is_pointer_interconvertible_with_class<Derived>(&Base::x) << '\n';
    }

    // std::is_corresponding_member
    {
        // 这个特征用于检查两个成员指针是否指向两个不同类中的对应成员（即它们在类布局中的位置相同）。
        struct A { int a; char b; };

        struct B { int x; char y; };

        struct C { char p; int q; };
        std::cout.setf(std::ios::boolalpha);

        // 检查 A::a 和 B::x 是否是对应成员
        std::cout << "A::a and B::x are corresponding members: "
            << std::is_corresponding_member(&A::a, &B::x) << '\n';

        // 检查 A::b 和 B::y 是否是对应成员
        std::cout << "A::b and B::y are corresponding members: "
            << std::is_corresponding_member(&A::b, &B::y) << '\n';

        // 检查 A::a 和 C::q 是否是对应成员（布局不同）
        std::cout << "A::a and C::q are corresponding members: "
            << std::is_corresponding_member(&A::a, &C::q) << '\n';
    }
    return 0;
}
```

### [std::declval](./通用工具库.md)

用于编写出现在[非求值语境](https://cppreference.cn/w/cpp/language/expressions#Potentially-evaluated_expressions)（通常为 [`decltype`](https://cppreference.cn/w/cpp/language/decltype) 的操作数）中的表达式的辅助模板。在非求值语境中，此辅助模板将任何类型 `T` (可以是未完成类型) 转换为该类型的表达式，从而可以无需通过构造函数即可使用 T 的成员函数。

`std::declval` 只能在[非求值语境](https://cppreference.cn/w/cpp/language/expressions#Potentially-evaluated_expressions)中使用，并且不需要定义；若求值包含此函数的表达式则会出错。正式地，如果此函数被[ODR 使用](https://cppreference.cn/w/cpp/language/definition#ODR-use)，则程序是非良构的。

```c
#include <iostream>
#include <utility>
 
struct Default
{
    int foo() const { return 1; }
};
 
struct NonDefault
{
    NonDefault() = delete;
    int foo() const { return 1; }
};
 
int main()
{
    decltype(Default().foo())               n1 = 1;     // type of n1 is int
    decltype(std::declval<Default>().foo()) n2 = 1;     // same
 
//  decltype(NonDefault().foo())               n3 = n1; // error: no default constructor
    decltype(std::declval<NonDefault>().foo()) n3 = n1; // type of n3 is int
 
    std::cout << "n1 = " << n1 << '\n'
              << "n2 = " << n2 << '\n'
              << "n3 = " << n3 << '\n';
}
```

