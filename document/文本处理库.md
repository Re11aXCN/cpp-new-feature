# 头文件

```c
#include <charconv>
#include <regex>
#include <format>
```



# `<regex>`

##  概述

此头文件是[文本处理](https://cppreference.cn/w/cpp/text)库的一部分。

| 包括                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ ](https://cppreference.cn/w/cpp/header/compare)(C++20)     | [三路比较运算符](https://cppreference.cn/w/cpp/language/operator_comparison#Three-way_comparison) 支持 |
| [ ](https://cppreference.cn/w/cpp/header/initializer_list)(C++11) | [std::initializer_list](https://cppreference.cn/w/cpp/utility/initializer_list) 类模板 |
| 类                                                           |                                                              |
| [ basic_regex](https://cppreference.cn/w/cpp/regex/basic_regex)(C++11) | 正则表达式对象  (类模板)                                     |
| [std::regex](https://cppreference.cn/w/cpp/regex/basic_regex) | [std::basic_regex](https://cppreference.cn/w/cpp/regex/basic_regex)<char> (类型别名) |
| [std::wregex](https://cppreference.cn/w/cpp/regex/basic_regex) | [std::basic_regex](https://cppreference.cn/w/cpp/regex/basic_regex)<wchar_t> (类型别名) |
| [ sub_match](https://cppreference.cn/w/cpp/regex/sub_match)(C++11) | 标识子表达式所匹配的字符序列  (类模板)                       |
| [std::csub_match](https://cppreference.cn/w/cpp/regex/sub_match) | [std::sub_match](https://cppreference.cn/w/cpp/regex/sub_match)<const char*> (类型别名) |
| [std::wcsub_match](https://cppreference.cn/w/cpp/regex/sub_match) | [std::sub_match](https://cppreference.cn/w/cpp/regex/sub_match)<const wchar_t*> (类型别名) |
| [std::ssub_match](https://cppreference.cn/w/cpp/regex/sub_match) | [std::sub_match](https://cppreference.cn/w/cpp/regex/sub_match)<std::string::const_iterator> (类型别名) |
| [std::wssub_match](https://cppreference.cn/w/cpp/regex/sub_match) | [std::sub_match](https://cppreference.cn/w/cpp/regex/sub_match)<std::wstring::const_iterator> (类型别名) |
| [ match_results](https://cppreference.cn/w/cpp/regex/match_results)(C++11) | 标识一个正则表达式匹配，包括所有子表达式匹配  (类模板)       |
| [std::cmatch](https://cppreference.cn/w/cpp/regex/match_results) | [std::match_results](https://cppreference.cn/w/cpp/regex/match_results)<const char*> (类型别名) |
| [std::wcmatch](https://cppreference.cn/w/cpp/regex/match_results) | [std::match_results](https://cppreference.cn/w/cpp/regex/match_results)<const wchar_t*> (类型别名) |
| [std::smatch](https://cppreference.cn/w/cpp/regex/match_results) | [std::match_results](https://cppreference.cn/w/cpp/regex/match_results)<std::string::const_iterator> (类型别名) |
| [std::wsmatch](https://cppreference.cn/w/cpp/regex/match_results) | [std::match_results](https://cppreference.cn/w/cpp/regex/match_results)<std::wstring::const_iterator> (类型别名) |
| [ regex_iterator](https://cppreference.cn/w/cpp/regex/regex_iterator)(C++11) | 迭代字符序列中的所有 regex 匹配项  (类模板)                  |
| [std::cregex_iterator](https://cppreference.cn/w/cpp/regex/regex_iterator) | [std::regex_iterator](https://cppreference.cn/w/cpp/regex/regex_iterator)<const char*> (类型别名) |
| [std::wcregex_iterator](https://cppreference.cn/w/cpp/regex/regex_iterator) | [std::regex_iterator](https://cppreference.cn/w/cpp/regex/regex_iterator)<const wchar_t*> (类型别名) |
| [std::sregex_iterator](https://cppreference.cn/w/cpp/regex/regex_iterator) | [std::regex_iterator](https://cppreference.cn/w/cpp/regex/regex_iterator)<std::string::const_iterator> (类型别名) |
| [std::wsregex_iterator](https://cppreference.cn/w/cpp/regex/regex_iterator) | [std::regex_iterator](https://cppreference.cn/w/cpp/regex/regex_iterator)<std::wstring::const_iterator> (类型别名) |
| [ regex_token_iterator](https://cppreference.cn/w/cpp/regex/regex_token_iterator)(C++11) | 迭代给定字符串中所有 regex 匹配项内的指定子表达式，或迭代不匹配的子字符串  (类模板) |
| [std::cregex_token_iterator](https://cppreference.cn/w/cpp/regex/regex_token_iterator) | [std::regex_token_iterator](https://cppreference.cn/w/cpp/regex/regex_token_iterator)<const char*> (类型别名) |
| [std::wcregex_token_iterator](https://cppreference.cn/w/cpp/regex/regex_token_iterator) | [std::regex_token_iterator](https://cppreference.cn/w/cpp/regex/regex_token_iterator)<const wchar_t*> (类型别名) |
| [std::sregex_token_iterator](https://cppreference.cn/w/cpp/regex/regex_token_iterator) | [std::regex_token_iterator](https://cppreference.cn/w/cpp/regex/regex_token_iterator)<std::string::const_iterator> (类型别名) |
| [std::wsregex_token_iterator](https://cppreference.cn/w/cpp/regex/regex_token_iterator) | [std::regex_token_iterator](https://cppreference.cn/w/cpp/regex/regex_token_iterator)<std::wstring::const_iterator> (类型别名) |
| [ regex_error](https://cppreference.cn/w/cpp/regex/regex_error)(C++11) | 报告正则表达式库生成的错误  (类)                             |
| [ regex_traits](https://cppreference.cn/w/cpp/regex/regex_traits)(C++11) | 提供正则表达式库所需的关于字符类型的元信息  (类模板)         |
| regex 常量类型                                               |                                                              |
| 定义于命名空间 `std::regex_constants`                        |                                                              |
| [ syntax_option_type](https://cppreference.cn/w/cpp/regex/syntax_option_type)(C++11) | 控制 regex 行为的通用选项  (类型别名)                        |
| [ match_flag_type](https://cppreference.cn/w/cpp/regex/match_flag_type)(C++11) | 特定于匹配的选项  (类型别名)                                 |
| [ error_type](https://cppreference.cn/w/cpp/regex/error_type)(C++11) | 描述不同类型的匹配错误  (类型别名)                           |
| 函数                                                         |                                                              |
| 算法                                                         |                                                              |
| [ regex_match](https://cppreference.cn/w/cpp/regex/regex_match)(C++11) | 尝试将正则表达式匹配到整个字符序列  (函数模板)               |
| [ regex_search](https://cppreference.cn/w/cpp/regex/regex_search)(C++11) | 尝试将正则表达式匹配到字符序列的任何部分  (函数模板)         |
| [ regex_replace](https://cppreference.cn/w/cpp/regex/regex_replace)(C++11) | 使用格式化的替换文本替换正则表达式的出现  (函数模板)         |
| 非成员操作                                                   |                                                              |
| [ std::swap(std::basic_regex)](https://cppreference.cn/w/cpp/regex/basic_regex/swap2)(C++11) | 特化 [std::swap](https://cppreference.cn/w/cpp/algorithm/swap) 算法  (函数模板) |
| [ operator==operator!=operatoroperator>=operator<=>](https://cppreference.cn/w/cpp/regex/sub_match/operator_cmp)(C++20 中移除)(C++20 中移除)(C++20 中移除)(C++20 中移除)(C++20 中移除)(C++20) | 将 `sub_match` 与另一个 `sub_match`、字符串或字符进行比较  (函数模板) |
| [ operator<<](https://cppreference.cn/w/cpp/regex/sub_match/operator_ltlt) | 输出匹配的字符子序列  (函数模板)                             |
| [ operator==operator!=](https://cppreference.cn/w/cpp/regex/match_results/operator_cmp)(C++20 中移除) | 按字典顺序比较两个匹配结果中的值  (函数模板)                 |
| [ std::swap(std::match_results)](https://cppreference.cn/w/cpp/regex/match_results/swap2)(C++11) | 特化 [`std::swap`](https://cppreference.cn/w/cpp/algorithm/swap) 算法  (函数模板) |
| 范围访问                                                     |                                                              |
| [ begincbegin](https://cppreference.cn/w/cpp/iterator/begin)(C++11)(C++14) | 返回指向容器或数组开头的迭代器  (函数模板)                   |
| [ endcend](https://cppreference.cn/w/cpp/iterator/end)(C++11)(C++14) | 返回指向容器或数组末尾的迭代器  (函数模板)                   |
| [ rbegincrbegin](https://cppreference.cn/w/cpp/iterator/rbegin)(C++14) | 返回指向容器或数组开头的反向迭代器  (函数模板)               |
| [ rendcrend](https://cppreference.cn/w/cpp/iterator/rend)(C++14) | 返回容器或数组的反向末尾迭代器  (函数模板)                   |
| [ sizessize](https://cppreference.cn/w/cpp/iterator/size)(C++17)(C++20) | 返回容器或数组的大小  (函数模板)                             |
| [ empty](https://cppreference.cn/w/cpp/iterator/empty)(C++17) | 检查容器是否为空  (函数模板)                                 |
| [ data](https://cppreference.cn/w/cpp/iterator/data)(C++17)  | 获取指向底层数组的指针  (函数模板)                           |

### 语法选项（Syntax Options）：

- **ECMAScript (0x01)**：使用 ECMAScript 正则表达式语法（默认）。
- **basic (0x02)**：使用基本 POSIX 正则表达式语法。
- **extended (0x04)**：使用扩展 POSIX 正则表达式语法。
- **awk (0x08)**：使用 AWK 正则表达式语法。
- **grep (0x10)**：使用 grep 正则表达式语法。
- **egrep (0x20)**：使用 egrep 正则表达式语法。
- **_Gmask (0x3F)**：语法标志的掩码，用于内部处理。

### 其他选项（Other Options）：

- **icase (0x0100)**：匹配时忽略大小写。
- **nosubs (0x0200)**：不存储子匹配（捕获组），可以提高性能。
- **optimize (0x0400)**：优化匹配速度，可能会增加编译时间。
- **collate (0x0800)**：使用区域设置敏感的字符范围（如 `[a-z]`）。

## 使用示例

下面是一个展示 C++11 `<regex>` 库核心功能的全面示例：

### 1. 示例

```cpp
#include <iostream>
#include <string>
#include <regex>
#include <vector>
#include <iterator>

int main() {
        std::string text = R"(
        John Doe, age: 30, email: john.doe@example.com, phone: +1-555-123-4567
        Jane Smith, age: 25, email: jane.smith@test.org, phone: +44-20-7946-0958
        Bob Johnson, age: 40, email: bob@company.net, phone: +81-3-1234-5678
        Invalid email: not.an.email, phone: 123-456-7890
        Another email: alice@domain.co.uk
    )";

    std::cout << "原始文本:\n" << text << "\n\n";

    // 1. 基本匹配 - regex_match (匹配整个字符串)
    std::cout << "1. regex_match 示例:\n";
    std::string simple_text = "Hello, World!";
    std::regex pattern1(R"(Hello, World!)");
    if (std::regex_match(simple_text, pattern1)) {
        std::cout << "字符串完全匹配: " << simple_text << "\n";
    }
    else {
        std::cout << "字符串不匹配\n";
    }
    std::cout << "\n";

    // 2. 搜索匹配 - regex_search (在字符串中搜索匹配)
    std::cout << "2. regex_search 示例:\n";
    std::regex pattern2(R"(age: (\d+))");
    std::smatch matches;
    if (std::regex_search(text, matches, pattern2)) {
        std::cout << "找到年龄: " << matches[0] << "\n";
        std::cout << "捕获组1: " << matches[1] << "\n";
    }
    std::cout << "\n";

    // 3. 电子邮件匹配 - 复杂正则表达式
    std::cout << "3. 电子邮件匹配:\n";
    // 复杂的电子邮件正则表达式
    std::regex email_pattern(R"(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b)");
    auto email_begin = std::sregex_iterator(text.begin(), text.end(), email_pattern);
    auto email_end = std::sregex_iterator();

    std::cout << "找到的电子邮件地址:\n";
    for (std::sregex_iterator i = email_begin; i != email_end; ++i) {
        std::smatch match = *i;
        std::cout << "  " << match.str() << "\n";
    }
    std::cout << "\n";

    // 4. 电话号码匹配 - 使用捕获组
    std::cout << "4. 电话号码匹配:\n";
    std::regex phone_pattern(R"(\+(\d{1,3})-(\d{1,4})-(\d{3,4})-(\d{4}))");
    auto phone_begin = std::sregex_iterator(text.begin(), text.end(), phone_pattern);
    auto phone_end = std::sregex_iterator();

    std::cout << "找到的电话号码:\n";
    for (std::sregex_iterator i = phone_begin; i != phone_end; ++i) {
        std::smatch match = *i;
        std::cout << "  完整匹配: " << match[0] << "\n";
        std::cout << "  国家代码: " << match[1] << "\n";
        std::cout << "  地区代码: " << match[2] << "\n";
        std::cout << "  交换代码: " << match[3] << "\n";
        std::cout << "  用户号码: " << match[4] << "\n\n";
    }

    // 5. 使用 regex_replace 进行替换
    std::cout << "5. regex_replace 示例:\n";
    std::regex email_replace_pattern(R"(\b([A-Za-z0-9._%+-]+)@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b)");
    std::string replaced_text = std::regex_replace(text, email_replace_pattern, "[邮箱已隐藏]");
    std::cout << "替换电子邮件后的文本:\n" << replaced_text << "\n\n";

    // 6. 使用 regex_token_iterator 提取特定部分
    std::cout << "6. regex_token_iterator 示例:\n";
    std::regex token_pattern(R"((\w+)\s+(\w+),\s*age:\s*(\d+))");
    std::sregex_token_iterator token_iterator(text.begin(), text.end(), token_pattern, { 1, 2, 3 });
    std::sregex_token_iterator token_end;

    std::cout << "提取的人员信息:\n";
    while (token_iterator != token_end) {
        std::string first_name = *token_iterator++;
        std::string last_name = *token_iterator++;
        std::string age = *token_iterator++;
        std::cout << "  姓名: " << first_name << " " << last_name << ", 年龄: " << age << "\n";
    }
    std::cout << "\n";

    // 7. 使用不同匹配标志
    std::cout << "7. 使用不同匹配标志:\n";
    std::string multiline_text = "Line 1\nLine 2\nLine 3";
    std::regex line_pattern(R"(^Line \d+)");

    // 默认不匹配多行
    auto normal_begin = std::sregex_iterator(multiline_text.begin(), multiline_text.end(), line_pattern);
    auto normal_end = std::sregex_iterator();
    std::cout << "默认匹配找到 " << std::distance(normal_begin, normal_end) << " 个匹配\n";

    // 使用 multiline 标志
    std::regex multiline_pattern(R"(^Line \d+)", std::regex_constants::ECMAScript);
    auto ml_begin = std::sregex_iterator(multiline_text.begin(), multiline_text.end(), multiline_pattern);
    auto ml_end = std::sregex_iterator();
    std::cout << "多行匹配找到 " << std::distance(ml_begin, ml_end) << " 个匹配\n\n";

    // 8. 错误处理
    std::cout << "8. 错误处理示例:\n";
    try {
        // 尝试编译无效的正则表达式
        std::regex invalid_pattern(R"((unclosed group)");
    }
    catch (const std::regex_error& e) {
        std::cout << "正则表达式错误: " << e.what() << "\n";
        std::cout << "错误代码: " << e.code() << "\n";
    }
    std::cout << "\n";

    // 9. 高级特性 - 正向预查和反向引用
    std::cout << "9. 高级正则表达式特性:\n";
    std::string html_text = R"(<img src="image1.jpg"> <img src="image2.png" alt="test">)";

    // 使用正向预查匹配图片标签
    // 使用#()#解决默认结束标记冲突
    std::regex img_pattern(R"#(<img\s+[^>]*src="([^"]+)"[^>]*>)#");
    auto img_begin = std::sregex_iterator(html_text.begin(), html_text.end(), img_pattern);
    auto img_end = std::sregex_iterator();

    std::cout << "找到的图片源:\n";
    for (std::sregex_iterator i = img_begin; i != img_end; ++i) {
        std::smatch match = *i;
        std::cout << "  完整标签: " << match[0] << "\n";
        std::cout << "  图片源: " << match[1] << "\n\n";
    }

    // 10. 使用反向引用替换
    std::cout << "10. 使用反向引用替换:\n";
    std::string date_text = "2023-10-15";
    std::regex date_pattern(R"((\d{4})-(\d{2})-(\d{2}))");
    std::string reformatted_date = std::regex_replace(date_text, date_pattern, "$3/$2/$1");
    std::cout << "原始日期: " << date_text << "\n";
    std::cout << "重新格式化: " << reformatted_date << "\n\n";
    
    return 0;
}
```

### 2. 示例说明

### （1）捕获组

以示例的第二点为例说明   **捕获组 (Capturing Groups)**   概念

为什么`matches`能够产生两个结果，正则表达式是： `R"(age: (\d+))"`

它分解为两部分：

1. `age: `： 字面匹配，匹配字符 "age: "。
2. `(\d+)`： **这是一个捕获组**。括号 `()` 将其内部的内容标记为一个“组”，这个组匹配一个或多个数字(`\d+`)。

当 `regex_search` 找到一个匹配时，它会将结果填充到一个 `std::smatch` 对象中。您可以把这个 `matches` 对象想象成一个数组：

- **`matches[0]`**： 始终存放**整个正则表达式匹配到的完整字符串**。
  - 在您的例子中，整个匹配是 `"age: 30"`，所以 `matches[0]` 就是 `"age: 30"`。
- **`matches[1]`**： 存放**第一个捕获组**匹配到的内容。
  - 在您的例子中，第一个（也是唯一一个）捕获组 `(\d+)` 匹配到的是 `"30"`，所以 `matches[1]` 就是 `"30"`。
- `matches[2]`： 如果有第二个捕获组，比如 `(age: (\d+))`，那么 `matches[2]` 就会是第二个组的内容，依此类推。

**简单来说：**

- `matches[0]`： **我找到了什么**（整个匹配）。
- `matches[1]`, `matches[2]`...： **我从找到的东西里特别提取出了什么**（各个捕获组的内容）。捕获组的目的就是为了从匹配的文本中精确地提取出你关心的部分（比如这里的数字年龄，而不是前面的 "age: " 标签）。

### （2）sregex_token_iterator 

第六点示例

 `std::sregex_token_iterator token_iterator(text.begin(), text.end(), token_pattern, { 1, 2, 3 });`

说明`{1, 2, 3}` 参数含义，即它指定了你**感兴趣的捕获组索引**

这表示：

- 你不想要完整的匹配（索引0）
- 你只想要第1、第2和第3个捕获组的内容

当你遍历这个迭代器时，它会依次返回这些捕获组的值，按照你指定的顺序（1, 2, 3）。

## [正则表达式语法说明](https://www.runoob.com/regexp/regexp-syntax.html)

### 1. 基本匹配
- `regex_match`: 尝试将整个字符串与正则表达式匹配
- `regex_search`: 在字符串中搜索匹配的子串

### 2. 字符类
- `\d`: 数字字符 (等价于 `[0-9]`)
- `\w`: 单词字符 (字母、数字、下划线)
- `\s`: 空白字符
- `.`: 任意字符 (除换行符外)
- `[abc]`: 字符集合中的任意一个字符
- `[^abc]`: 不在字符集合中的任意字符

### 3. 量词
- `*`: 零次或多次
- `+`: 一次或多次
- `?`: 零次或一次
- `{n}`: 恰好 n 次
- `{n,}`: 至少 n 次
- `{n,m}`: n 到 m 次

### 4. 锚点
- `^`: 字符串开始 (或多行模式下的行开始)
- `$`: 字符串结束 (或多行模式下的行结束)
- `\b`: 单词边界

### 5. 分组和捕获
- `(pattern)`: 捕获组
- `(?:pattern)`: 非捕获组
- `(?=pattern)`: 正向预查
- `(?!pattern)`: 负向预查

### 6. 反向引用
- `\1`, `\2`, ...: 引用之前的捕获组
- `$1`, `$2`, ...: 在替换字符串中引用捕获组

### 7. 转义字符
- `\\`: 反斜杠
- `\.`: 点号
- `\*`: 星号
- `\+`: 加号
- `\?`: 问号
- `\(`, `\)`: 括号

### 8. 标志和选项
- `std::regex_constants::icase`: 不区分大小写匹配
- `std::regex_constants::multiline`: 多行模式 (使 `^` 和 `$` 匹配行首行尾)
- `std::regex_constants::ECMAScript`: 使用 ECMAScript 语法 (默认)
- `std::regex_constants::basic`: 使用基本 POSIX 语法
- `std::regex_constants::extended`: 使用扩展 POSIX 语法

### 9. 迭代器
- `std::sregex_iterator`: 遍历所有匹配项
- `std::sregex_token_iterator`: 遍历所有匹配的子表达式或不匹配的部分

### 10. 错误处理
- `std::regex_error`: 正则表达式编译或执行错误时抛出的异常

这个示例展示了 C++11 `<regex>` 库的核心功能，包括基本匹配、搜索、替换、迭代器使用、错误处理以及各种正则表达式语法特性。正则表达式是一个强大的工具，可以用于文本处理、数据验证、字符串提取等各种场景。

# `<charconv>`

## 1. 概述

此头文件是[文本处理](https://cppreference.cn/w/cpp/text)库的一部分。

`std::to_chars` 和 `std::from_chars` 是 C++17 引入的高效数值转换函数，位于 `<charconv>` 头文件中。它们提供区域设置无关、不分配内存、无异常抛出的高性能转换，特别适合需要严格控制性能的场合。

## 2. `std::to_chars`

（1）功能

将数值转换为字符序列，写入指定缓冲区。

（2）原型

```cpp
// 整数类型
std::to_chars_result to_chars(char* first, char* last, integer_type value, int base = 10);

// 浮点类型
std::to_chars_result to_chars(char* first, char* last, float_type value);
std::to_chars_result to_chars(char* first, char* last, float_type value, std::chars_format fmt);
std::to_chars_result to_chars(char* first, char* last, float_type value, std::chars_format fmt, int precision);
```

（3）返回值

`std::to_chars_result` 结构体：
```cpp
struct to_chars_result {
    char* ptr;
    std::errc ec;
};
```
- `ptr`: 指向写入字符的尾后位置
- `ec`: 错误码，成功时为 `std::errc()`

（4）示例代码

```cpp
#include <charconv>
#include <iostream>
#include <system_error>
#include <array>
#include <cmath>

void demonstrate_to_chars() {
    std::array<char, 100> buffer;
    
    // 1. 整数转换
    int value = 42;
    auto result = std::to_chars(buffer.data(), buffer.data() + buffer.size(), value);
    if (result.ec == std::errc()) {
        std::string str(buffer.data(), result.ptr);
        std::cout << "整数转换: " << str << std::endl;
    }
    
    // 2. 不同进制的整数转换
    result = std::to_chars(buffer.data(), buffer.data() + buffer.size(), 255, 16);
    if (result.ec == std::errc()) {
        std::string str(buffer.data(), result.ptr);
        std::cout << "十六进制: " << str << std::endl;
    }
    
    // 3. 浮点数默认转换
    double pi = 3.141592653589793;
    result = std::to_chars(buffer.data(), buffer.data() + buffer.size(), pi);
    if (result.ec == std::errc()) {
        std::string str(buffer.data(), result.ptr);
        std::cout << "浮点默认: " << str << std::endl;
    }
    
    // 4. 指定格式的浮点数转换
    result = std::to_chars(buffer.data(), buffer.data() + buffer.size(), pi, std::chars_format::fixed);
    if (result.ec == std::errc()) {
        std::string str(buffer.data(), result.ptr);
        std::cout << "固定格式: " << str << std::endl;
    }
    
    // 5. 指定格式和精度的浮点数转换
    result = std::to_chars(buffer.data(), buffer.data() + buffer.size(), pi, std::chars_format::scientific, 3);
    if (result.ec == std::errc()) {
        std::string str(buffer.data(), result.ptr);
        std::cout << "科学计数法(精度3): " << str << std::endl;
    }
    
    // 6. 十六进制浮点数格式
    result = std::to_chars(buffer.data(), buffer.data() + buffer.size(), pi, std::chars_format::hex);
    if (result.ec == std::errc()) {
        std::string str(buffer.data(), result.ptr);
        std::cout << "十六进制浮点: " << str << std::endl;
    }
    
    // 7. 测试错误情况 - 缓冲区太小
    std::array<char, 1> small_buf;
    result = std::to_chars(small_buf.data(), small_buf.data() + small_buf.size(), 12345);
    if (result.ec == std::errc::value_too_large) {
        std::cout << "错误: 缓冲区太小" << std::endl;
    }
}
```

## 3. `std::from_chars`

（1）功能

从字符序列解析数值。

（2）原型

```cpp
// 整数类型
std::from_chars_result from_chars(const char* first, const char* last, integer_type& value, int base = 10);

// 浮点类型
std::from_chars_result from_chars(const char* first, const char* last, float_type& value, std::chars_format fmt = std::chars_format::general);
```

（3）返回值

`std::from_chars_result` 结构体：
```cpp
struct from_chars_result {
    const char* ptr;
    std::errc ec;
};
```
- `ptr`: 指向第一个未解析字符的位置
- `ec`: 错误码，成功时为 `std::errc()`

（4）示例代码

```cpp
#include <charconv>
#include <iostream>
#include <string>
#include <system_error>

void demonstrate_from_chars() {
    // 1. 整数解析
    std::string int_str = "12345";
    int int_value;
    auto result = std::from_chars(int_str.data(), int_str.data() + int_str.size(), int_value);
    if (result.ec == std::errc()) {
        std::cout << "解析的整数: " << int_value << std::endl;
    }
    
    // 2. 不同进制的整数解析
    std::string hex_str = "ff";
    int hex_value;
    result = std::from_chars(hex_str.data(), hex_str.data() + hex_str.size(), hex_value, 16);
    if (result.ec == std::errc()) {
        std::cout << "解析的十六进制数: " << hex_value << std::endl;
    }
    
    // 3. 浮点数解析
    std::string float_str = "3.14159";
    double double_value;
    result = std::from_chars(float_str.data(), float_str.data() + float_str.size(), double_value);
    if (result.ec == std::errc()) {
        std::cout << "解析的浮点数: " << double_value << std::endl;
    }
    
    // 4. 指定格式的浮点数解析
    std::string sci_str = "1.23e-2";
    double sci_value;
    result = std::from_chars(sci_str.data(), sci_str.data() + sci_str.size(), sci_value, std::chars_format::scientific);
    if (result.ec == std::errc()) {
        std::cout << "解析的科学计数法: " << sci_value << std::endl;
    }
    
    // 5. 部分解析
    std::string partial_str = "42abc";
    int partial_value;
    result = std::from_chars(partial_str.data(), partial_str.data() + partial_str.size(), partial_value);
    if (result.ec == std::errc()) {
        std::cout << "解析的值: " << partial_value << ", 剩余字符串: " << result.ptr << std::endl;
    }
    
    // 6. 错误处理 - 无效输入
    std::string invalid_str = "abc";
    int invalid_value = 0;
    result = std::from_chars(invalid_str.data(), invalid_str.data() + invalid_str.size(), invalid_value);
    if (result.ec == std::errc::invalid_argument) {
        std::cout << "无效参数错误" << std::endl;
    }
    
    // 7. 错误处理 - 超出范围
    std::string overflow_str = "9999999999999999999";
    int overflow_value;
    result = std::from_chars(overflow_str.data(), overflow_str.data() + overflow_str.size(), overflow_value);
    if (result.ec == std::errc::result_out_of_range) {
        std::cout << "超出范围错误" << std::endl;
    }
}
```

（5）说明

要将	**含有数字字符串**	转换为	**数字**	，需要满足条件如下：

1. 字符串必须以数字开头，	如`"123abc"	ok`、`"a123"	error: invalid_argument`

2. 只能匹配首个出现的数字，一旦截断之后的，后面的数字不能够解析，	如`"123abc123"	 只能获取到第一个123，解析指针得到 "abc123"剩余为解析字符串`

3. 解析的数字字符串范围不能超过，赋值可运算的类型（int、double等），如`"9999999999999999999"	error:result_out_of_range`
4. 可以解析科学计数法的数字，如`"1.23e-2"  实际上为0.0123`，但需要指定参数`std::chars_format::scientific`

## 4. 完整示例

```cpp
#include <charconv>
#include <iostream>
#include <array>
#include <string>
#include <system_error>

int main() {
    std::cout << "=== std::to_chars 示例 ===" << std::endl;
    demonstrate_to_chars();
    
    std::cout << "\n=== std::from_chars 示例 ===" << std::endl;
    demonstrate_from_chars();
    
    return 0;
}
```

## 5. 注意事项

1. **无区域设置依赖**: 这些函数不受当前区域设置影响，始终使用C语言环境规则
2. **无内存分配**: 所有操作都在预先分配的缓冲区上进行
3. **无异常**: 使用错误码而非异常报告错误
4. **无空终止符**: 结果字符串不以空字符终止，需要手动处理
5. **高性能**: 相比传统方法（如stringstream）有显著性能优势

## 6. `std::to_chars`/`std::from_chars` 与传统转换函数的区别

> 详细 c定义	字符串转换	见	[](./cdefine.md)	的第十五章	[cstdlib](https://www.runoob.com/cprogramming/c-standard-library-stdlib-h.html)

`std::to_chars` 和 `std::from_chars` 是 C++17 引入的新转换函数，与传统的 `std::strtod`、`std::strtoull` 和 `std::to_string` 有几个关键区别：

### （1）主要区别对比

| 特性           | 传统函数 (`strtod`, `strtoull`, `to_string`) | C++17 函数 (`to_chars`, `from_chars`) |
| -------------- | -------------------------------------------- | ------------------------------------- |
| **区域设置**   | 受当前区域设置影响                           | 完全区域设置无关（总是使用C区域设置） |
| **内存分配**   | `to_string` 会分配内存                       | 从不分配内存（使用现有缓冲区）        |
| **错误处理**   | 使用errno或异常                              | 使用结构体返回错误码，不修改全局errno |
| **性能**       | 相对较慢（可能涉及区域设置和内存分配）       | 高性能（无区域设置开销，无内存分配）  |
| **格式控制**   | 有限制                                       | 更精细的控制（进制、浮点格式等）      |
| **异常安全**   | 可能抛出异常(`to_string`)                    | 从不抛出异常                          |
| **缓冲区安全** | 需要额外处理缓冲区大小                       | 自动检测缓冲区边界                    |

### （2）详细示例对比

```cpp
#include <charconv>
#include <iostream>
#include <string>
#include <cstdlib>
#include <cerrno>
#include <climits>
#include <system_error>

void compare_conversion_methods() {
    // 示例字符串和数值
    const char* num_str = "123.45";
    double value = 123.45;
    std::array<char, 100> buffer;
    
    std::cout << "=== 字符串转数值 ===" << std::endl;
    
    // 1. 传统方法: std::strtod
    char* endptr;
    errno = 0; // 清除错误状态
    double result1 = std::strtod(num_str, &endptr);
    if (errno == ERANGE) {
        std::cout << "strtod: 超出范围错误" << std::endl;
    } else if (endptr == num_str) {
        std::cout << "strtod: 无效输入" << std::endl;
    } else {
        std::cout << "strtod 结果: " << result1 << std::endl;
    }
    
    // 2. 新方法: std::from_chars
    double result2;
    auto fc_result = std::from_chars(num_str, num_str + std::strlen(num_str), result2);
    if (fc_result.ec == std::errc::invalid_argument) {
        std::cout << "from_chars: 无效参数" << std::endl;
    } else if (fc_result.ec == std::errc::result_out_of_range) {
        std::cout << "from_chars: 超出范围" << std::endl;
    } else {
        std::cout << "from_chars 结果: " << result2 << std::endl;
        std::cout << "解析了 " << (fc_result.ptr - num_str) << " 个字符" << std::endl;
    }
    
    std::cout << "\n=== 数值转字符串 ===" << std::endl;
    
    // 3. 传统方法: std::to_string
    std::string str_result = std::to_string(value);
    std::cout << "to_string 结果: " << str_result << " (长度: " << str_result.size() << ")" << std::endl;
    
    // 4. 新方法: std::to_chars
    auto tc_result = std::to_chars(buffer.data(), buffer.data() + buffer.size(), value);
    if (tc_result.ec == std::errc()) {
        std::string chars_result(buffer.data(), tc_result.ptr);
        std::cout << "to_chars 结果: " << chars_result << " (长度: " << chars_result.size() << ")" << std::endl;
    } else {
        std::cout << "to_chars 错误: 缓冲区太小" << std::endl;
    }
    
    std::cout << "\n=== 区域设置影响示例 ===" << std::endl;
    
    // 演示区域设置的影响
    const char* european_num = "123,45"; // 欧洲格式使用逗号作为小数点
    
    // 传统方法受区域设置影响
    setlocale(LC_NUMERIC, "de_DE.UTF-8"); // 设置为德语区域
    double result3 = std::strtod(european_num, &endptr);
    std::cout << "德语区域设置下 strtod 结果: " << result3 << std::endl;
    
    // 新方法不受区域设置影响
    setlocale(LC_NUMERIC, "C"); // 恢复C区域设置
    double result4;
    fc_result = std::from_chars(european_num, european_num + std::strlen(european_num), result4);
    if (fc_result.ec == std::errc()) {
        std::cout << "from_chars 结果 (不受区域设置影响): " << result4 << std::endl;
    } else {
        std::cout << "from_chars 无法解析欧洲格式数字" << std::endl;
    }
}

void performance_comparison() {
    std::cout << "\n=== 性能考虑 ===" << std::endl;
    std::cout << "1. to_chars/from_chars 不分配内存，适合高性能应用" << std::endl;
    std::cout << "2. to_chars/from_chars 不受区域设置影响，执行更快" << std::endl;
    std::cout << "3. to_chars/from_chars 提供更精确的错误处理" << std::endl;
    std::cout << "4. to_string 简单易用但可能分配不必要的内存" << std::endl;
}

int main() {
    compare_conversion_methods();
    performance_comparison();
    return 0;
}
```

### （3）何时使用哪种方法

#### a. 使用传统方法的情况：
1. **需要区域设置感知**的转换（如处理本地化数字格式）
2. **简单快速**的转换，不需要极致性能
3. **与现有代码**保持一致性
4. **C++11/14** 兼容代码

#### b.使用 C++17 方法的情况：
1. **高性能应用**，需要避免内存分配
2. **区域设置无关**的转换（如网络协议、文件格式）
3. **需要精细控制**转换格式（如指定进制、浮点格式）
4. **更好的错误处理**，不需要检查全局 errno
5. **异常安全**代码（这些函数从不抛出异常）

# `<format>`

## 1. 概述

此头文件是[文本处理](https://cppreference.cn/w/cpp/text)库的一部分。

| 概念                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ formattable](https://cppreference.cn/w/cpp/utility/format/formattable)(C++23) | 指定一个类型是可格式化的，即它特化了 [std::formatter](https://cppreference.cn/w/cpp/utility/format/formatter) 并提供了成员函数 `parse` 和 `format`  (概念) |
| 枚举                                                         |                                                              |
| [ range_format](https://cppreference.cn/w/cpp/utility/format/range_format)(C++23) | 指定范围应如何格式化  (枚举)                                 |
| 类                                                           |                                                              |
| [ formatter](https://cppreference.cn/w/cpp/utility/format/formatter)(C++20) | 定义给定类型的格式化规则  (类模板)                           |
| [ range_formatter](https://cppreference.cn/w/cpp/utility/format/range_formatter)(C++23) | 有助于实现范围类型的 [std::formatter](https://cppreference.cn/w/cpp/utility/format/formatter) 特化的类模板  (类模板) |
| [ basic_format_parse_contextformat_parse_contextwformat_parse_context](https://cppreference.cn/w/cpp/utility/format/basic_format_parse_context)(C++20)(C++20)(C++20) | 格式化字符串解析器状态  (类模板)                             |
| [ basic_format_contextformat_contextwformat_context](https://cppreference.cn/w/cpp/utility/format/basic_format_context)(C++20)(C++20)(C++20) | 格式化状态，包括所有格式化参数和输出迭代器  (类模板)         |
| [ basic_format_arg](https://cppreference.cn/w/cpp/utility/format/basic_format_arg)(C++20) | 为用户定义格式化器提供格式化参数访问的类模板  (类模板)       |
| [ basic_format_argsformat_argswformat_args](https://cppreference.cn/w/cpp/utility/format/basic_format_args)(C++20)(C++20)(C++20) | 提供对所有格式化参数访问的类  (类模板)                       |
| [ basic_format_stringformat_stringwformat_string](https://cppreference.cn/w/cpp/utility/format/basic_format_string)(C++20)(C++20)(C++20) | 在构造时执行编译时格式字符串检查的类模板  (类模板)           |
| [ format_error](https://cppreference.cn/w/cpp/utility/format/format_error)(C++20) | 格式化错误时抛出的异常类型  (类)                             |
| 格式化器特化                                                 |                                                              |
| [ std::formatter<*pair-or-tuple*>](https://cppreference.cn/w/cpp/utility/format/tuple_formatter)(C++23) | 对 `pair` 和 `tuple` 的格式化支持  (类模板特化)              |
| [ std::formatter<*range*>](https://cppreference.cn/w/cpp/utility/format/ranges_formatter)(C++23) | 对范围的格式化支持  (类模板特化)                             |
| 函数                                                         |                                                              |
| [ format](https://cppreference.cn/w/cpp/utility/format/format)(C++20) | 将参数的格式化表示存储在新字符串中  (函数模板)               |
| [ format_to](https://cppreference.cn/w/cpp/utility/format/format_to)(C++20) | 通过输出迭代器写出其参数的格式化表示  (函数模板)             |
| [ format_to_n](https://cppreference.cn/w/cpp/utility/format/format_to_n)(C++20) | 通过输出迭代器写出其参数的格式化表示，不超过指定大小  (函数模板) |
| [ formatted_size](https://cppreference.cn/w/cpp/utility/format/formatted_size)(C++20) | 确定存储其参数格式化表示所需的字符数  (函数模板)             |
| [ runtime_format](https://cppreference.cn/w/cpp/utility/format/runtime_format)(C++26) | 创建可直接用于面向用户的格式化函数的运行时格式字符串  (函数) |
| [ vformat](https://cppreference.cn/w/cpp/utility/format/vformat)(C++20) | 使用类型擦除参数表示的 [std::format](https://cppreference.cn/w/cpp/utility/format/format) 的非模板变体  (函数) |
| [ vformat_to](https://cppreference.cn/w/cpp/utility/format/vformat_to)(C++20) | 使用类型擦除参数表示的 [std::format_to](https://cppreference.cn/w/cpp/utility/format/format_to) 的非模板变体  (函数模板) |
| [ visit_format_arg](https://cppreference.cn/w/cpp/utility/format/visit_format_arg)(C++20) (在 C++26 中废弃) | 用户定义格式化器的参数访问接口  (函数模板)                   |
| [ make_format_argsmake_wformat_args](https://cppreference.cn/w/cpp/utility/format/make_format_args)(C++20)(C++20) | 创建引用所有格式化参数的类型擦除对象，可转换为 `format_args`  (函数模板) |
| 辅助函数                                                     |                                                              |
| [ format_kind](https://cppreference.cn/w/cpp/utility/format/format_kind)(C++23) | 为范围选择合适的 std::range_format (变量模板)                |
| [ enable_nonlocking_formatter_optimization](https://cppreference.cn/w/cpp/utility/format/enable_nonlocking_formatter_optimization)(C++23) | 指示参数类型可以高效打印 (变量模板)                          |

C++20 的 `<format>` 库提供了现代、类型安全的文本格式化功能。以下是详细说明和示例：

## 2.核心组件详解

### 1. **类模板 `std::formatter`**
```cpp
template<class T, class CharT = char>
struct formatter;
```
- **作用**：为类型 `T` 定义格式化规则。
- **需实现的方法**：
  - `parse(format_parse_context& ctx)`：解析格式说明符（如 `{:5.3f}` 中的 `5.3f`）。
  - `format(const T& obj, format_context& ctx)`：将 `obj` 格式化为字符串。

**示例：特化 `formatter` 用于自定义类型**

```cpp
#include <format>
#include <iostream>

struct Point {
    double x, y;
};

template<>
struct std::formatter<Point> {
    constexpr auto parse(auto& ctx) {
        return ctx.begin(); // 无自定义格式说明符
    }
    auto format(const Point& p, auto& ctx) const {
        return std::format_to(ctx.out(), "({:.1f}, {:.1f})", p.x, p.y);
    }
};

int main() {
    Point p{1.0, 2.5};
    std::cout << std::format("Point: {}", p); // 输出: Point: (1.0, 2.5)
}
```

### 2. **格式化函数**
```cpp
// 返回格式化后的字符串
template<class... Args>
std::string format(std::format_string<Args...> fmt, Args&&... args);

// 写入到输出迭代器
template<class Out, class... Args>
Out format_to(Out out, std::format_string<Args...> fmt, Args&&... args);

// 写入最多 n 个字符（包括终止符）
template<class Out, class... Args>
std::format_to_n_result<Out> format_to_n(Out out, std::iter_difference_t<Out> n, 
                                         std::format_string<Args...> fmt, Args&&... args);

// 计算所需字符数
template<class... Args>
std::size_t formatted_size(std::format_string<Args...> fmt, Args&&... args);
```

**示例：基本函数使用**

```cpp
#include <format>
#include <vector>
#include <iterator>

int main() {
    // std::format
    std::string s = std::format("Hello, {}!", "World"); // s = "Hello, World!"

    // std::format_to
    std::vector<char> buf;
    std::format_to(std::back_inserter(buf), "{} + {} = {}", 2, 3, 5);

    // std::format_to_n
    char arr[10];
    auto res = std::format_to_n(arr, 10, "PI: {:.2f}", 3.14159);
    // res.out 指向数组末尾，res.size 为实际写入长度（不含终止符）

    // std::formatted_size
    size_t size = std::formatted_size("Answer: {}", 42); // size = 10
}
```

### 3. **类型擦除函数（vformat 系列）**
```cpp
// 使用 format_args 进行运行时格式化
std::string vformat(std::string_view fmt, std::format_args args);
void vformat_to(auto out, std::string_view fmt, std::format_args args);

// 创建 format_args
template<class... Args>
std::make_format_args<Args...> make_format_args(Args&&... args);
```

**示例：动态格式化**
```cpp
#include <format>

void log_message(std::string_view fmt, std::format_args args) {
    std::string msg = std::vformat(fmt, args);
    // 写入日志...
}

template<class... Args>
void log(std::string_view fmt, Args&&... args) {
    log_message(fmt, std::make_format_args(args...));
}

int main() {
    log("Error: {} at line {}", "File not found", 42);
}
```

### 4. **范围格式化（C++23）**
```cpp
#include <format>
#include <vector>

int main() {
    std::vector<int> v = {1, 2, 3};
    // 需编译器支持 C++23 范围格式化
    std::cout << std::format("Vector: {}", v); // 输出: Vector: [1, 2, 3]
}
```

### 5. **异常 `std::format_error`**
```cpp
try {
    std::format("Invalid: {", 42); // 缺少闭合括号
} catch (const std::format_error& e) {
    std::cout << e.what(); // 输出错误信息
}
```

## 3. 完整示例代码
```cpp
#include <format>
#include <iostream>
#include <vector>

// 自定义类型特化
struct Point { double x, y; };

template<>
struct std::formatter<Point> {
    constexpr auto parse(auto& ctx) { return ctx.begin(); }
    auto format(const Point& p, auto& ctx) const {
        return std::format_to(ctx.out(), "({:.1f}, {:.1f})", p.x, p.y);
    }
};

int main() {
    // 基本格式化
    std::cout << std::format("Hello, {}!\n", "World");

    // 自定义类型
    Point p{1.0, 2.5};
    std::cout << std::format("Point: {}\n", p);

    // 动态格式化
    auto args = std::make_format_args(42, "answer");
    std::string s = std::vformat("{} is the {}", args);
    std::cout << s << "\n";

    // 写入迭代器
    std::vector<char> buf;
    std::format_to(std::back_inserter(buf), "PI: {:.2f}", 3.14159);
    for (char c : buf) std::cout << c;
    std::cout << "\n";

    // 计算大小
    size_t n = std::formatted_size("Value: {}", 12345);
    std::cout << "Required size: " << n << "\n"; // 输出 12
}
```

