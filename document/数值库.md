# 数值库头文件

```c
#include <cmath>
#include <climits>
#include <complex>
#include <numeric>
#include <random>
#include <limits>
#include <ratio>
#include <numbers> //C++20
#include <linalg> //C++23

#include <algorithm> // 算法库
```



# 数值库概要

C++ 数值库包含常用数学函数和类型，以及优化的数值数组和随机数生成支持。



### [浮点数环境](./cdefine.md)

> 详细见 cmath 详细见	 [](./cdefine.md) 	的第四章



### [常用数学函数](https://cppreference.cn/w/cpp/numeric/math)

头文件 [`<cmath>`](https://cppreference.cn/w/cpp/header/cmath) 提供了 [标准 C 库数学函数](https://cppreference.cn/w/cpp/numeric/math)，例如 [std::fabs](https://cppreference.cn/w/cpp/numeric/math/fabs)、 [std::sqrt](https://cppreference.cn/w/cpp/numeric/math/sqrt) 和 [std::sin](https://cppreference.cn/w/cpp/numeric/math/sin)。

> cmath 详细见	 [](./cdefine.md) 	的第八章



### [随机数生成器和分布](https://cppreference.cn/w/cpp/header/random)

头文件 [`<random>`](https://cppreference.cn/w/cpp/header/random) 提供了泊松分布、正态分布、伯努利分布、均匀分布、抽样分布等概率论的数学运算，也提供关于随机数生成器进行使用

[第三章<randon> 第4节，预定义生成器]: 



### [复数算术](https://cppreference.cn/w/cpp/numeric/complex)

头文件 [`<complex>`](https://cppreference.cn/w/cpp/header/cmath) 也提供了几个数学复数函数，例如 [std::real](https://cppreference.cn/w/cpp/numeric/complex/real2)、[std::imag](https://cppreference.cn/w/cpp/numeric/complex/imag2)



###  [数值数组](https://cppreference.cn/w/cpp/header/valarray)

头文件 [`<valarray>`](https://cppreference.cn/w/cpp/header/valarray) 也提供了数值数组、数组掩码和数组切片  (类模板)，使用类似[`restrict`关键字](./关键字.md)的特性进行优化计算，不过常使用 `表达式模板进行替代`



### [limits基本数据类型属性的标准化](https://cppreference.cn/w/cpp/header/limits)

详细见 [](./cdefine.md) 的 climits



### [numeric](https://cppreference.cn/w/cpp/header/numeric)

头文件 [`<numeric>`](https://cppreference.cn/w/cpp/header/numeric) 提供了常用的封装算法接口，如[std::iota](https://cppreference.cn/w/cpp/algorithm/iota)、[std::accumulate](https://cppreference.cn/w/cpp/algorithm/accumulate)、[std::reduce](https://cppreference.cn/w/cpp/algorithm/reduce)，常用和[ranges](./ranges)（C++20）一起使用

> 详细见	[](./算法库.md)



### [ratio](https://cppreference.cn/w/cpp/header/ratio)

头文件  [`<ratio>`](https://cppreference.cn/w/cpp/header/ratio) ，ratio是一个模板类，表示分数对象，可以进行编译期间 加减乘除，注意该对象是保留两个数字的，而不是计算好的分数，

```c
template <intmax_t N, intmax_t D = 1>
class ratio {
    public:
    typedef ratio<num, den> type;
    static constexpr intmax_t num;
    static constexpr intmax_t den;
};
```



###  [数学特殊函数](https://cppreference.cn/w/cpp/numeric/special_functions) (自 C++17 起)

头文件 [`<cmath>`](https://cppreference.cn/w/cpp/header/cmath) 也提供了几个数学特殊函数，例如 [std::beta](https://cppreference.cn/w/cpp/numeric/special_functions/beta)、 [std::hermite](https://cppreference.cn/w/cpp/numeric/special_functions/hermite) 和 [std::cyl_bessel_i](https://cppreference.cn/w/cpp/numeric/special_functions/cyl_bessel_i)。



###  [数学常数](https://cppreference.cn/w/cpp/numeric/constants) (自 C++20 起)

头文件 [`<numbers>`](https://cppreference.cn/w/cpp/header/numbers) 提供了几个数学常数，例如 [std::numbers::pi](https://cppreference.cn/w/cpp/numeric/constants) 或 [std::numbers::sqrt2](https://cppreference.cn/w/cpp/numeric/constants)



### [bit](https://cppreference.cn/w/cpp/header/bit) (自 C++20 起)

头文件 [`<bit>`](https://cppreference.cn/w/cpp/header/bit) ，提供了处理位级别操作的功能，包括字节序操作、位操作和类型转换等



###  [基本线性代数算法](https://cppreference.cn/w/cpp/numeric/linalg) (自 C++26 起)

头文件 [`<linalg>`](https://cppreference.cn/w/cpp/header/linalg) 提供了基于 BLAS 的基本线性代数算法。



###  [数据并行类型](https://cppreference.cn/w/cpp/numeric/simd) (自 C++26 起)

头文件 [`<simd>`](https://cppreference.cn/w/cpp/header/simd) 提供了可移植的类型，用于显式声明数据并行性并构建数据以实现更高效的 SIMD 访问。

 

# 一、`<`numbers`>`数学常量

```cpp
namespace std::numbers {
  template<class T> inline constexpr T e_v          = /* unspecified */;
  template<class T> inline constexpr T log2e_v      = /* unspecified */;
  template<class T> inline constexpr T log10e_v     = /* unspecified */;
  template<class T> inline constexpr T pi_v         = /* unspecified */;
  template<class T> inline constexpr T inv_pi_v     = /* unspecified */;
  template<class T> inline constexpr T inv_sqrtpi_v = /* unspecified */;
  template<class T> inline constexpr T ln2_v        = /* unspecified */;
  template<class T> inline constexpr T ln10_v       = /* unspecified */;
  template<class T> inline constexpr T sqrt2_v      = /* unspecified */;
  template<class T> inline constexpr T sqrt3_v      = /* unspecified */;
  template<class T> inline constexpr T inv_sqrt3_v  = /* unspecified */;
  template<class T> inline constexpr T egamma_v     = /* unspecified */;
  template<class T> inline constexpr T phi_v        = /* unspecified */;
 
  template<floating_point T> inline constexpr T e_v<T>          = /* see description */;
  template<floating_point T> inline constexpr T log2e_v<T>      = /* see description */;
  template<floating_point T> inline constexpr T log10e_v<T>     = /* see description */;
  template<floating_point T> inline constexpr T pi_v<T>         = /* see description */;
  template<floating_point T> inline constexpr T inv_pi_v<T>     = /* see description */;
  template<floating_point T> inline constexpr T inv_sqrtpi_v<T> = /* see description */;
  template<floating_point T> inline constexpr T ln2_v<T>        = /* see description */;
  template<floating_point T> inline constexpr T ln10_v<T>       = /* see description */;
  template<floating_point T> inline constexpr T sqrt2_v<T>      = /* see description */;
  template<floating_point T> inline constexpr T sqrt3_v<T>      = /* see description */;
  template<floating_point T> inline constexpr T inv_sqrt3_v<T>  = /* see description */;
  template<floating_point T> inline constexpr T egamma_v<T>     = /* see description */;
  template<floating_point T> inline constexpr T phi_v<T>        = /* see description */;
 
  inline constexpr double e          = e_v<double>;
  inline constexpr double log2e      = log2e_v<double>;
  inline constexpr double log10e     = log10e_v<double>;
  inline constexpr double pi         = pi_v<double>;
  inline constexpr double inv_pi     = inv_pi_v<double>;
  inline constexpr double inv_sqrtpi = inv_sqrtpi_v<double>;
  inline constexpr double ln2        = ln2_v<double>;
  inline constexpr double ln10       = ln10_v<double>;
  inline constexpr double sqrt2      = sqrt2_v<double>;
  inline constexpr double sqrt3      = sqrt3_v<double>;
  inline constexpr double inv_sqrt3  = inv_sqrt3_v<double>;
  inline constexpr double egamma     = egamma_v<double>;
  inline constexpr double phi        = phi_v<double>;
}
```

------



# 二、`<`complex`>`复数



# 三、`<bit>`字节

`<bit>` 头文件提供了处理位级别操作的功能，包括字节序操作、位操作和类型转换等。以下是详细说明和示例：

## 1. 函数方法表格

| 函数名                | 功能描述                                 | 参数         | 返回值         |
| --------------------- | ---------------------------------------- | ------------ | -------------- |
| `std::endian`         | 表示标量类型的字节序                     | -            | 枚举值         |
| `std::bit_cast`       | 将一种类型的对象表示重新解释为另一种类型 | 源对象       | 目标类型的对象 |
| `std::byteswap`       | 反转给定整数值中的字节                   | 整数值       | 字节反转后的值 |
| `std::has_single_bit` | 检查一个数是否是2的整数次幂              | 无符号整数   | `bool`         |
| `std::bit_ceil`       | 查找不小于给定值的最小2的整数幂          | 无符号整数   | 无符号整数     |
| `std::bit_floor`      | 查找不大于给定值的最大2的整数幂          | 无符号整数   | 无符号整数     |
| `std::bit_width`      | 查找表示给定值所需的最小位数             | 无符号整数   | 无符号整数     |
| `std::rotl`           | 计算按位左旋的结果                       | 值，旋转位数 | 旋转后的值     |
| `std::rotr`           | 计算按位右旋的结果                       | 值，旋转位数 | 旋转后的值     |
| `std::countl_zero`    | 计算从最高有效位开始的连续0位的数量      | 无符号整数   | 整数           |
| `std::countl_one`     | 计算从最高有效位开始的连续1位的数量      | 无符号整数   | 整数           |
| `std::countr_zero`    | 计算从最低有效位开始的连续0位的数量      | 无符号整数   | 整数           |
| `std::countr_one`     | 计算从最低有效位开始的连续1位的数量      | 无符号整数   | 整数           |
| `std::popcount`       | 计算无符号整数中1位的数量                | 无符号整数   | 整数           |

## 2. 完整示例代码

```cpp
#include <bit>
#include <iostream>
#include <cstdint>
#include <bitset>
#include <format>

// 辅助函数，用于打印二进制表示
template<typename T>
void print_binary(T value) {
    std::bitset<sizeof(T) * 8> bits(value);
    std::cout << std::format("0b{:0{}b}", value, sizeof(T) * 8) << " (" << bits << ")" << std::endl;
}

int main() {
    std::cout << "=== C++20 <bit> 头文件功能演示 ===\n\n";
    
    // 1. 字节序检测
    std::cout << "1. 系统字节序: ";
    if constexpr (std::endian::native == std::endian::little) {
        std::cout << "小端序 (Little Endian)\n";
    } else if constexpr (std::endian::native == std::endian::big) {
        std::cout << "大端序 (Big Endian)\n";
    } else {
        std::cout << "混合字节序\n";
    }
    std::cout << std::endl;
    
    // 2. bit_cast - 类型安全的内存重新解释
    std::cout << "2. std::bit_cast 示例:\n";
    float f = 3.14f;
    auto i = std::bit_cast<uint32_t>(f);
    std::cout << std::format("浮点数 {} 的位表示: ", f);
    print_binary(i);
    std::cout << std::endl;
    
    // 3. byteswap - 字节交换
    std::cout << "3. std::byteswap 示例:\n";
    uint32_t value = 0x12345678;
    std::cout << std::format("原始值: 0x{:08X}\n", value);
    std::cout << std::format("字节交换后: 0x{:08X}\n", std::byteswap(value));
    std::cout << std::endl;
    
    // 4. has_single_bit - 检查是否为2的幂
    std::cout << "4. std::has_single_bit 示例:\n";
    for (uint16_t n : {0, 1, 2, 3, 4, 5, 8, 16}) {
        std::cout << std::format("{:2d} 是2的幂次方吗? {}\n", n, std::has_single_bit(n));
    }
    std::cout << std::endl;
    
    // 5. bit_ceil - 向上取整到2的幂
    std::cout << "5. std::bit_ceil 示例:\n";
    for (uint16_t n : {0, 1, 2, 3, 4, 5, 8, 15, 16, 17}) {
        try {
            std::cout << std::format("bit_ceil({:2d}) = {:2d}\n", n, std::bit_ceil(n));
        } catch (const std::exception& e) {
            std::cout << std::format("bit_ceil({:2d}) 错误: {}\n", n, e.what());
        }
    }
    std::cout << std::endl;
    
    // 6. bit_floor - 向下取整到2的幂
    std::cout << "6. std::bit_floor 示例:\n";
    for (uint16_t n : {0, 1, 2, 3, 4, 5, 8, 15, 16, 17}) {
        std::cout << std::format("bit_floor({:2d}) = {:2d}\n", n, std::bit_floor(n));
    }
    std::cout << std::endl;
    
    // 7. bit_width - 表示值所需的最小位数
    std::cout << "7. std::bit_width 示例:\n";
    for (uint16_t n : {0, 1, 2, 3, 4, 5, 8, 15, 16, 255}) {
        std::cout << std::format("bit_width({:3d}) = {:2d}\n", n, std::bit_width(n));
    }
    std::cout << std::endl;
    
    // 8. rotl - 循环左移
    std::cout << "8. std::rotl 示例:\n";
    uint8_t num = 0b11010010; // 210
    std::cout << "原始值: ";
    print_binary(num);
    
    for (int s = 1; s <= 4; s++) {
        auto result = std::rotl(num, s);
        std::cout << std::format("循环左移 {} 位: ", s);
        print_binary(result);
    }
    std::cout << std::endl;
    
    // 9. rotr - 循环右移
    std::cout << "9. std::rotr 示例:\n";
    std::cout << "原始值: ";
    print_binary(num);
    
    for (int s = 1; s <= 4; s++) {
        auto result = std::rotr(num, s);
        std::cout << std::format("循环右移 {} 位: ", s);
        print_binary(result);
    }
    std::cout << std::endl;
    
    // 10. countl_zero - 前导零计数
    std::cout << "10. std::countl_zero 示例:\n";
    for (uint16_t n : {0, 1, 2, 3, 4, 5, 8, 16, 255, 256, 1024}) {
        std::cout << std::format("countl_zero({:4d}) = {:2d}\n", n, std::countl_zero(n));
    }
    std::cout << std::endl;
    
    // 11. countl_one - 前导一计数
    std::cout << "11. std::countl_one 示例:\n";
    for (uint16_t n : {0xFFFF, 0xFF00, 0xF000, 0x8000, 0x0000}) {
        std::cout << std::format("countl_one(0x{:04X}) = {:2d}\n", n, std::countl_one(n));
    }
    std::cout << std::endl;
    
    // 12. countr_zero - 后缀零计数
    std::cout << "12. std::countr_zero 示例:\n";
    for (uint16_t n : {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}) {
        std::cout << std::format("countr_zero({:4d}) = {:2d}\n", n, std::countr_zero(n));
    }
    std::cout << std::endl;
    
    // 13. countr_one - 后缀一计数
    std::cout << "13. std::countr_one 示例:\n";
    for (uint16_t n : {0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF}) {
        std::cout << std::format("countr_one(0x{:04X}) = {:2d}\n", n, std::countr_one(n));
    }
    std::cout << std::endl;
    
    // 14. popcount - 设置位计数
    std::cout << "14. std::popcount 示例:\n";
    for (uint16_t n : {0, 1, 2, 3, 4, 5, 8, 15, 16, 255, 256, 1023}) {
        std::cout << std::format("popcount({:4d}) = {:2d}\n", n, std::popcount(n));
    }
    std::cout << std::endl;
    
    return 0;
}
```

------



# 四、`<limits>` 数值类型限制

`<limits>` 头文件是 C++ 类型支持库的一部分，提供了查询各种基本数据类型属性的标准化方法，主要通过 `numeric_limits` 类模板实现。

## 1. 枚举类型说明

### （1）std::float_round_style
| 枚举值                      | 描述             |
| --------------------------- | ---------------- |
| `round_indeterminate`       | 无法确定舍入样式 |
| `round_toward_zero`         | 向零舍入（截断） |
| `round_to_nearest`          | 向最接近的值舍入 |
| `round_toward_infinity`     | 向正无穷舍入     |
| `round_toward_neg_infinity` | 向负无穷舍入     |

**功能**: 表示浮点数类型使用的舍入模式。

### （2）std::float_denorm_style
| 枚举值                 | 描述                     |
| ---------------------- | ------------------------ |
| `denorm_indeterminate` | 无法确定反常值处理方式   |
| `denorm_absent`        | 不支持反常值（次正规数） |
| `denorm_present`       | 支持反常值（次正规数）   |

**功能**: 表示浮点数类型对反常值（denormalized numbers）的处理方式。

## 2. numeric_limits 类模板成员说明

### （1）基本属性
| 成员             | 类型                 | 描述                                       |
| ---------------- | -------------------- | ------------------------------------------ |
| `is_specialized` | `constexpr bool`     | 表示是否为特定类型提供了特化               |
| `min()`          | `static constexpr T` | 返回类型可表示的最小有限值                 |
| `max()`          | `static constexpr T` | 返回类型可表示的最大有限值                 |
| `lowest()`       | `static constexpr T` | 返回类型可表示的最小值（对浮点数为负无穷） |

### （2）数值特性
| 成员           | 类型             | 描述                                 |
| -------------- | ---------------- | ------------------------------------ |
| `digits`       | `constexpr int`  | 基数位数（整型）或尾数位数（浮点型） |
| `digits10`     | `constexpr int`  | 十进制精度位数                       |
| `max_digits10` | `constexpr int`  | 确保唯一表示所需的最大十进制位数     |
| `is_signed`    | `constexpr bool` | 类型是否有符号                       |
| `is_integer`   | `constexpr bool` | 类型是否为整数类型                   |
| `is_exact`     | `constexpr bool` | 类型表示是否精确                     |
| `radix`        | `constexpr int`  | 表示使用的基数（通常为2）            |

### （3）浮点特性
| 成员             | 类型                 | 描述                           |
| ---------------- | -------------------- | ------------------------------ |
| `epsilon()`      | `static constexpr T` | 返回1与大于1的最小值之间的差值 |
| `round_error()`  | `static constexpr T` | 测量最大舍入误差               |
| `min_exponent`   | `constexpr int`      | 最小负整数指数                 |
| `min_exponent10` | `constexpr int`      | 最小负十进制指数               |
| `max_exponent`   | `constexpr int`      | 最大正整数指数                 |
| `max_exponent10` | `constexpr int`      | 最大正十进制指数               |

### （3）特殊值支持
| 成员                | 类型                           | 描述                   |
| ------------------- | ------------------------------ | ---------------------- |
| `has_infinity`      | `constexpr bool`               | 是否支持无穷大表示     |
| `has_quiet_NaN`     | `constexpr bool`               | 是否支持静默NaN        |
| `has_signaling_NaN` | `constexpr bool`               | 是否支持信号NaN        |
| `has_denorm`        | `constexpr float_denorm_style` | 反常值支持状态         |
| `has_denorm_loss`   | `constexpr bool`               | 精度损失是否检测为反常 |
| `infinity()`        | `static constexpr T`           | 返回正无穷表示         |
| `quiet_NaN()`       | `static constexpr T`           | 返回静默NaN表示        |
| `signaling_NaN()`   | `static constexpr T`           | 返回信号NaN表示        |
| `denorm_min()`      | `static constexpr T`           | 返回最小正反常值       |

### （4）其他属性
| 成员              | 类型                          | 描述                         |
| ----------------- | ----------------------------- | ---------------------------- |
| `is_iec559`       | `constexpr bool`              | 是否符合IEC 559/IEEE 754标准 |
| `is_bounded`      | `constexpr bool`              | 类型值集是否有限             |
| `is_modulo`       | `constexpr bool`              | 类型是否遵循模运算           |
| `traps`           | `constexpr bool`              | 类型是否捕获浮点异常         |
| `tinyness_before` | `constexpr bool`              | 是否在舍入前检测微小值       |
| `round_style`     | `constexpr float_round_style` | 浮点舍入样式                 |

## 3. 特化版本

`numeric_limits` 为所有基本数值类型提供了特化版本，包括：
- 布尔类型：`numeric_limits<bool>`
- 字符类型：`char`, `signed char`, `unsigned char`, `char8_t`, `char16_t`, `char32_t`, `wchar_t`
- 整数类型：所有有符号和无符号整数类型
- 浮点类型：`float`, `double`, `long double`

## 4. 使用场景

1. **编写可移植代码**：查询类型特性以确保代码在不同平台上的正确性
2. **算法优化**：根据类型特性选择最优算法实现
3. **数值计算**：处理边界条件、精度问题和特殊值
4. **模板元编程**：在编译时根据类型特性做出决策
5. **错误处理**：检测和处理数值溢出、下溢等情况

## 5. 示例用法

```cpp
#include <limits>
#include <iostream>

int main() {
    std::cout << "int 最大值: " << std::numeric_limits<int>::max() << std::endl;
    std::cout << "double 最小值: " << std::numeric_limits<double>::min() << std::endl;
    std::cout << "float 精度位数: " << std::numeric_limits<float>::digits10 << std::endl;
    
    return 0;
}
```

这个头文件提供了跨平台的类型特性查询方法，是编写健壮、可移植C++程序的重要工具。

# 五、`<`valarray`>`数值数组

## 1. 概述

`std::valarray` 是 C++ 标准库中专门为高性能数值计算设计的类模板。它表示一维数值数组，并提供了丰富的数学运算功能。与标准容器（如 `std::vector`）不同，`std::valarray` 的设计允许编译器进行更激进的优化，类似于 C 语言中 `restrict` 关键字的效果。

## 2. 核心特性

1. **元素级运算**：支持对整个数组应用数学运算
2. **免别名保证**：允许编译器假设数据没有重叠，启用优化
3. **表达式模板**：许多实现使用表达式模板来优化复杂表达式
4. **广义下标**：支持切片、掩码和间接访问

## 3. 基本用法示例

```cpp
#include <iostream>
#include <valarray>
#include <cmath>

int main() {
    // 1. 构造函数示例
    std::valarray<int> v1 = {1, 2, 3, 4, 5}; // 初始化列表
    std::valarray<int> v2(5, 10); // 10个元素，每个初始化为5
    std::valarray<int> v3(v1); // 拷贝构造
    
    // 2. 基本操作
    std::cout << "Size: " << v1.size() << std::endl;
    std::cout << "Sum: " << v1.sum() << std::endl;
    std::cout << "Min: " << v1.min() << std::endl;
    std::cout << "Max: " << v1.max() << std::endl;
    
    // 3. 元素级运算
    v1 += 2; // 每个元素加2
    v1 = v1 * 2; // 每个元素乘2
    
    std::valarray<int> v4 = v1 + v2; // 逐元素加法
    std::valarray<int> v5 = v1 * v2; // 逐元素乘法
    
    // 4. 数学函数应用
    std::valarray<double> v6 = {0.0, 0.5, 1.0, 1.5};
    std::valarray<double> v7 = std::sin(v6); // 对每个元素求sin
    
    // 5. 下标操作
    std::cout << "First element: " << v1[0] << std::endl;
    v1[1] = 10; // 修改单个元素
    
    // 6. 切片操作
    std::valarray<int> v8 = v1[std::slice(0, 3, 1)]; // 取前3个元素
    std::valarray<int> v9 = v1[std::slice(0, 3, 2)]; // 取索引0,2,4的元素
    
    // 7. 条件操作
    std::valarray<bool> mask = v1 > 5; // 创建掩码
    std::valarray<int> v10 = v1[mask]; // 应用掩码
    
    // 8. 循环移位
    std::valarray<int> v11 = v1.cshift(2); // 循环左移2位
    std::valarray<int> v12 = v1.shift(-1); // 右移1位，用0填充
    
    // 9. 应用自定义函数
    v1 = v1.apply([](int x) { return x * x; }); // 平方每个元素
    
    return 0;
}
```

## 4. 切片和广义下标示例

```cpp
#include <iostream>
#include <valarray>

int main() {
    std::valarray<int> data = {0,1,2,3,4,5,6,7,8,9};
    
    // 1. 基本切片: 起始索引、长度、步长
    std::slice my_slice(2, 4, 2); // 从索引2开始，取4个元素，步长为2
    std::valarray<int> sliced = data[my_slice]; // 结果为 {2,4,6,8}
    
    // 2. 广义切片: 起始索引、长度数组、步长数组
    std::size_t lengths[] = {2, 2};
    std::size_t strides[] = {3, 1};
    std::gslice my_gslice(1, std::valarray<std::size_t>(lengths, 2), 
                         std::valarray<std::size_t>(strides, 2));
    std::valarray<int> gsliced = data[my_gslice]; // 结果为 {1,2,4,5}
    
    // 3. 掩码索引
    std::valarray<bool> mask = {true, false, true, false, true, 
                               false, true, false, true, false};
    std::valarray<int> masked = data[mask]; // 结果为 {0,2,4,6,8}
    
    // 4. 间接索引
    std::valarray<std::size_t> indices = {3, 1, 4, 1, 5};
    std::valarray<int> indirect = data[indices]; // 结果为 {3,1,4,1,5}
    
    return 0;
}
```

## 5. 表达式模板与性能优化

### （1）表达式模板概念

表达式模板是一种元编程技术，用于将数值表达式转换为模板表达式树，从而延迟计算并优化性能。这使得像 `v1 = a * v2 + v3` 这样的表达式可以被优化为单循环执行，避免创建临时对象。

详细文章介绍	https://blog.csdn.net/HaoBBNuanMM/article/details/109740504

### （3）表达式模板示例

```cpp
#include <iostream>
#include <vector>

// 简单的表达式模板实现示例
template<typename Expr>
class VecExpression {
public:
    double operator[](size_t i) const { 
        return static_cast<Expr const&>(*this)[i]; 
    }
    size_t size() const { 
        return static_cast<Expr const&>(*this).size(); 
    }
};

// 具体向量类
class Vec : public VecExpression<Vec> {
    std::vector<double> elems;
public:
    Vec() = default;
    Vec(size_t n) : elems(n) {}
    Vec(std::initializer_list<double> init) : elems(init) {}
    
    double operator[](size_t i) const { return elems[i]; }
    double& operator[](size_t i) { return elems[i]; }
    size_t size() const { return elems.size(); }
    
    // 从表达式构造
    template<typename Expr>
    Vec(VecExpression<Expr> const& expr) {
        elems.resize(expr.size());
        for (size_t i = 0; i < expr.size(); ++i) {
            elems[i] = expr[i];
        }
    }
    
    // 从表达式赋值
    template<typename Expr>
    Vec& operator=(VecExpression<Expr> const& expr) {
        for (size_t i = 0; i < expr.size(); ++i) {
            elems[i] = expr[i];
        }
        return *this;
    }
};

// 向量加法表达式
template<typename LHS, typename RHS>
class VecSum : public VecExpression<VecSum<LHS, RHS>> {
    LHS const& lhs;
    RHS const& rhs;
public:
    VecSum(LHS const& l, RHS const& r) : lhs(l), rhs(r) {}
    
    double operator[](size_t i) const { return lhs[i] + rhs[i]; }
    size_t size() const { return lhs.size(); }
};

// 向量标量乘法表达式
template<typename Expr>
class VecScalarMul : public VecExpression<VecScalarMul<Expr>> {
    Expr const& expr;
    double scalar;
public:
    VecScalarMul(Expr const& e, double s) : expr(e), scalar(s) {}
    
    double operator[](size_t i) const { return expr[i] * scalar; }
    size_t size() const { return expr.size(); }
};

// 运算符重载
template<typename LHS, typename RHS>
VecSum<LHS, RHS> operator+(VecExpression<LHS> const& lhs, 
                           VecExpression<RHS> const& rhs) {
    return VecSum<LHS, RHS>(static_cast<LHS const&>(lhs), 
                           static_cast<RHS const&>(rhs));
}

template<typename Expr>
VecScalarMul<Expr> operator*(double scalar, VecExpression<Expr> const& expr) {
    return VecScalarMul<Expr>(static_cast<Expr const&>(expr), scalar);
}

int main() {
    Vec v1 = {1, 2, 3, 4, 5};
    Vec v2 = {2, 3, 4, 5, 6};
    Vec v3;
    
    // 使用表达式模板，不会创建临时对象
    v3 = 2.0 * v1 + v2; // 被优化为单循环: v3[i] = 2.0 * v1[i] + v2[i]
    
    for (size_t i = 0; i < v3.size(); ++i) {
        std::cout << v3[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

## 6. 表达式模板 vs. `std::valarray`

虽然 `std::valarray` 的设计初衷是支持高性能数值计算，但实际中许多数值库选择使用表达式模板而不是 `std::valarray`，因为表达式模板提供了更大的灵活性，且性能更好。

以以下代码测试矩阵运算为基准，Intel(R) Core(TM) i5-10200H CPU @ 2.40GHz   2.40 GHz，X64-Release的情况下，400行列的矩阵运算性能相当，当行列数继续增大那么表达式模板性能开始显现

```
=== 表达式模板实现 ===
Computation time: 209 ms

=== Valarray 实现 ===
Computation time: 197 ms

=== 小矩阵测试（验证正确性）===
Small matrix test (Expression Template):
      15.5         18         21
        21         26         30
        27         33       39.5
Small matrix test (Valarray):
      15.5         18         21
        21         26         30
        27         33       39.5
```



```cpp
#include <valarray>
#include <vector>
#include <stdexcept>
#include <iostream>
#include <iomanip>

// 表达式模板实现
namespace ExpressionTemplate {

    // 表达式基类
    template<typename E>
    class MatrixExpr {
    public:
        double operator()(size_t i, size_t j) const {
            return static_cast<const E&>(*this)(i, j);
        }

        size_t rows() const { return static_cast<const E&>(*this).rows(); }
        size_t cols() const { return static_cast<const E&>(*this).cols(); }

        operator E& () { return static_cast<E&>(*this); }
        operator const E& () const { return static_cast<const E&>(*this); }
    };

    // 具体矩阵类
    class Matrix : public MatrixExpr<Matrix> {
        std::vector<double> data;
        size_t n_rows, n_cols;

    public:
        Matrix(size_t rows, size_t cols) : n_rows(rows), n_cols(cols), data(rows* cols) {}

        Matrix(size_t rows, size_t cols, double value) : n_rows(rows), n_cols(cols), data(value, rows* cols) {}

        // 从表达式构造
    template<typename E>
    Matrix(const MatrixExpr<E>& expr) : n_rows(expr.rows()), n_cols(expr.cols()) {
        data.resize(n_rows * n_cols);
        // 直接在初始化列表中分配内存，避免额外的resize操作
        // 使用更高效的内存访问模式
        for (size_t i = 0; i < n_rows; ++i) {
            size_t row_offset = i * n_cols;
            for (size_t j = 0; j < n_cols; ++j) {
                data[row_offset + j] = expr(i, j);
            }
        }
        }

        double operator()(size_t i, size_t j) const {
            return data[i * n_cols + j];
        }

        double& operator()(size_t i, size_t j) {
            return data[i * n_cols + j];
        }

        size_t rows() const { return n_rows; }
        size_t cols() const { return n_cols; }

        // 矩阵求逆（使用高斯-约当消元法）
        Matrix inverse() const {
            if (n_rows != n_cols) {
                throw std::runtime_error("Matrix must be square for inversion");
            }

            size_t n = n_rows;
            Matrix result(n, n);
            Matrix temp(*this);

            // 初始化单位矩阵
            for (size_t i = 0; i < n; ++i) {
                for (size_t j = 0; j < n; ++j) {
                    result(i, j) = (i == j) ? 1.0 : 0.0;
                }
            }

            // 高斯-约当消元
            for (size_t i = 0; i < n; ++i) {
                // 寻找主元
                double max_val = std::abs(temp(i, i));
                size_t max_row = i;
                for (size_t k = i + 1; k < n; ++k) {
                    if (std::abs(temp(k, i)) > max_val) {
                        max_val = std::abs(temp(k, i));
                        max_row = k;
                    }
                }

                // 交换行
                if (max_row != i) {
                    for (size_t j = 0; j < n; ++j) {
                        std::swap(temp(i, j), temp(max_row, j));
                        std::swap(result(i, j), result(max_row, j));
                    }
                }

                // 归一化
                double pivot = temp(i, i);
                if (std::abs(pivot) < 1e-10) {
                    throw std::runtime_error("Matrix is singular");
                }

                for (size_t j = 0; j < n; ++j) {
                    temp(i, j) /= pivot;
                    result(i, j) /= pivot;
                }

                // 消元
                for (size_t k = 0; k < n; ++k) {
                    if (k != i) {
                        double factor = temp(k, i);
                        for (size_t j = 0; j < n; ++j) {
                            temp(k, j) -= factor * temp(i, j);
                            result(k, j) -= factor * result(i, j);
                        }
                    }
                }
            }

            return result;
        }

        // 打印矩阵
        void print() const {
            for (size_t i = 0; i < n_rows; ++i) {
                for (size_t j = 0; j < n_cols; ++j) {
                    std::cout << std::setw(10) << std::setprecision(4) << (*this)(i, j) << " ";
                }
                std::cout << std::endl;
            }
        }
    };

    // 矩阵加法表达式
    template<typename E1, typename E2>
    class MatrixAdd : public MatrixExpr<MatrixAdd<E1, E2>> {
        const E1& a;
        const E2& b;

    public:
        MatrixAdd(const MatrixExpr<E1>& a, const MatrixExpr<E2>& b) : a(a), b(b) {
            if (a.rows() != b.rows() || a.cols() != b.cols()) {
                throw std::runtime_error("Matrix dimensions must match for addition");
            }
        }

        double operator()(size_t i, size_t j) const {
            return a(i, j) + b(i, j);
        }

        size_t rows() const { return a.rows(); }
        size_t cols() const { return a.cols(); }
    };

    // 矩阵乘法表达式
    template<typename E1, typename E2>
    class MatrixMult : public MatrixExpr<MatrixMult<E1, E2>> {
        const E1& a;
        const E2& b;
        const size_t a_cols; // 缓存常用维度，避免重复调用

    public:
        MatrixMult(const MatrixExpr<E1>& a, const MatrixExpr<E2>& b) : a(a), b(b), a_cols(a.cols()) {
            if (a_cols != b.rows()) {
                throw std::runtime_error("Matrix dimensions must match for multiplication");
            }
        }

        double operator()(size_t i, size_t j) const {
            // 使用更高效的循环展开和缓存友好的访问模式
            double sum = 0.0;
            const size_t block_size = 4; // 小块计算以提高缓存命中率
            size_t k = 0;
            
            // 主循环使用块处理
            for (; k + block_size <= a_cols; k += block_size) {
                sum += a(i, k) * b(k, j) +
                       a(i, k+1) * b(k+1, j) +
                       a(i, k+2) * b(k+2, j) +
                       a(i, k+3) * b(k+3, j);
            }
            
            // 处理剩余元素
            for (; k < a_cols; ++k) {
                sum += a(i, k) * b(k, j);
            }
            
            return sum;
        }

        size_t rows() const { return a.rows(); }
        size_t cols() const { return b.cols(); }
    };

    // 矩阵转置表达式
    template<typename E>
    class MatrixTranspose : public MatrixExpr<MatrixTranspose<E>> {
        const E& a;

    public:
        MatrixTranspose(const MatrixExpr<E>& a) : a(a) {}

        double operator()(size_t i, size_t j) const {
            return a(j, i);
        }

        size_t rows() const { return a.cols(); }
        size_t cols() const { return a.rows(); }
    };

    // 标量乘法表达式
    template<typename E>
    class MatrixScalarMult : public MatrixExpr<MatrixScalarMult<E>> {
        const E& a;
        double scalar;

    public:
        MatrixScalarMult(const MatrixExpr<E>& a, double scalar) : a(a), scalar(scalar) {}

        double operator()(size_t i, size_t j) const {
            return a(i, j) * scalar;
        }

        size_t rows() const { return a.rows(); }
        size_t cols() const { return a.cols(); }
    };

    // 运算符重载
    template<typename E1, typename E2>
    MatrixAdd<E1, E2> operator+(const MatrixExpr<E1>& a, const MatrixExpr<E2>& b) {
        return MatrixAdd<E1, E2>(a, b);
    }

    template<typename E1, typename E2>
    MatrixMult<E1, E2> operator*(const MatrixExpr<E1>& a, const MatrixExpr<E2>& b) {
        return MatrixMult<E1, E2>(a, b);
    }

    template<typename E>
    MatrixTranspose<E> transpose(const MatrixExpr<E>& a) {
        return MatrixTranspose<E>(a);
    }

    template<typename E>
    MatrixScalarMult<E> operator*(const MatrixExpr<E>& a, double scalar) {
        return MatrixScalarMult<E>(a, scalar);
    }

    template<typename E>
    MatrixScalarMult<E> operator*(double scalar, const MatrixExpr<E>& a) {
        return MatrixScalarMult<E>(a, scalar);
    }

} // namespace ExpressionTemplate

// Valarray实现
namespace ValarrayImpl {

    class Matrix {
        std::valarray<double> data;
        size_t n_rows, n_cols;

    public:
        Matrix(size_t rows, size_t cols) : n_rows(rows), n_cols(cols), data(rows* cols) {}

        Matrix(size_t rows, size_t cols, double value) : n_rows(rows), n_cols(cols), data(value, rows* cols) {}

        double operator()(size_t i, size_t j) const {
            return data[i * n_cols + j];
        }

        double& operator()(size_t i, size_t j) {
            return data[i * n_cols + j];
        }

        size_t rows() const { return n_rows; }
        size_t cols() const { return n_cols; }

        // 矩阵加法
        Matrix operator+(const Matrix& other) const {
            if (n_rows != other.n_rows || n_cols != other.n_cols) {
                throw std::runtime_error("Matrix dimensions must match for addition");
            }

            Matrix result(n_rows, n_cols);
            result.data = data + other.data;
            return result;
        }

        // 矩阵乘法 - 优化版本
    Matrix operator*(const Matrix& other) const {
        if (n_cols != other.n_rows) {
            throw std::runtime_error("Matrix dimensions must match for multiplication");
        }

        Matrix result(n_rows, other.n_cols);
        const size_t block_size = 4; // 使用块计算提高缓存效率
        
        // 使用分块矩阵乘法算法
        for (size_t i = 0; i < n_rows; ++i) {
            for (size_t j = 0; j < other.n_cols; ++j) {
                double sum = 0.0;
                size_t k = 0;
                
                // 主循环使用块处理
                for (; k + block_size <= n_cols; k += block_size) {
                    sum += (*this)(i, k) * other(k, j) +
                           (*this)(i, k+1) * other(k+1, j) +
                           (*this)(i, k+2) * other(k+2, j) +
                           (*this)(i, k+3) * other(k+3, j);
                }
                
                // 处理剩余元素
                for (; k < n_cols; ++k) {
                    sum += (*this)(i, k) * other(k, j);
                }
                
                result(i, j) = sum;
            }
        }
        return result;
        }

        // 标量乘法
        Matrix operator*(double scalar) const {
            Matrix result(n_rows, n_cols);
            result.data = data * scalar;
            return result;
        }

        // 矩阵转置 - 优化版本
    Matrix transpose() const {
        Matrix result(n_cols, n_rows);
        // 使用缓存友好的访问模式
        for (size_t i = 0; i < n_cols; ++i) {
            for (size_t j = 0; j < n_rows; ++j) {
                result(i, j) = (*this)(j, i);
            }
        }
        return result;
        }

        // 矩阵求逆（使用高斯-约当消元法）
        Matrix inverse() const {
            if (n_rows != n_cols) {
                throw std::runtime_error("Matrix must be square for inversion");
            }

            size_t n = n_rows;
            Matrix result(n, n);
            Matrix temp(*this);

            // 初始化单位矩阵
            for (size_t i = 0; i < n; ++i) {
                for (size_t j = 0; j < n; ++j) {
                    result(i, j) = (i == j) ? 1.0 : 0.0;
                }
            }

            // 高斯-约当消元
            for (size_t i = 0; i < n; ++i) {
                // 寻找主元
                double max_val = std::abs(temp(i, i));
                size_t max_row = i;
                for (size_t k = i + 1; k < n; ++k) {
                    if (std::abs(temp(k, i)) > max_val) {
                        max_val = std::abs(temp(k, i));
                        max_row = k;
                    }
                }

                // 交换行
                if (max_row != i) {
                    for (size_t j = 0; j < n; ++j) {
                        std::swap(temp(i, j), temp(max_row, j));
                        std::swap(result(i, j), result(max_row, j));
                    }
                }

                // 归一化
                double pivot = temp(i, i);
                if (std::abs(pivot) < 1e-10) {
                    throw std::runtime_error("Matrix is singular");
                }

                for (size_t j = 0; j < n; ++j) {
                    temp(i, j) /= pivot;
                    result(i, j) /= pivot;
                }

                // 消元
                for (size_t k = 0; k < n; ++k) {
                    if (k != i) {
                        double factor = temp(k, i);
                        for (size_t j = 0; j < n; ++j) {
                            temp(k, j) -= factor * temp(i, j);
                            result(k, j) -= factor * result(i, j);
                        }
                    }
                }
            }

            return result;
        }

        // 打印矩阵
        void print() const {
            for (size_t i = 0; i < n_rows; ++i) {
                for (size_t j = 0; j < n_cols; ++j) {
                    std::cout << std::setw(10) << std::setprecision(4) << data[i * n_cols + j] << " ";
                }
                std::cout << std::endl;
            }
        }
    };

} // namespace ValarrayImpl

// 生成随机矩阵
template<typename MatrixType>
void fill_random(MatrixType& mat) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.1, 1.0);

    for (size_t i = 0; i < mat.rows(); ++i) {
        for (size_t j = 0; j < mat.cols(); ++j) {
            mat(i, j) = dis(gen);
        }
    }
}

// 复杂的线性代数计算
template<typename MatrixType>
void complex_linear_algebra_computation(size_t size, bool print_result = false) {
    // 创建矩阵
    MatrixType A(size, size);
    MatrixType B(size, size);
    MatrixType C(size, size);
    MatrixType D(size, size);

    // 填充随机值
    fill_random(A);
    fill_random(B);
    fill_random(C);
    fill_random(D);

    // 执行复杂的线性代数计算
    // 计算: (A^T * B + C) * D^-1
    auto start = std::chrono::high_resolution_clock::now();

    // 使用表达式模板或valarray进行计算
    if constexpr (std::is_same_v<MatrixType, ExpressionTemplate::Matrix>) {
        // 表达式模板版本
        // 预先计算可重用的部分，避免重复计算
        ExpressionTemplate::Matrix AT = transpose(A); // 显式计算转置矩阵
        ExpressionTemplate::Matrix ATB = AT * B;     // 显式计算乘积
        ExpressionTemplate::Matrix ATB_C = ATB + C;  // 显式计算加法
        ExpressionTemplate::Matrix D_inv = D.inverse(); // 预先计算逆矩阵
        ExpressionTemplate::Matrix result = ATB_C * D_inv; // 最终计算

        // 防止优化，使用结果
        volatile double dummy = result(0, 0);

        if (print_result) {
            std::cout << "Result matrix (Expression Template):" << std::endl;
            result.print();
        }
    }
    else {
        // Valarray版本 - 优化实现
        // 预先计算可重用的部分，避免重复计算
        auto AT = A.transpose();       // 预先计算转置
        auto ATB = AT * B;             // 预先计算乘积
        auto ATB_C = ATB + C;          // 预先计算加法
        auto D_inv = D.inverse();      // 预先计算逆矩阵
        auto result = ATB_C * D_inv;   // 最终计算

        // 防止优化，使用结果
        volatile double dummy = result(0, 0);

        if (print_result) {
            std::cout << "Result matrix (Valarray):" << std::endl;
            result.print();
        }
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    std::cout << "Computation time: " << duration.count() << " ms" << std::endl;
}

int main() {
    const size_t MATRIX_SIZE = 400; // 矩阵大小
    const bool PRINT_RESULT = false; // 设置为true可以打印结果矩阵（对于大矩阵不推荐）

    std::cout << "=== 表达式模板实现 ===" << std::endl;
    complex_linear_algebra_computation<ExpressionTemplate::Matrix>(MATRIX_SIZE, PRINT_RESULT);

    std::cout << "\n=== Valarray 实现 ===" << std::endl;
    complex_linear_algebra_computation<ValarrayImpl::Matrix>(MATRIX_SIZE, PRINT_RESULT);

    // 小矩阵测试，验证正确性
    std::cout << "\n=== 小矩阵测试（验证正确性）===" << std::endl;
    const size_t SMALL_SIZE = 3;

    // 表达式模板小矩阵测试
    ExpressionTemplate::Matrix A_small(SMALL_SIZE, SMALL_SIZE);
    ExpressionTemplate::Matrix B_small(SMALL_SIZE, SMALL_SIZE);
    ExpressionTemplate::Matrix C_small(SMALL_SIZE, SMALL_SIZE);
    ExpressionTemplate::Matrix D_small(SMALL_SIZE, SMALL_SIZE);

    // 使用简单值填充
    for (size_t i = 0; i < SMALL_SIZE; ++i) {
        for (size_t j = 0; j < SMALL_SIZE; ++j) {
            A_small(i, j) = i + j + 1;
            B_small(i, j) = i * SMALL_SIZE + j + 1;
            C_small(i, j) = (i == j) ? 1.0 : 0.0;
            D_small(i, j) = (i == j) ? 2.0 : 0.0;
        }
    }

    std::cout << "Small matrix test (Expression Template):" << std::endl;
    ExpressionTemplate::Matrix result_small_et = (ExpressionTemplate::transpose(A_small) * B_small + C_small) * D_small.inverse();
    result_small_et.print();

    // Valarray小矩阵测试
    ValarrayImpl::Matrix A_small_va(SMALL_SIZE, SMALL_SIZE);
    ValarrayImpl::Matrix B_small_va(SMALL_SIZE, SMALL_SIZE);
    ValarrayImpl::Matrix C_small_va(SMALL_SIZE, SMALL_SIZE);
    ValarrayImpl::Matrix D_small_va(SMALL_SIZE, SMALL_SIZE);

    for (size_t i = 0; i < SMALL_SIZE; ++i) {
        for (size_t j = 0; j < SMALL_SIZE; ++j) {
            A_small_va(i, j) = i + j + 1;
            B_small_va(i, j) = i * SMALL_SIZE + j + 1;
            C_small_va(i, j) = (i == j) ? 1.0 : 0.0;
            D_small_va(i, j) = (i == j) ? 2.0 : 0.0;
        }
    }

    std::cout << "Small matrix test (Valarray):" << std::endl;
    auto result_small_va = (A_small_va.transpose() * B_small_va + C_small_va) * D_small_va.inverse();
    result_small_va.print();

    return 0;
}
```



## 7. 适用场景与总结

1. **数值计算密集型应用**：科学计算、工程模拟、金融建模
2. **简单向量运算**：当需要执行元素级数学运算时
3. **教学和原型开发**：语法简洁，易于理解和使用
4. **性能敏感场景**：编译器可以对 `valarray` 操作进行特殊优化

## 8. 总结

- `std::valarray` 提供了高性能的数值数组操作，支持元素级运算和广义下标
- 其设计允许编译器进行类似 `restrict` 关键字的优化
- 许多实现使用表达式模板技术来优化复杂表达式
- 虽然 `std::valarray` 功能强大，但在实际项目中，许多开发者更喜欢使用专门的数值库（如 Eigen、Armadillo），这些库使用更先进的表达式模板技术
- 表达式模板技术可以提供更好的性能和灵活性，但实现复杂度较高

对于大多数数值计算需求，`std::valarray` 是一个不错的选择，但对于极其复杂或性能要求极高的应用，可能需要考虑专门的数值计算库。

## 9. 线性代数计算三方库链接

https://github.com/RcppCore/RcppArmadillo

https://github.com/PX4/eigen

https://github.com/eigenteam/eigen-git-mirror

https://github.com/qixianyu-buaa/EigenChineseDocument

https://github.com/strasdat/Sophus

# 六、`<`random`>`随机数生成器和分布

## 1. 概述定义

| 概念                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 均匀随机位生成器要求                                         |                                                              |
| [ uniform_random_bit_generator](https://cppreference.cn/w/cpp/numeric/random/uniform_random_bit_generator)(C++20) | 指定一个类型是否符合均匀随机位生成器的条件  (概念)           |
| 类                                                           |                                                              |
| 随机数引擎                                                   |                                                              |
| [ linear_congruential_engine](https://cppreference.cn/w/cpp/numeric/random/linear_congruential_engine)(C++11) | 实现 [线性同余](https://en.wikipedia.org/wiki/Linear_congruential_generator) 算法  (类模板) |
| [ mersenne_twister_engine](https://cppreference.cn/w/cpp/numeric/random/mersenne_twister_engine)(C++11) | 实现 [梅森旋转](https://en.wikipedia.org/wiki/Mersenne_twister) 算法  (类模板) |
| [ subtract_with_carry_engine](https://cppreference.cn/w/cpp/numeric/random/subtract_with_carry_engine)(C++11) | 实现带进位的减法（[滞后斐波那契](https://en.wikipedia.org/wiki/Lagged_Fibonacci_generator)）算法  (类模板) |
| [ philox_engine](https://cppreference.cn/w/cpp/numeric/random/philox_engine)(C++26) | 基于计数器的可并行化生成器  (类模板)                         |
| 随机数引擎适配器                                             |                                                              |
| [ discard_block_engine](https://cppreference.cn/w/cpp/numeric/random/discard_block_engine)(C++11) | 丢弃随机数引擎的某些输出  (类模板)                           |
| [ independent_bits_engine](https://cppreference.cn/w/cpp/numeric/random/independent_bits_engine)(C++11) | 将随机数引擎的输出打包成指定位数的块  (类模板)               |
| [ shuffle_order_engine](https://cppreference.cn/w/cpp/numeric/random/shuffle_order_engine)(C++11) | 以不同的顺序传递随机数引擎的输出  (类模板)                   |

| 预定义生成器                   |                                                              |
| ------------------------------ | ------------------------------------------------------------ |
| `minstd_rand0` (C++11)         | [std::linear_congruential_engine](https://cppreference.cn/w/cpp/numeric/random/linear_congruential_engine)<[std::uint_fast32_t](https://cppreference.cn/w/cpp/types/integer), `                `16807, 0, 2147483647>  1969 年由 Lewis、Goodman 和 Miller 发现，1988 年被 Park 和 Miller 采纳为“最小标准” |
| `minstd_rand` (C++11)          | [std::linear_congruential_engine](https://cppreference.cn/w/cpp/numeric/random/linear_congruential_engine)<[std::uint_fast32_t](https://cppreference.cn/w/cpp/types/integer), `                `48271, 0, 2147483647> 更新的“最小标准”，由 Park、Miller 和 Stockmeyer 于 1993 年推荐 |
| `mt19937` (C++11)              | [std::mersenne_twister_engine](https://cppreference.cn/w/cpp/numeric/random/mersenne_twister_engine)<[std::uint_fast32_t](https://cppreference.cn/w/cpp/types/integer),  `               `32, 624, 397, 31,  `               `0x9908b0df, 11,  `               `0xffffffff, 7,  `               `0x9d2c5680, 15,  `               `0xefc60000, 18, 1812433253> Matsumoto 和 Nishimura 于 1998 年提出的 32 位梅森旋转算法 |
| `mt19937_64` (C++11)           | [std::mersenne_twister_engine](https://cppreference.cn/w/cpp/numeric/random/mersenne_twister_engine)<[std::uint_fast64_t](https://cppreference.cn/w/cpp/types/integer),  `               `64, 312, 156, 31,  `               `0xb5026f5aa96619e9, 29,  `               `0x5555555555555555, 17,  `               `0x71d67fffeda60000, 37,  `               `0xfff7eee000000000, 43,  `               `6364136223846793005> Matsumoto 和 Nishimura 于 2000 年提出的 64 位梅森旋转算法 |
| `ranlux24_base` (C++11)        | [std::subtract_with_carry_engine](https://cppreference.cn/w/cpp/numeric/random/subtract_with_carry_engine)<[std::uint_fast32_t](https://cppreference.cn/w/cpp/types/integer), 24, 10, 24> |
| `ranlux48_base` (C++11)        | [std::subtract_with_carry_engine](https://cppreference.cn/w/cpp/numeric/random/subtract_with_carry_engine)<[std::uint_fast64_t](https://cppreference.cn/w/cpp/types/integer), 48, 5, 12> |
| `ranlux24` (C++11)             | [std::discard_block_engine](https://cppreference.cn/w/cpp/numeric/random/discard_block_engine)<[std::ranlux24_base](https://cppreference.cn/w/cpp/numeric/random/subtract_with_carry_engine), 223, 23>  Martin Lüscher 和 Fred James 于 1994 年提出的 24 位 RANLUX 生成器 |
| `ranlux48` (C++11)             | [std::discard_block_engine](https://cppreference.cn/w/cpp/numeric/random/discard_block_engine)<[std::ranlux48_base](https://cppreference.cn/w/cpp/numeric/random/subtract_with_carry_engine), 389, 11>  Martin Lüscher 和 Fred James 于 1994 年提出的 48 位 RANLUX 生成器 |
| `knuth_b` (C++11)              | [std::shuffle_order_engine](https://cppreference.cn/w/cpp/numeric/random/shuffle_order_engine)<[std::minstd_rand0](https://cppreference.cn/w/cpp/numeric/random/linear_congruential_engine), 256> |
| `philox4x32` (C++26)           | [std::philox_engine](https://cppreference.cn/w/cpp/numeric/random/philox_engine)<[std::uint_fast32_t](https://cppreference.cn/w/cpp/types/integer), 32, 4, 10, `          `0xCD9E8D57, 0x9E3779B9, `          `0xD2511F53, 0xBB67AE85> |
| `philox4x64` (C++26)           | [std::philox_engine](https://cppreference.cn/w/cpp/numeric/random/philox_engine)<[std::uint_fast64_t](https://cppreference.cn/w/cpp/types/integer), 64, 4, 10, `          `0xCA5A826395121157, 0x9E3779B97F4A7C15, `          `0xD2E7470EE14C6C93, 0xBB67AE8584CAA73B> |
| `default_random_engine`(C++11) | 实现定义的 [*RandomNumberEngine*](https://cppreference.cn/w/cpp/named_req/RandomNumberEngine) 类型 |



| 非确定性随机数                                               |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ random_device](https://cppreference.cn/w/cpp/numeric/random/random_device)(C++11) | 使用硬件熵源的非确定性随机数生成器  (类)                     |
| 均匀分布                                                     |                                                              |
| [ uniform_int_distribution](https://cppreference.cn/w/cpp/numeric/random/uniform_int_distribution)(C++11) | 生成均匀分布在一定范围内的整数值  (类模板)                   |
| [ uniform_real_distribution](https://cppreference.cn/w/cpp/numeric/random/uniform_real_distribution)(C++11) | 生成均匀分布在一定范围内的实数值  (类模板)                   |
| 伯努利分布                                                   |                                                              |
| [ bernoulli_distribution](https://cppreference.cn/w/cpp/numeric/random/bernoulli_distribution)(C++11) | 在 [伯努利分布](https://en.wikipedia.org/wiki/Bernoulli_distribution) 上生成 bool 值  (类) |
| [ binomial_distribution](https://cppreference.cn/w/cpp/numeric/random/binomial_distribution)(C++11) | 在 [二项分布](https://en.wikipedia.org/wiki/Binomial_distribution) 上生成整数值  (类模板) |
| [ negative_binomial_distribution](https://cppreference.cn/w/cpp/numeric/random/negative_binomial_distribution)(C++11) | 在 [负二项分布](https://en.wikipedia.org/wiki/Negative_binomial_distribution) 上生成整数值  (类模板) |
| [ geometric_distribution](https://cppreference.cn/w/cpp/numeric/random/geometric_distribution)(C++11) | 在 [几何分布](https://en.wikipedia.org/wiki/Geometric_distribution) 上生成整数值  (类模板) |
| 泊松分布                                                     |                                                              |
| [ poisson_distribution](https://cppreference.cn/w/cpp/numeric/random/poisson_distribution)(C++11) | 在 [泊松分布](https://en.wikipedia.org/wiki/Poisson_distribution) 上生成整数值  (类模板) |
| [ exponential_distribution](https://cppreference.cn/w/cpp/numeric/random/exponential_distribution)(C++11) | 在 [指数分布](https://en.wikipedia.org/wiki/Exponential_distribution) 上生成实数值  (类模板) |
| [ gamma_distribution](https://cppreference.cn/w/cpp/numeric/random/gamma_distribution)(C++11) | 在 [伽马分布](https://en.wikipedia.org/wiki/Gamma_distribution) 上生成实数值  (类模板) |
| [ weibull_distribution](https://cppreference.cn/w/cpp/numeric/random/weibull_distribution)(C++11) | 在 [威布尔分布](https://en.wikipedia.org/wiki/Weibull_distribution) 上生成实数值  (类模板) |
| [ extreme_value_distribution](https://cppreference.cn/w/cpp/numeric/random/extreme_value_distribution)(C++11) | 在 [极值分布](https://en.wikipedia.org/wiki/Generalized_extreme_value_distribution) 上生成实数值  (类模板) |
| 正态分布                                                     |                                                              |
| [ normal_distribution](https://cppreference.cn/w/cpp/numeric/random/normal_distribution)(C++11) | 产生符合[标准正态（高斯）分布](https://en.wikipedia.org/wiki/Normal_distribution)的实数值  (类模板) |
| [ lognormal_distribution](https://cppreference.cn/w/cpp/numeric/random/lognormal_distribution)(C++11) | 产生符合[对数正态分布](https://en.wikipedia.org/wiki/Lognormal_distribution)的实数值  (类模板) |
| [ chi_squared_distribution](https://cppreference.cn/w/cpp/numeric/random/chi_squared_distribution)(C++11) | 产生符合[卡方分布](https://en.wikipedia.org/wiki/Chi-squared_distribution)的实数值  (类模板) |
| [ cauchy_distribution](https://cppreference.cn/w/cpp/numeric/random/cauchy_distribution)(C++11) | 产生符合[柯西分布](https://en.wikipedia.org/wiki/Cauchy_distribution)的实数值  (类模板) |
| [ fisher_f_distribution](https://cppreference.cn/w/cpp/numeric/random/fisher_f_distribution)(C++11) | 产生符合 [Fisher F 分布](https://en.wikipedia.org/wiki/F-distribution)的实数值  (类模板) |
| [ student_t_distribution](https://cppreference.cn/w/cpp/numeric/random/student_t_distribution)(C++11) | 产生符合[学生 t 分布](https://en.wikipedia.org/wiki/Student's_t-distribution)的实数值  (类模板) |
| 抽样分布                                                     |                                                              |
| [ discrete_distribution](https://cppreference.cn/w/cpp/numeric/random/discrete_distribution)(C++11) | 产生符合离散分布的整数值  (类模板)                           |
| [ piecewise_constant_distribution](https://cppreference.cn/w/cpp/numeric/random/piecewise_constant_distribution)(C++11) | 产生分布在常数子区间上的实数值  (类模板)                     |
| [ piecewise_linear_distribution](https://cppreference.cn/w/cpp/numeric/random/piecewise_linear_distribution)(C++11) | 产生分布在已定义子区间上的实数值  (类模板)                   |
| 实用工具                                                     |                                                              |
| [ seed_seq](https://cppreference.cn/w/cpp/numeric/random/seed_seq)(C++11) | 通用消除偏差的扰乱种子序列生成器  (类)                       |
| 函数                                                         |                                                              |
| [ generate_canonical](https://cppreference.cn/w/cpp/numeric/random/generate_canonical)(C++11) | 均匀分布给定精度的实数值于 `[`0`, `1`)` 区间  (函数模板)     |
| [ ranges::generate_random](https://cppreference.cn/w/cpp/algorithm/ranges/generate_random)(C++26) | 使用来自均匀随机位生成器的随机数填充范围 (算法函数对象)      |

## 

`<random>` 是 C++11 引入的伪随机数生成库，提供了多种随机数生成器和分布类型。下面详细介绍每个模块的使用方法。

## 2. 随机数引擎

### 1. linear_congruential_engine
线性同余生成器，使用公式 $x_{i+1} = (a \times x_i + c) \mod m$ 生成随机数。

```cpp
#include <iostream>
#include <random>

int main() {
    // 定义线性同余引擎：使用 uint32_t，参数 a=48271, c=0, m=2147483647
    std::linear_congruential_engine<std::uint32_t, 48271, 0, 2147483647> engine;
    
    // 1. 生成随机数
    std::cout << "Random number: " << engine() << std::endl;
    
    // 2. 获取最小值
    std::cout << "Min value: " << engine.min() << std::endl;
    
    // 3. 获取最大值
    std::cout << "Max value: " << engine.max() << std::endl;
    
    // 4. 设置种子
    engine.seed(123);
    std::cout << "After seed: " << engine() << std::endl;
    
    // 5. 丢弃若干随机数
    engine.discard(5);
    std::cout << "After discard: " << engine() << std::endl;
    
    return 0;
}
```

### 2. mersenne_twister_engine
梅森旋转算法生成器，产生高质量随机数。

```cpp
#include <iostream>
#include <random>

int main() {
    // 使用32位梅森旋转引擎，参数为mt19937的标准参数
    std::mersenne_twister_engine<std::uint32_t, 32, 624, 397, 31, 
                                 0x9908b0df, 11, 
                                 0xffffffff, 7, 
                                 0x9d2c5680, 15, 
                                 0xefc60000, 18, 1812433253> engine;
    
    // 1. 生成随机数
    std::cout << "Random number: " << engine() << std::endl;
    
    // 2. 获取最小/最大值
    std::cout << "Min: " << engine.min() << ", Max: " << engine.max() << std::endl;
    
    // 3. 设置种子
    engine.seed(456);
    std::cout << "After seed: " << engine() << std::endl;
    
    // 4. 丢弃若干随机数
    engine.discard(10);
    std::cout << "After discard: " << engine() << std::endl;
    
    return 0;
}
```

### 3. subtract_with_carry_engine
带进位减法生成器（滞后斐波那契算法）。

```cpp
#include <iostream>
#include <random>

int main() {
    // 定义带进位减法引擎：使用uint32_t，参数为ranlux24_base的标准参数
    std::subtract_with_carry_engine<std::uint32_t, 24, 10, 24> engine;
    
    // 1. 生成随机数
    std::cout << "Random number: " << engine() << std::endl;
    
    // 2. 获取最小/最大值
    std::cout << "Min: " << engine.min() << ", Max: " << engine.max() << std::endl;
    
    // 3. 设置种子
    engine.seed(789);
    std::cout << "After seed: " << engine() << std::endl;
    
    // 4. 丢弃若干随机数
    engine.discard(5);
    std::cout << "After discard: " << engine() << std::endl;
    
    return 0;
}
```

## 3. 随机数引擎适配器

### 1. discard_block_engine
丢弃块引擎，丢弃生成器的某些输出。

```cpp
#include <iostream>
#include <random>

int main() {
    // 基于ranlux24_base，每生成223个数字丢弃23个
    std::discard_block_engine<std::ranlux24_base, 223, 23> engine;
    
    // 1. 生成随机数
    std::cout << "Random number: " << engine() << std::endl;
    
    // 2. 获取基础引擎
    auto base_engine = engine.base();
    std::cout << "Base engine: " << base_engine() << std::endl;
    
    // 3. 获取最小/最大值
    std::cout << "Min: " << engine.min() << ", Max: " << engine.max() << std::endl;
    
    return 0;
}
```

### 2. independent_bits_engine
独立位引擎，将输出打包成指定位数的块。

```cpp
#include <iostream>
#include <random>

int main() {
    // 基于minstd_rand0，生成64位随机数
    std::independent_bits_engine<std::minstd_rand0, 64, std::uint64_t> engine;
    
    // 1. 生成随机数
    std::cout << "Random number: " << engine() << std::endl;
    
    // 2. 获取基础引擎
    auto base_engine = engine.base();
    std::cout << "Base engine: " << base_engine() << std::endl;
    
    // 3. 获取最小/最大值
    std::cout << "Min: " << engine.min() << ", Max: " << engine.max() << std::endl;
    
    return 0;
}
```

### 3. shuffle_order_engine
洗牌顺序引擎，以不同顺序传递输出。

```cpp
#include <iostream>
#include <random>

int main() {
    // 基于minstd_rand0，使用256大小的内部表
    std::shuffle_order_engine<std::minstd_rand0, 256> engine;
    
    // 1. 生成随机数
    std::cout << "Random number: " << engine() << std::endl;
    
    // 2. 获取基础引擎
    auto base_engine = engine.base();
    std::cout << "Base engine: " << base_engine() << std::endl;
    
    // 3. 获取最小/最大值
    std::cout << "Min: " << engine.min() << ", Max: " << engine.max() << std::endl;
    
    return 0;
}
```

## 4. 预定义生成器

### 各生成器详细说明

### （1）minstd_rand0
```cpp
std::linear_congruential_engine<std::uint_fast32_t, 16807, 0, 2147483647>
```
- **算法**：线性同余生成器
- **特点**：最简单的随机数生成器，速度快但随机性质量较低
- **周期**：2³¹-2 (约21亿)
- **适用领域**：简单应用、教学示例、对随机性要求不高的场景
- **缺点**：随机性质量一般，有明显的周期性模式

### （2）minstd_rand
```cpp
std::linear_congruential_engine<std::uint_fast32_t, 48271, 0, 2147483647>
```
- **算法**：改进的线性同余生成器
- **特点**：minstd_rand0的改进版本，具有更好的统计特性
- **周期**：2³¹-2 (约21亿)
- **适用领域**：简单游戏、基础模拟、对速度要求高于质量的应用
- **优点**：比minstd_rand0更好的随机性

### （3）mt19937 (32位梅森旋转)
```cpp
std::mersenne_twister_engine<std::uint_fast32_t, 32, 624, 397, 31,
                             0x9908b0df, 11, 0xffffffff, 7,
                             0x9d2c5680, 15, 0xefc60000, 18, 1812433253>
```
- **算法**：梅森旋转算法
- **特点**：高质量随机数生成器，具有良好的统计特性
- **周期**：2¹⁹⁹³⁷-1 (极其巨大，约10⁶⁰⁰⁰)
- **适用领域**：科学计算、复杂模拟、机器学习、游戏开发
- **优点**：高质量随机数，长周期
- **缺点**：内存占用较大(约2.5KB)

### （4）mt19937_64 (64位梅森旋转)
```cpp
std::mersenne_twister_engine<std::uint_fast64_t, 64, 312, 156, 31,
                             0xb5026f5aa96619e9, 29, 0x5555555555555555, 17,
                             0x71d67fffeda60000, 37, 0xfff7eee000000000, 43,
                             6364136223846793005>
```
- **算法**：64位版本的梅森旋转算法
- **特点**：产生64位随机数，质量更高
- **周期**：2¹⁹⁹³⁷-1 (极其巨大)
- **适用领域**：需要高质量64位随机数的科学计算、密码学相关应用
- **优点**：更高质量的随机数，适合64位系统

### （5）ranlux24_base 和 ranlux48_base
```cpp
// 24位版本
std::subtract_with_carry_engine<std::uint_fast32_t, 24, 10, 24>
// 48位版本
std::subtract_with_carry_engine<std::uint_fast64_t, 48, 5, 12>
```
- **算法**：带进位减法算法(滞后斐波那契)
- **特点**：中等质量的随机数生成器
- **适用领域**：一般应用，作为更复杂生成器的基础

### （6）ranlux24 和 ranlux48
```cpp
// 24位版本
std::discard_block_engine<std::ranlux24_base, 223, 23>
// 48位版本
std::discard_block_engine<std::ranlux48_base, 389, 11>
```
- **算法**：基于带进位减法算法的丢弃块引擎
- **特点**：高质量随机数，但速度较慢
- **适用领域**：对随机性质量要求极高的科学模拟、蒙特卡洛方法
- **优点**：非常高质量的随机数
- **缺点**：速度较慢

### （7）knuth_b
```cpp
std::shuffle_order_engine<std::minstd_rand0, 256>
```
- **算法**：基于minstd_rand0的洗牌顺序引擎
- **特点**：通过洗牌改善线性同余生成器的输出质量
- **适用领域**：需要比minstd好但不需要mt19937高质量的应用
- **优点**：比基础线性同余生成器更好的统计特性

### （8）philox4x32 和 philox4x64 (C++26)
```cpp
// 4x32位版本
std::philox_engine<std::uint_fast32_t, 32, 4, 10,
                   0xCD9E8D57, 0x9E3779B9, 0xD2511F53, 0xBB67AE85>
// 4x64位版本
std::philox_engine<std::uint_fast64_t, 64, 4, 10,
                   0xCA5A826395121157, 0x9E3779B97F4A7C15,
                   0xD2E7470EE14C6C93, 0xBB67AE8584CAA73B>
```
- **算法**：基于计数器的可并行化生成器
- **特点**：高质量、可并行化的随机数生成器
- **适用领域**：并行计算、GPU编程、需要可预测随机数流的应用
- **优点**：高质量、可并行、可预测的随机数流

### （9）default_random_engine
- **特点**：实现定义的随机数引擎
- **适用领域**：简单应用、快速原型开发
- **注意**：不同编译器可能有不同实现，不利于可移植代码

### 常用生成器推荐

#### a. 最常用：mt19937
```cpp
#include <random>
#include <iostream>

int main() {
    // 使用32位梅森旋转算法
    std::mt19937 gen(std::random_device{}());
    std::uniform_int_distribution<int> dist(1, 100);
    
    for (int i = 0; i < 10; ++i) {
        std::cout << dist(gen) << " ";
    }
    
    return 0;
}
```

#### b. 高质量科学计算：ranlux48
```cpp
#include <random>
#include <iostream>

int main() {
    // 使用高质量ranlux48生成器
    std::ranlux48 gen(std::random_device{}());
    std::uniform_real_distribution<double> dist(0.0, 1.0);
    
    for (int i = 0; i < 10; ++i) {
        std::cout << dist(gen) << " ";
    }
    
    return 0;
}
```

#### c. 简单应用：minstd_rand
```cpp
#include <random>
#include <iostream>

int main() {
    // 使用minstd_rand生成器
    std::minstd_rand gen(std::random_device{}());
    std::uniform_int_distribution<int> dist(1, 6);
    
    // 模拟掷骰子
    for (int i = 0; i < 10; ++i) {
        std::cout << "Dice roll: " << dist(gen) << std::endl;
    }
    
    return 0;
}
```

### 选择指南

1. **一般用途**：`mt19937` - 良好的平衡点，适用于大多数应用
2. **高质量科学计算**：`ranlux48` 或 `mt19937_64` - 极高的随机性质量
3. **简单应用**：`minstd_rand` - 速度快，资源占用少
4. **并行计算**：`philox`系列(C++26) - 可并行化，可预测的随机数流
5. **避免使用**：`default_random_engine` - 缺乏可移植性

### 性能比较

| 生成器       | 速度 | 内存占用 | 随机性质量 | 周期长度 |
| ------------ | ---- | -------- | ---------- | -------- |
| minstd_rand0 | 快   | 小       | 低         | 短       |
| minstd_rand  | 快   | 小       | 中低       | 短       |
| mt19937      | 中   | 大       | 高         | 极长     |
| mt19937_64   | 中   | 大       | 很高       | 极长     |
| ranlux24/48  | 慢   | 中       | 极高       | 长       |
| philox       | 中快 | 中       | 高         | 长       |

### 示例

根据应用需求权衡这些因素，选择最适合的随机数生成器。

```cpp
#include <iostream>
#include <random>

int main() {
    // 1. minstd_rand0
    std::minstd_rand0 engine1;
    std::cout << "minstd_rand0: " << engine1() << std::endl;
    
    // 2. minstd_rand
    std::minstd_rand engine2;
    std::cout << "minstd_rand: " << engine2() << std::endl;
    
    // 3. mt19937 (32位梅森旋转)
    std::mt19937 engine3;
    std::cout << "mt19937: " << engine3() << std::endl;
    
    // 4. mt19937_64 (64位梅森旋转)
    std::mt19937_64 engine4;
    std::cout << "mt19937_64: " << engine4() << std::endl;
    
    // 5. ranlux24_base
    std::ranlux24_base engine5;
    std::cout << "ranlux24_base: " << engine5() << std::endl;
    
    // 6. ranlux48_base
    std::ranlux48_base engine6;
    std::cout << "ranlux48_base: " << engine6() << std::endl;
    
    // 7. ranlux24
    std::ranlux24 engine7;
    std::cout << "ranlux24: " << engine7() << std::endl;
    
    // 8. ranlux48
    std::ranlux48 engine8;
    std::cout << "ranlux48: " << engine8() << std::endl;
    
    // 9. knuth_b
    std::knuth_b engine9;
    std::cout << "knuth_b: " << engine9() << std::endl;
    
    // 10. default_random_engine
    std::default_random_engine engine10;
    std::cout << "default_random_engine: " << engine10() << std::endl;
    
    return 0;
}
```

## 5. 非确定性随机数

### random_device
使用硬件熵源的非确定性随机数生成器。

```cpp
#include <iostream>
#include <random>

int main() {
    // 1. 创建random_device
    std::random_device rd;
    
    // 2. 生成随机数
    std::cout << "Random number: " << rd() << std::endl;
    
    // 3. 获取熵估计
    std::cout << "Entropy: " << rd.entropy() << std::endl;
    
    // 4. 获取最小/最大值
    std::cout << "Min: " << rd.min() << ", Max: " << rd.max() << std::endl;
    
    return 0;
}
```

## 6. 均匀分布

### 1. uniform_int_distribution
均匀整数分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布 [1, 6]
    std::uniform_int_distribution<int> dist(1, 6);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Roll: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Min: " << dist.min() << ", Max: " << dist.max() << std::endl;
    
    // 4. 重置分布状态
    dist.reset();
    
    return 0;
}
```

### 2. uniform_real_distribution
均匀实数分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布 [0.0, 1.0)
    std::uniform_real_distribution<double> dist(0.0, 1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Random: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Min: " << dist.min() << ", Max: " << dist.max() << std::endl;
    
    return 0;
}
```

## 7. 伯努利分布

### 1. bernoulli_distribution
伯努利分布（生成bool值）。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（成功概率0.7）
    std::bernoulli_distribution dist(0.7);
    
    // 2. 生成随机bool值
    int success = 0;
    for (int i = 0; i < 100; ++i) {
        if (dist(engine)) success++;
    }
    std::cout << "Success rate: " << success / 100.0 << std::endl;
    
    // 3. 获取参数
    std::cout << "Probability: " << dist.p() << std::endl;
    
    return 0;
}
```

### 2. binomial_distribution
二项分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（试验次数10，成功概率0.5）
    std::binomial_distribution<int> dist(10, 0.5);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Successes: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Trials: " << dist.t() << ", Probability: " << dist.p() << std::endl;
    
    return 0;
}
```

### 3. negative_binomial_distribution
负二项分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（成功次数5，成功概率0.5）
    std::negative_binomial_distribution<int> dist(5, 0.5);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Failures: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Success count: " << dist.k() << ", Probability: " << dist.p() << std::endl;
    
    return 0;
}
```

### 4. geometric_distribution
几何分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（成功概率0.5）
    std::geometric_distribution<int> dist(0.5);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Trials: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Probability: " << dist.p() << std::endl;
    
    return 0;
}
```

## 8. 泊松分布

### 1. poisson_distribution
泊松分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（均值4.0）
    std::poisson_distribution<int> dist(4.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Count: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Mean: " << dist.mean() << std::endl;
    
    return 0;
}
```

### 2. exponential_distribution
指数分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（lambda=1.0）
    std::exponential_distribution<double> dist(1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Lambda: " << dist.lambda() << std::endl;
    
    return 0;
}
```

### 3. gamma_distribution
伽马分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（形状参数=2.0，尺度参数=1.0）
    std::gamma_distribution<double> dist(2.0, 1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Alpha: " << dist.alpha() << ", Beta: " << dist.beta() << std::endl;
    
    return 0;
}
```

### 4. weibull_distribution
威布尔分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（形状参数=1.0，尺度参数=1.0）
    std::weibull_distribution<double> dist(1.0, 1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "A: " << dist.a() << ", B: " << dist.b() << std::endl;
    
    return 0;
}
```

### 5. extreme_value_distribution
极值分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（位置参数=0.0，尺度参数=1.0）
    std::extreme_value_distribution<double> dist(0.0, 1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "A: " << dist.a() << ", B: " << dist.b() << std::endl;
    
    return 0;
}
```

## 9. 正态分布

### 1. normal_distribution
正态分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（均值=0.0，标准差=1.0）
    std::normal_distribution<double> dist(0.0, 1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Mean: " << dist.mean() << ", Stddev: " << dist.stddev() << std::endl;
    
    return 0;
}
```

### 2. lognormal_distribution
对数正态分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（均值=0.0，标准差=1.0）
    std::lognormal_distribution<double> dist(0.0, 1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "M: " << dist.m() << ", S: " << dist.s() << std::endl;
    
    return 0;
}
```

### 3. chi_squared_distribution
卡方分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（自由度=1.0）
    std::chi_squared_distribution<double> dist(1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Degrees of freedom: " << dist.n() << std::endl;
    
    return 0;
}
```

### 4. cauchy_distribution
柯西分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（位置参数=0.0，尺度参数=1.0）
    std::cauchy_distribution<double> dist(0.0, 1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "A: " << dist.a() << ", B: " << dist.b() << std::endl;
    
    return 0;
}
```

### 5. fisher_f_distribution
Fisher F分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（自由度m=1.0，n=1.0）
    std::fisher_f_distribution<double> dist(1.0, 1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "M: " << dist.m() << ", N: " << dist.n() << std::endl;
    
    return 0;
}
```

### 6. student_t_distribution
学生t分布。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（自由度=1.0）
    std::student_t_distribution<double> dist(1.0);
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    // 3. 获取参数
    std::cout << "Degrees of freedom: " << dist.n() << std::endl;
    
    return 0;
}
```

## 10. 抽样分布

### 1. discrete_distribution
离散分布。

```cpp
#include <iostream>
#include <random>
#include <vector>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（概率权重{1, 2, 3, 4}）
    std::discrete_distribution<int> dist({1, 2, 3, 4});
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Category: " << dist(engine) << std::endl;
    }
    
    // 3. 获取概率
    const auto& probabilities = dist.probabilities();
    std::cout << "Probabilities: ";
    for (double p : probabilities) {
        std::cout << p << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 2. piecewise_constant_distribution
分段常数分布。

```cpp
#include <iostream>
#include <random>
#include <vector>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（区间[0,1), [1,2), [2,3] 和权重{1, 2, 3}）
    std::vector<double> intervals = {0.0, 1.0, 2.0, 3.0};
    std::vector<double> weights = {1.0, 2.0, 3.0};
    std::piecewise_constant_distribution<double> dist(
        intervals.begin(), intervals.end(), weights.begin());
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    return 0;
}
```

### 3. piecewise_linear_distribution
分段线性分布。

```cpp
#include <iostream>
#include <random>
#include <vector>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 创建分布（区间[0,1), [1,2), [2,3] 和密度{1, 2, 3, 0}）
    std::vector<double> intervals = {0.0, 1.0, 2.0, 3.0};
    std::vector<double> densities = {1.0, 2.0, 3.0, 0.0};
    std::piecewise_linear_distribution<double> dist(
        intervals.begin(), intervals.end(), densities.begin());
    
    // 2. 生成随机数
    for (int i = 0; i < 10; ++i) {
        std::cout << "Value: " << dist(engine) << std::endl;
    }
    
    return 0;
}
```

## 11. 实用工具

### seed_seq
种子序列生成器，用于消除偏差。

```cpp
#include <iostream>
#include <random>
#include <vector>

int main() {
    // 1. 创建种子序列
    std::seed_seq seq{1, 2, 3, 4, 5};
    
    // 2. 生成随机数引擎
    std::vector<std::uint32_t> seeds(10);
    seq.generate(seeds.begin(), seeds.end());
    
    // 3. 输出生成的种子
    std::cout << "Generated seeds: ";
    for (auto seed : seeds) {
        std::cout << seed << " ";
    }
    std::cout << std::endl;
    
    // 4. 获取种子序列大小
    std::cout << "Size: " << seq.size() << std::endl;
    
    // 5. 将种子序列写入迭代器
    std::vector<std::uint32_t> params;
    seq.param(std::back_inserter(params));
    
    std::cout << "Parameters: ";
    for (auto p : params) {
        std::cout << p << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

## 12. 函数

### generate_canonical
生成指定精度的[0,1)区间内的均匀分布实数。

```cpp
#include <iostream>
#include <random>

int main() {
    std::random_device rd;
    std::mt19937 engine(rd());
    
    // 1. 生成单精度浮点数
    float f = std::generate_canonical<float, 10>(engine);
    std::cout << "Float value: " << f << std::endl;
    
    // 2. 生成双精度浮点数
    double d = std::generate_canonical<double, 10>(engine);
    std::cout << "Double value: " << d << std::endl;
    
    // 3. 生成长双精度浮点数
    long double ld = std::generate_canonical<long double, 10>(engine);
    std::cout << "Long double value: " << ld << std::endl;
    
    return 0;
}
```



# 、`<`linalg`>`（C++26）

# 、`<`simd`>`（C++26）
