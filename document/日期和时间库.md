# C++ Chrono 库指南 (C++11 至 C++20)

## 概述

C++ `<chrono>` 库提供了强大的时间处理功能，包括持续时间、时间点、时钟、日历和时区操作。以下是按功能分类的详细说明和示例。

```cpp
#include <compare>
 
namespace std {
  namespace chrono {
    // class template duration
    template<class Rep, class Period = ratio<1>> class duration;
 
    // class template time_point
    template<class Clock, class Duration = typename Clock::duration> class time_point;
  }
 
  // common_type specializations
  template<class Rep1, class Period1, class Rep2, class Period2>
    struct common_type<chrono::duration<Rep1, Period1>,
                       chrono::duration<Rep2, Period2>>;
 
  template<class Clock, class Duration1, class Duration2>
    struct common_type<chrono::time_point<Clock, Duration1>,
                       chrono::time_point<Clock, Duration2>>;
 
  namespace chrono {
    // customization traits
    template<class Rep> struct treat_as_floating_point;
    template<class Rep>
      inline constexpr bool treat_as_floating_point_v = treat_as_floating_point<Rep>::value;
 
    template<class Rep> struct duration_values;
 
    template<class T> struct is_clock;
    template<class T> inline constexpr bool is_clock_v = is_clock<T>::value;
 
    // duration arithmetic
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
        operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
        operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period, class Rep2>
      constexpr duration<common_type_t<Rep1, Rep2>, Period>
        operator*(const duration<Rep1, Period>& d, const Rep2& s);
    template<class Rep1, class Rep2, class Period>
      constexpr duration<common_type_t<Rep1, Rep2>, Period>
        operator*(const Rep1& s, const duration<Rep2, Period>& d);
    template<class Rep1, class Period, class Rep2>
      constexpr duration<common_type_t<Rep1, Rep2>, Period>
        operator/(const duration<Rep1, Period>& d, const Rep2& s);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr common_type_t<Rep1, Rep2>
        operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period, class Rep2>
      constexpr duration<common_type_t<Rep1, Rep2>, Period>
        operator%(const duration<Rep1, Period>& d, const Rep2& s);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr common_type_t<duration<Rep1, Period1>, duration<Rep2, Period2>>
        operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
 
    // duration comparisons
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator==(const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator< (const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator> (const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator<=(const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      constexpr bool operator>=(const duration<Rep1, Period1>& lhs,
                                const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Rep2, class Period2>
      requires /* see description */
      constexpr auto operator<=>(const duration<Rep1, Period1>& lhs,
                                 const duration<Rep2, Period2>& rhs);
 
    // conversions
    template<class ToDuration, class Rep, class Period>
      constexpr ToDuration duration_cast(const duration<Rep, Period>& d);
    template<class ToDuration, class Rep, class Period>
      constexpr ToDuration floor(const duration<Rep, Period>& d);
    template<class ToDuration, class Rep, class Period>
      constexpr ToDuration ceil(const duration<Rep, Period>& d);
    template<class ToDuration, class Rep, class Period>
      constexpr ToDuration round(const duration<Rep, Period>& d);
 
    // duration I/O
    template<class CharT, class Traits, class Rep, class Period>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os,
                   const duration<Rep, Period>& d);
    template<class CharT, class Traits, class Rep, class Period, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    duration<Rep, Period>& d,
                    basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // convenience typedefs
    using nanoseconds  = duration</* signed integer type of at least 64 bits */, nano>;
    using microseconds = duration</* signed integer type of at least 55 bits */, micro>;
    using milliseconds = duration</* signed integer type of at least 45 bits */, milli>;
    using seconds      = duration</* signed integer type of at least 35 bits */>;
    using minutes      = duration</* signed integer type of at least 29 bits */,
                                  ratio<  60>>;
    using hours        = duration</* signed integer type of at least 23 bits */,
                                  ratio<3600>>;
    using days         = duration</* signed integer type of at least 25 bits */,
                                  ratio_multiply<ratio<24>, hours::period>>;
    using weeks        = duration</* signed integer type of at least 22 bits */,
                                  ratio_multiply<ratio<7>, days::period>>;
    using years        = duration</* signed integer type of at least 17 bits */,
                                  ratio_multiply<ratio<146097, 400>, days::period>>;
    using months       = duration</* signed integer type of at least 20 bits */,
                                  ratio_divide<years::period, ratio<12>>>;
 
    // time_point arithmetic
    template<class Clock, class Duration1, class Rep2, class Period2>
      constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
        operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Rep1, class Period1, class Clock, class Duration2>
      constexpr time_point<Clock, common_type_t<duration<Rep1, Period1>, Duration2>>
        operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Rep2, class Period2>
      constexpr time_point<Clock, common_type_t<Duration1, duration<Rep2, Period2>>>
        operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
    template<class Clock, class Duration1, class Duration2>
      constexpr common_type_t<Duration1, Duration2>
        operator-(const time_point<Clock, Duration1>& lhs,
                  const time_point<Clock, Duration2>& rhs);
 
    // time_point comparisons
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator==(const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator< (const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator> (const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator<=(const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, class Duration2>
       constexpr bool operator>=(const time_point<Clock, Duration1>& lhs,
                                 const time_point<Clock, Duration2>& rhs);
    template<class Clock, class Duration1, three_way_comparable_with<Duration1> Duration2>
       constexpr auto operator<=>(const time_point<Clock, Duration1>& lhs,
                                  const time_point<Clock, Duration2>& rhs);
 
    // conversions
    template<class ToDuration, class Clock, class Duration>
      constexpr time_point<Clock, ToDuration>
        time_point_cast(const time_point<Clock, Duration>& t);
    template<class ToDuration, class Clock, class Duration>
      constexpr time_point<Clock, ToDuration> floor(const time_point<Clock, Duration>& tp);
    template<class ToDuration, class Clock, class Duration>
      constexpr time_point<Clock, ToDuration> ceil(const time_point<Clock, Duration>& tp);
    template<class ToDuration, class Clock, class Duration>
      constexpr time_point<Clock, ToDuration> round(const time_point<Clock, Duration>& tp);
 
    // specialized algorithms
    template<class Rep, class Period>
      constexpr duration<Rep, Period> abs(duration<Rep, Period> d);
 
    // class system_clock
    class system_clock;
 
    template<class Duration>
      using sys_time  = time_point<system_clock, Duration>;
    using sys_seconds = sys_time<seconds>;
    using sys_days    = sys_time<days>;
 
    template<class CharT, class Traits, class Duration>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const sys_time<Duration>& tp);
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const sys_days& dp);
 
    template<class CharT, class Traits, class Duration, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    sys_time<Duration>& tp,
                    basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class utc_clock
    class utc_clock;
 
    template<class Duration>
      using utc_time  = time_point<utc_clock, Duration>;
    using utc_seconds = utc_time<seconds>;
 
    template<class CharT, class Traits, class Duration>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const utc_time<Duration>& t);
    template<class CharT, class Traits, class Duration, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    utc_time<Duration>& tp,
                    basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    struct leap_second_info;
 
    template<class Duration>
      leap_second_info get_leap_second_info(const utc_time<Duration>& ut);
 
    // class tai_clock
    class tai_clock;
 
    template<class Duration>
      using tai_time  = time_point<tai_clock, Duration>;
    using tai_seconds = tai_time<seconds>;
 
    template<class CharT, class Traits, class Duration>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const tai_time<Duration>& t);
    template<class CharT, class Traits, class Duration, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    tai_time<Duration>& tp,
                    basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class gps_clock
    class gps_clock;
 
    template<class Duration>
      using gps_time  = time_point<gps_clock, Duration>;
    using gps_seconds = gps_time<seconds>;
 
    template<class CharT, class Traits, class Duration>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const gps_time<Duration>& t);
    template<class CharT, class Traits, class Duration, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    gps_time<Duration>& tp,
                    basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // type file_clock
    using file_clock = /* see description */;
 
    template<class Duration>
      using file_time = time_point<file_clock, Duration>;
 
    template<class CharT, class Traits, class Duration>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const file_time<Duration>& tp);
    template<class CharT, class Traits, class Duration, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    file_time<Duration>& tp,
                    basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class steady_clock
    class steady_clock;
 
    // class high_resolution_clock
    class high_resolution_clock;
 
    // local time
    struct local_t {};
    template<class Duration>
      using local_time  = time_point<local_t, Duration>;
    using local_seconds = local_time<seconds>;
    using local_days    = local_time<days>;
 
    template<class CharT, class Traits, class Duration>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const local_time<Duration>& tp);
    template<class CharT, class Traits, class Duration, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    local_time<Duration>& tp,
                    basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // time_point conversions
    template<class DestClock, class SourceClock>
      struct clock_time_conversion;
 
    template<class DestClock, class SourceClock, class Duration>
      auto clock_cast(const time_point<SourceClock, Duration>& t);
 
    // class last_spec
    struct last_spec;
 
    // class day
    class day;
 
    constexpr bool operator==(const day& x, const day& y) noexcept;
    constexpr strong_ordering operator<=>(const day& x, const day& y) noexcept;
 
    constexpr day  operator+(const day&  x, const days& y) noexcept;
    constexpr day  operator+(const days& x, const day&  y) noexcept;
    constexpr day  operator-(const day&  x, const days& y) noexcept;
    constexpr days operator-(const day&  x, const day&  y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const day& d);
    template<class CharT, class Traits, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    day& d, basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class month
    class month;
 
    constexpr bool operator==(const month& x, const month& y) noexcept;
    constexpr strong_ordering operator<=>(const month& x, const month& y) noexcept;
 
    constexpr month  operator+(const month&  x, const months& y) noexcept;
    constexpr month  operator+(const months& x,  const month& y) noexcept;
    constexpr month  operator-(const month&  x, const months& y) noexcept;
    constexpr months operator-(const month&  x,  const month& y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const month& m);
    template<class CharT, class Traits, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    month& m, basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class year
    class year;
 
    constexpr bool operator==(const year& x, const year& y) noexcept;
    constexpr strong_ordering operator<=>(const year& x, const year& y) noexcept;
 
    constexpr year  operator+(const year&  x, const years& y) noexcept;
    constexpr year  operator+(const years& x, const year&  y) noexcept;
    constexpr year  operator-(const year&  x, const years& y) noexcept;
    constexpr years operator-(const year&  x, const year&  y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const year& y);
 
    template<class CharT, class Traits, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    year& y, basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class weekday
    class weekday;
 
    constexpr bool operator==(const weekday& x, const weekday& y) noexcept;
 
    constexpr weekday operator+(const weekday& x, const days&    y) noexcept;
    constexpr weekday operator+(const days&    x, const weekday& y) noexcept;
    constexpr weekday operator-(const weekday& x, const days&    y) noexcept;
    constexpr days    operator-(const weekday& x, const weekday& y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const weekday& wd);
 
    template<class CharT, class Traits, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    weekday& wd, basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class weekday_indexed
    class weekday_indexed;
 
    constexpr bool operator==(const weekday_indexed& x, const weekday_indexed& y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const weekday_indexed& wdi);
 
    // class weekday_last
    class weekday_last;
 
    constexpr bool operator==(const weekday_last& x, const weekday_last& y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const weekday_last& wdl);
 
    // class month_day
    class month_day;
 
    constexpr bool operator==(const month_day& x, const month_day& y) noexcept;
    constexpr strong_ordering operator<=>(const month_day& x, const month_day& y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const month_day& md);
 
    template<class CharT, class Traits, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    month_day& md, basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class month_day_last
    class month_day_last;
 
    constexpr bool operator==(const month_day_last& x, const month_day_last& y) noexcept;
    constexpr strong_ordering operator<=>(const month_day_last& x,
                                          const month_day_last& y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const month_day_last& mdl);
 
    // class month_weekday
    class month_weekday;
 
    constexpr bool operator==(const month_weekday& x, const month_weekday& y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const month_weekday& mwd);
 
    // class month_weekday_last
    class month_weekday_last;
 
    constexpr bool operator==(const month_weekday_last& x, const month_weekday_last& y) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const month_weekday_last& mwdl);
 
    // class year_month
    class year_month;
 
    constexpr bool operator==(const year_month& x, const year_month& y) noexcept;
    constexpr strong_ordering operator<=>(const year_month& x, const year_month& y) noexcept;
 
    constexpr year_month operator+(const year_month& ym, const months& dm) noexcept;
    constexpr year_month operator+(const months& dm, const year_month& ym) noexcept;
    constexpr year_month operator-(const year_month& ym, const months& dm) noexcept;
    constexpr months operator-(const year_month& x, const year_month& y) noexcept;
    constexpr year_month operator+(const year_month& ym, const years& dy) noexcept;
    constexpr year_month operator+(const years& dy, const year_month& ym) noexcept;
    constexpr year_month operator-(const year_month& ym, const years& dy) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const year_month& ym);
 
    template<class CharT, class Traits, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    year_month& ym, basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class year_month_day
    class year_month_day;
 
    constexpr bool operator==(const year_month_day& x, const year_month_day& y) noexcept;
    constexpr strong_ordering operator<=>(const year_month_day& x,
                                          const year_month_day& y) noexcept;
 
    constexpr year_month_day operator+(const year_month_day& ymd, const months& dm) noexcept;
    constexpr year_month_day operator+(const months& dm, const year_month_day& ymd) noexcept;
    constexpr year_month_day operator+(const year_month_day& ymd, const years& dy) noexcept;
    constexpr year_month_day operator+(const years& dy, const year_month_day& ymd) noexcept;
    constexpr year_month_day operator-(const year_month_day& ymd, const months& dm) noexcept;
    constexpr year_month_day operator-(const year_month_day& ymd, const years& dy) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const year_month_day& ymd);
 
    template<class CharT, class Traits, class Alloc = allocator<CharT>>
      basic_istream<CharT, Traits>&
        from_stream(basic_istream<CharT, Traits>& is, const CharT* fmt,
                    year_month_day& ymd,
                    basic_string<CharT, Traits, Alloc>* abbrev = nullptr,
                    minutes* offset = nullptr);
 
    // class year_month_day_last
    class year_month_day_last;
 
    constexpr bool operator==(const year_month_day_last& x,
                              const year_month_day_last& y) noexcept;
    constexpr strong_ordering operator<=>(const year_month_day_last& x,
                                          const year_month_day_last& y) noexcept;
 
    constexpr year_month_day_last
      operator+(const year_month_day_last& ymdl, const months& dm) noexcept;
    constexpr year_month_day_last
      operator+(const months& dm, const year_month_day_last& ymdl) noexcept;
    constexpr year_month_day_last
      operator+(const year_month_day_last& ymdl, const years& dy) noexcept;
    constexpr year_month_day_last
      operator+(const years& dy, const year_month_day_last& ymdl) noexcept;
    constexpr year_month_day_last
      operator-(const year_month_day_last& ymdl, const months& dm) noexcept;
    constexpr year_month_day_last
      operator-(const year_month_day_last& ymdl, const years& dy) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const year_month_day_last& ymdl);
 
    // class year_month_weekday
    class year_month_weekday;
 
    constexpr bool operator==(const year_month_weekday& x,
                              const year_month_weekday& y) noexcept;
 
    constexpr year_month_weekday
      operator+(const year_month_weekday& ymwd, const months& dm) noexcept;
    constexpr year_month_weekday
      operator+(const months& dm, const year_month_weekday& ymwd) noexcept;
    constexpr year_month_weekday
      operator+(const year_month_weekday& ymwd, const years& dy) noexcept;
    constexpr year_month_weekday
      operator+(const years& dy, const year_month_weekday& ymwd) noexcept;
    constexpr year_month_weekday
      operator-(const year_month_weekday& ymwd, const months& dm) noexcept;
    constexpr year_month_weekday
      operator-(const year_month_weekday& ymwd, const years& dy) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const year_month_weekday& ymwdi);
 
    // class year_month_weekday_last
    class year_month_weekday_last;
 
    constexpr bool operator==(const year_month_weekday_last& x,
                              const year_month_weekday_last& y) noexcept;
 
    constexpr year_month_weekday_last
      operator+(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
    constexpr year_month_weekday_last
      operator+(const months& dm, const year_month_weekday_last& ymwdl) noexcept;
    constexpr year_month_weekday_last
      operator+(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
    constexpr year_month_weekday_last
      operator+(const years& dy, const year_month_weekday_last& ymwdl) noexcept;
    constexpr year_month_weekday_last
      operator-(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
    constexpr year_month_weekday_last
      operator-(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
 
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const year_month_weekday_last& ymwdl);
 
    // civil calendar conventional syntax operators
    constexpr year_month
      operator/(const year& y, const month& m) noexcept;
    constexpr year_month
      operator/(const year& y, int m) noexcept;
    constexpr month_day
      operator/(const month& m, const day& d) noexcept;
    constexpr month_day
      operator/(const month& m, int d) noexcept;
    constexpr month_day
      operator/(int m, const day& d) noexcept;
    constexpr month_day
      operator/(const day& d, const month& m) noexcept;
    constexpr month_day
      operator/(const day& d, int m) noexcept;
    constexpr month_day_last
      operator/(const month& m, last_spec) noexcept;
    constexpr month_day_last
      operator/(int m, last_spec) noexcept;
    constexpr month_day_last
      operator/(last_spec, const month& m) noexcept;
    constexpr month_day_last
      operator/(last_spec, int m) noexcept;
    constexpr month_weekday
      operator/(const month& m, const weekday_indexed& wdi) noexcept;
    constexpr month_weekday
      operator/(int m, const weekday_indexed& wdi) noexcept;
    constexpr month_weekday
      operator/(const weekday_indexed& wdi, const month& m) noexcept;
    constexpr month_weekday
      operator/(const weekday_indexed& wdi, int m) noexcept;
    constexpr month_weekday_last
      operator/(const month& m, const weekday_last& wdl) noexcept;
    constexpr month_weekday_last
      operator/(int m, const weekday_last& wdl) noexcept;
    constexpr month_weekday_last
      operator/(const weekday_last& wdl, const month& m) noexcept;
    constexpr month_weekday_last
      operator/(const weekday_last& wdl, int m) noexcept;
    constexpr year_month_day
      operator/(const year_month& ym, const day& d) noexcept;
    constexpr year_month_day
      operator/(const year_month& ym, int d) noexcept;
    constexpr year_month_day
      operator/(const year& y, const month_day& md) noexcept;
    constexpr year_month_day
      operator/(int y, const month_day& md) noexcept;
    constexpr year_month_day
      operator/(const month_day& md, const year& y) noexcept;
    constexpr year_month_day
      operator/(const month_day& md, int y) noexcept;
    constexpr year_month_day_last
      operator/(const year_month& ym, last_spec) noexcept;
    constexpr year_month_day_last
      operator/(const year& y, const month_day_last& mdl) noexcept;
    constexpr year_month_day_last
      operator/(int y, const month_day_last& mdl) noexcept;
    constexpr year_month_day_last
      operator/(const month_day_last& mdl, const year& y) noexcept;
    constexpr year_month_day_last
      operator/(const month_day_last& mdl, int y) noexcept;
    constexpr year_month_weekday
      operator/(const year_month& ym, const weekday_indexed& wdi) noexcept;
    constexpr year_month_weekday
      operator/(const year& y, const month_weekday& mwd) noexcept;
    constexpr year_month_weekday
      operator/(int y, const month_weekday& mwd) noexcept;
    constexpr year_month_weekday
      operator/(const month_weekday& mwd, const year& y) noexcept;
    constexpr year_month_weekday
      operator/(const month_weekday& mwd, int y) noexcept;
    constexpr year_month_weekday_last
      operator/(const year_month& ym, const weekday_last& wdl) noexcept;
    constexpr year_month_weekday_last
      operator/(const year& y, const month_weekday_last& mwdl) noexcept;
    constexpr year_month_weekday_last
      operator/(int y, const month_weekday_last& mwdl) noexcept;
    constexpr year_month_weekday_last
      operator/(const month_weekday_last& mwdl, const year& y) noexcept;
    constexpr year_month_weekday_last
      operator/(const month_weekday_last& mwdl, int y) noexcept;
 
    // class template hh_mm_ss
    template<class Duration> class hh_mm_ss;
 
    template<class CharT, class Traits, class Duration>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const hh_mm_ss<Duration>& hms);
 
    // 12/24 hour functions
    constexpr bool is_am(const hours& h) noexcept;
    constexpr bool is_pm(const hours& h) noexcept;
    constexpr hours make12(const hours& h) noexcept;
    constexpr hours make24(const hours& h, bool is_pm) noexcept;
 
    // time zone database
    struct tzdb;
    class tzdb_list;
 
    // time zone database access
    const tzdb& get_tzdb();
    tzdb_list& get_tzdb_list();
    const time_zone* locate_zone(string_view tz_name);
    const time_zone* current_zone();
 
    // remote time zone database support
    const tzdb& reload_tzdb();
    string remote_version();
 
    // exception classes
    class nonexistent_local_time;
    class ambiguous_local_time;
 
    // information classes
    struct sys_info;
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const sys_info& si);
 
    struct local_info;
    template<class CharT, class Traits>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os, const local_info& li);
 
    // class time_zone
    enum class choose {earliest, latest};
    class time_zone;
 
    bool operator==(const time_zone& x, const time_zone& y) noexcept;
    strong_ordering operator<=>(const time_zone& x, const time_zone& y) noexcept;
 
    // class template zoned_traits
    template<class T> struct zoned_traits;
 
    // class template zoned_time
    template<class Duration, class TimeZonePtr = const time_zone*> class zoned_time;
 
    using zoned_seconds = zoned_time<seconds>;
 
    template<class Duration1, class Duration2, class TimeZonePtr>
      bool operator==(const zoned_time<Duration1, TimeZonePtr>& x,
                      const zoned_time<Duration2, TimeZonePtr>& y);
 
    template<class CharT, class Traits, class Duration, class TimeZonePtr>
      basic_ostream<CharT, Traits>&
        operator<<(basic_ostream<CharT, Traits>& os,
                   const zoned_time<Duration, TimeZonePtr>& t);
 
    // leap second support
    class leap_second;
 
    bool operator==(const leap_second& x, const leap_second& y);
    strong_ordering operator<=>(const leap_second& x, const leap_second& y);
 
    template<class Duration>
      constexpr bool operator==(const leap_second& x, const sys_time<Duration>& y);
    template<class Duration>
      constexpr bool operator< (const leap_second& x, const sys_time<Duration>& y);
    template<class Duration>
      constexpr bool operator< (const sys_time<Duration>& x, const leap_second& y);
    template<class Duration>
      constexpr bool operator> (const leap_second& x, const sys_time<Duration>& y);
    template<class Duration>
      constexpr bool operator> (const sys_time<Duration>& x, const leap_second& y);
    template<class Duration>
      constexpr bool operator<=(const leap_second& x, const sys_time<Duration>& y);
    template<class Duration>
      constexpr bool operator<=(const sys_time<Duration>& x, const leap_second& y);
    template<class Duration>
      constexpr bool operator>=(const leap_second& x, const sys_time<Duration>& y);
    template<class Duration>
      constexpr bool operator>=(const sys_time<Duration>& x, const leap_second& y);
    template<class Duration>
      requires three_way_comparable_with<sys_seconds, sys_time<Duration>>
      constexpr auto operator<=>(const leap_second& x, const sys_time<Duration>& y);
 
    // class time_zone_link
    class time_zone_link;
 
    bool operator==(const time_zone_link& x, const time_zone_link& y);
    strong_ordering operator<=>(const time_zone_link& x, const time_zone_link& y);
 
    // formatting
    template<class Duration> struct /*local-time-format-t*/;    // exposition only
    template<class Duration>
      /*local-time-format-t*/<Duration>
        local_time_format(local_time<Duration> time, const string* abbrev = nullptr,
                          const seconds* offset_sec = nullptr);
  }
 
  template<class Rep, class Period, class CharT>
    struct formatter<chrono::duration<Rep, Period>, CharT>;
  template<class Duration, class CharT>
    struct formatter<chrono::sys_time<Duration>, CharT>;
  template<class Duration, class CharT>
    struct formatter<chrono::utc_time<Duration>, CharT>;
  template<class Duration, class CharT>
    struct formatter<chrono::tai_time<Duration>, CharT>;
  template<class Duration, class CharT>
    struct formatter<chrono::gps_time<Duration>, CharT>;
  template<class Duration, class CharT>
    struct formatter<chrono::file_time<Duration>, CharT>;
  template<class Duration, class CharT>
    struct formatter<chrono::local_time<Duration>, CharT>;
  template<class Duration, class CharT>
    struct formatter<chrono::/*local-time-format-t*/<Duration>, CharT>;
  template<class CharT> struct formatter<chrono::day, CharT>;
  template<class CharT> struct formatter<chrono::month, CharT>;
  template<class CharT> struct formatter<chrono::year, CharT>;
  template<class CharT> struct formatter<chrono::weekday, CharT>;
  template<class CharT> struct formatter<chrono::weekday_indexed, CharT>;
  template<class CharT> struct formatter<chrono::weekday_last, CharT>;
  template<class CharT> struct formatter<chrono::month_day, CharT>;
  template<class CharT> struct formatter<chrono::month_day_last, CharT>;
  template<class CharT> struct formatter<chrono::month_weekday, CharT>;
  template<class CharT> struct formatter<chrono::month_weekday_last, CharT>;
  template<class CharT> struct formatter<chrono::year_month, CharT>;
  template<class CharT> struct formatter<chrono::year_month_day, CharT>;
  template<class CharT> struct formatter<chrono::year_month_day_last, CharT>;
  template<class CharT> struct formatter<chrono::year_month_weekday, CharT>;
  template<class CharT> struct formatter<chrono::year_month_weekday_last, CharT>;
  template<class Rep, class Period, class CharT>
    struct formatter<chrono::hh_mm_ss<duration<Rep, Period>>, CharT>;
  template<class CharT> struct formatter<chrono::sys_info, CharT>;
  template<class CharT> struct formatter<chrono::local_info, CharT>;
  template<class Duration, class TimeZonePtr, class CharT>
    struct formatter<chrono::zoned_time<Duration, TimeZonePtr>, CharT>;
 
  namespace chrono {
    // parsing
    template<class CharT, class Parsable>
      /* unspecified */
        parse(const CharT* fmt, Parsable& tp);
 
    template<class CharT, class Traits, class Alloc, class Parsable>
      /* unspecified */
        parse(const basic_string<CharT, Traits, Alloc>& format, Parsable& tp);
 
    template<class CharT, class traits, class Alloc, class Parsable>
      /* unspecified */
        parse(const CharT* fmt, Parsable& tp,
              basic_string<CharT, traits, Alloc>& abbrev);
 
    template<class CharT, class Traits, class Alloc, class Parsable>
      /* unspecified */
        parse(const basic_string<CharT, Traits, Alloc>& format, Parsable& tp,
              basic_string<CharT, Traits, Alloc>& abbrev);
 
    template<class CharT, class Parsable>
      /* unspecified */
        parse(const CharT* fmt, Parsable& tp, minutes& offset);
 
    template<class CharT, class Traits, class Alloc, class Parsable>
      /* unspecified */
        parse(const basic_string<CharT, Traits, Alloc>& format, Parsable& tp,
              minutes& offset);
 
    template<class CharT, class traits, class Alloc, class Parsable>
      /* unspecified */
        parse(const CharT* fmt, Parsable& tp,
              basic_string<CharT, traits, Alloc>& abbrev, minutes& offset);
 
    template<class CharT, class Traits, class Alloc, class Parsable>
      /* unspecified */
        parse(const basic_string<CharT, Traits, Alloc>& format, Parsable& tp,
              basic_string<CharT, Traits, Alloc>& abbrev, minutes& offset);
 
    // calendrical constants
    inline constexpr last_spec last{};
 
    inline constexpr weekday Sunday{0};
    inline constexpr weekday Monday{1};
    inline constexpr weekday Tuesday{2};
    inline constexpr weekday Wednesday{3};
    inline constexpr weekday Thursday{4};
    inline constexpr weekday Friday{5};
    inline constexpr weekday Saturday{6};
 
    inline constexpr month January{1};
    inline constexpr month February{2};
    inline constexpr month March{3};
    inline constexpr month April{4};
    inline constexpr month May{5};
    inline constexpr month June{6};
    inline constexpr month July{7};
    inline constexpr month August{8};
    inline constexpr month September{9};
    inline constexpr month October{10};
    inline constexpr month November{11};
    inline constexpr month December{12};
  }
 
  inline namespace literals {
  inline namespace chrono_literals {
    // suffixes for duration literals
    constexpr chrono::hours                    operator""h(unsigned long long);
    constexpr chrono::duration</* unspecified */,
                               ratio<3600, 1>> operator""h(long double);
 
    constexpr chrono::minutes                operator""min(unsigned long long);
    constexpr chrono::duration</* unspecified */,
                               ratio<60, 1>> operator""min(long double);
 
    constexpr chrono::seconds                     operator""s(unsigned long long);
    constexpr chrono::duration</* unspecified */> operator""s(long double);
 
    constexpr chrono::milliseconds                       operator""ms(unsigned long long);
    constexpr chrono::duration</* unspecified */, milli> operator""ms(long double);
 
    constexpr chrono::microseconds                       operator""us(unsigned long long);
    constexpr chrono::duration</* unspecified */, micro> operator""us(long double);
 
    constexpr chrono::nanoseconds                       operator""ns(unsigned long long);
    constexpr chrono::duration</* unspecified */, nano> operator""ns(long double);
 
    // non-member functions
    constexpr chrono::day  operator""d(unsigned long long d) noexcept;
 
    // non-member functions
    constexpr chrono::year operator""y(unsigned long long y) noexcept;
  }
  }
 
  namespace chrono {
    using namespace literals::chrono_literals;
  }
 
  // hash support
  template<class T> struct hash;
  template<class Rep, class Period>
    struct hash<chrono::duration<Rep, Period>>;
  template<class Clock, class Duration>
    struct hash<chrono::time_point<Clock, Duration>>;
  template<> struct hash<chrono::day>;
  template<> struct hash<chrono::month>;
  template<> struct hash<chrono::year>;
  template<> struct hash<chrono::weekday>;
  template<> struct hash<chrono::weekday_indexed>;
  template<> struct hash<chrono::weekday_last>;
  template<> struct hash<chrono::month_day>;
  template<> struct hash<chrono::month_day_last>;
  template<> struct hash<chrono::month_weekday>;
  template<> struct hash<chrono::month_weekday_last>;
  template<> struct hash<chrono::year_month>;
  template<> struct hash<chrono::year_month_day>;
  template<> struct hash<chrono::year_month_day_last>;
  template<> struct hash<chrono::year_month_weekday>;
  template<> struct hash<chrono::year_month_weekday_last>;
  template<class Duration, class TimeZonePtr>
    struct hash<chrono::zoned_time<Duration, TimeZonePtr>>;
  template<> struct hash<chrono::leap_second>;
}
```

* 运算符重载运算得到的返回值取决于时间小的类型
  * seconds(1) + milliseconds(500) = milliseconds(1501)
  * seconds(1) + hours(2) = seconds(7201) 



* 

## 1. 持续时间 (Duration)

> std::ratio 的详细定义以及使用 见：	 [](./ratio.md)

### 常用持续时间类型

| 类型                          | 说明 | 周期                   |
| ----------------------------- | ---- | ---------------------- |
| `std::chrono::nanoseconds`    | 纳秒 | `std::nano`            |
| `std::chrono::microseconds`   | 微秒 | `std::micro`           |
| `std::chrono::milliseconds`   | 毫秒 | `std::milli`           |
| `std::chrono::seconds`        | 秒   | `std::ratio<1>`        |
| `std::chrono::minutes`        | 分钟 | `std::ratio<60>`       |
| `std::chrono::hours`          | 小时 | `std::ratio<3600>`     |
| `std::chrono::days` (C++20)   | 天   | `std::ratio<86400>`    |
| `std::chrono::weeks` (C++20)  | 周   | `std::ratio<604800>`   |
| `std::chrono::months` (C++20) | 月   | `std::ratio<2629746>`  |
| `std::chrono::years` (C++20)  | 年   | `std::ratio<31556952>` |

### 持续时间操作示例

```cpp
#include <iostream>
#include <chrono>
#include <thread>

int main() {
    using namespace std::chrono;
    
    // 创建持续时间
    auto one_second = seconds(1);
    auto half_second = milliseconds(500);
    auto two_hours = hours(2);
    
    // C++14 字面量
    auto ns = 100ns;
    auto us = 200us;
    auto ms = 300ms;
    auto sec = 4s;
    auto min = 5min;
    auto hr = 6h;
    
    // C++20 字面量
    #if __cplusplus >= 202002L
    auto d = 7d;
    auto y = 8y;
    #endif
    
    // 持续时间算术运算
    auto total_time = one_second + half_second;
    std::cout << "总时间: " << total_time.count() << " 毫秒" << std::endl;
    
    // 持续时间转换
    auto seconds_in_hour = duration_cast<seconds>(two_hours);
    std::cout << "2小时 = " << seconds_in_hour.count() << " 秒" << std::endl;
    
    // 向下取整、向上取整和四舍五入
    auto odd_time = milliseconds(1750);
    auto floor_sec = floor<seconds>(odd_time);
    auto ceil_sec = ceil<seconds>(odd_time);
    auto round_sec = round<seconds>(odd_time);
    
    std::cout << "1750毫秒向下取整: " << floor_sec.count() << " 秒" << std::endl;
    std::cout << "1750毫秒向上取整: " << ceil_sec.count() << " 秒" << std::endl;
    std::cout << "1750毫秒四舍五入: " << round_sec.count() << " 秒" << std::endl;
    
    // 实际应用：测量代码执行时间
    auto start = high_resolution_clock::now();
    std::this_thread::sleep_for(100ms); // 模拟工作
    auto end = high_resolution_clock::now();
    
    auto elapsed = duration_cast<microseconds>(end - start);
    std::cout << "执行时间: " << elapsed.count() << " 微秒" << std::endl;
    
    return 0;
}
```

## 2. 时间点 (Time Point) 和时钟 (Clocks)

### 时钟/时间点 类型

| 时间点                                                       |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ time_point](https://cppreference.cn/w/cpp/chrono/time_point)(C++11) | 时间中的一个点  (类模板)                                     |
| [ clock_time_conversion](https://cppreference.cn/w/cpp/chrono/clock_time_conversion)(C++20) | 定义如何将一个时钟的时间点转换为另一个时钟的时间点的特性类  (类模板) |
| 时钟                                                         |                                                              |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ is_clockis_clock_v](https://cppreference.cn/w/cpp/chrono/is_clock)(C++20) | 确定类型是否为 [*时钟*](https://cppreference.cn/w/cpp/named_req/Clock) (类模板) (变量模板) |
| [ system_clock](https://cppreference.cn/w/cpp/chrono/system_clock)(C++11) | 来自系统范围实时时钟的挂钟时间  (类)                         |
| [ steady_clock](https://cppreference.cn/w/cpp/chrono/steady_clock)(C++11) | 永不调整的单调时钟  (类)                                     |
| [ high_resolution_clock](https://cppreference.cn/w/cpp/chrono/high_resolution_clock)(C++11) | 具有最短可用时钟周期的时钟  (类)                             |
| [ utc_clock](https://cppreference.cn/w/cpp/chrono/utc_clock)(C++20) | [*时钟*](https://cppreference.cn/w/cpp/named_req/Clock)，用于协调世界时 (UTC)  (类) |
| [ tai_clock](https://cppreference.cn/w/cpp/chrono/tai_clock)(C++20) | [*时钟*](https://cppreference.cn/w/cpp/named_req/Clock)，用于国际原子时 (TAI)  (类) |
| [ gps_clock](https://cppreference.cn/w/cpp/chrono/gps_clock)(C++20) | [*时钟*](https://cppreference.cn/w/cpp/named_req/Clock)，用于 GPS 时间  (类) |
| [ file_clock](https://cppreference.cn/w/cpp/chrono/file_clock)(C++20) | [*时钟*](https://cppreference.cn/w/cpp/named_req/Clock)，用于 [文件时间](https://cppreference.cn/w/cpp/filesystem/file_time_type)  (类型别名) |
| [ local_t](https://cppreference.cn/w/cpp/chrono/local_t)(C++20) | 表示本地时间的伪时钟  (类)                                   |

### 时间点支持方法

| 时间点                                                       |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/time_point/operator_arith2)(C++11) | 执行涉及时间点的加法和减法运算  (函数模板)                   |
| [ operator==operator!=operatoroperator>=operator<=>](https://cppreference.cn/w/cpp/chrono/time_point/operator_cmp)(C++11)(C++11)(C++20 中移除)(C++11)(C++11)(C++11)(C++11)(C++20) | 比较两个时间点  (函数模板)                                   |
| [ time_point_cast](https://cppreference.cn/w/cpp/chrono/time_point/time_point_cast)(C++11) | 将时间点转换为同一时钟上的另一个时间点，具有不同的 duration  (函数模板) |
| [ floor(std::chrono::time_point)](https://cppreference.cn/w/cpp/chrono/time_point/floor)(C++17) | 将 time_point 转换为另一个 time_point，向下舍入  (函数模板)  |
| [ ceil(std::chrono::time_point)](https://cppreference.cn/w/cpp/chrono/time_point/ceil)(C++17) | 将 time_point 转换为另一个 time_point，向上舍入  (函数模板)  |
| [ round(std::chrono::time_point)](https://cppreference.cn/w/cpp/chrono/time_point/round)(C++17) | 将 time_point 转换为另一个 time_point，四舍五入到最接近的，平局到偶数  (函数模板) |
| [ from_stream(std::chrono::sys_time)](https://cppreference.cn/w/cpp/chrono/system_clock/from_stream)(C++20) | 根据提供的格式从流中解析 `sys_time`  (函数模板)              |
| [ from_stream(std::chrono::utc_time)](https://cppreference.cn/w/cpp/chrono/utc_clock/from_stream)(C++20) | 根据提供的格式从流中解析 `utc_time`  (函数模板)              |
| [ from_stream(std::chrono::tai_time)](https://cppreference.cn/w/cpp/chrono/tai_clock/from_stream)(C++20) | 根据提供的格式从流中解析 `tai_time`  (函数模板)              |
| [ from_stream(std::chrono::gps_time)](https://cppreference.cn/w/cpp/chrono/gps_clock/from_stream)(C++20) | 根据提供的格式从流中解析 `gps_time`  (函数模板)              |
| [ from_stream(std::chrono::file_time)](https://cppreference.cn/w/cpp/chrono/file_clock/from_stream)(C++20) | 根据提供的格式从流中解析 `file_time`  (函数模板)             |
| [ from_stream(std::chrono::local_time)](https://cppreference.cn/w/cpp/chrono/local_t/from_stream)(C++20) | 根据提供的格式从流中解析 `local_time`  (函数模板)            |
| [ clock_cast](https://cppreference.cn/w/cpp/chrono/clock_cast)(C++20) | 将一个时钟的时间点转换为另一个时钟的时间点  (函数模板)       |

### 时间点操作示例

```cpp
#include <iostream>
#include <chrono>
#include <thread>

int main() {
    using namespace std::chrono;
    
    // 获取当前时间点
    auto sys_now = system_clock::now();
    auto steady_now = steady_clock::now();
    
    // 时间点算术运算
    auto one_hour_later = sys_now + hours(1);
    auto ten_minutes_ago = sys_now - minutes(10);
    
    // 计算时间间隔
    auto start = steady_clock::now();
    std::this_thread::sleep_for(50ms);
    auto end = steady_clock::now();
    
    auto duration = end - start;
    std::cout << "实际睡眠时间: " 
              << duration_cast<microseconds>(duration).count() 
              << " 微秒" << std::endl;
    
    // 时间点转换
    auto sys_time = system_clock::to_time_t(sys_now);
    std::cout << "当前系统时间: " << std::ctime(&sys_time);
    
    // C++20 时钟转换
    #if __cplusplus >= 202002L
    auto utc_now = clock_cast<utc_clock>(sys_now);
    std::cout << "UTC时间: " << utc_now << "   " << utc_now.time_since_epoch().count() << std::endl;
    #endif
    
    // 时间点比较
    if (one_hour_later > sys_now) {
        std::cout << "一小时后确实是在未来" << std::endl;
    }
    
    return 0;
}
```

## 3. 日历类型 (C++20)

### 日历类型

| 日历                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ last_spec](https://cppreference.cn/w/cpp/chrono/last_spec)(C++20) | 标记类，指示一个月中的最后一天或最后一个工作日  (类)         |
| [ day](https://cppreference.cn/w/cpp/chrono/day)(C++20)      | 表示一个月中的一天  (类)                                     |
| [ month](https://cppreference.cn/w/cpp/chrono/month)(C++20)  | 表示一年中的一个月  (类)                                     |
| [ year](https://cppreference.cn/w/cpp/chrono/year)(C++20)    | 表示公历中的一年  (类)                                       |
| [ weekday](https://cppreference.cn/w/cpp/chrono/weekday)(C++20) | 表示公历中的一周中的一天  (类)                               |
| [ weekday_indexed](https://cppreference.cn/w/cpp/chrono/weekday_indexed)(C++20) | 表示一个月中的第 n 个 [`weekday`](https://cppreference.cn/w/cpp/chrono/weekday)  (类) |
| [ weekday_last](https://cppreference.cn/w/cpp/chrono/weekday_last)(C++20) | 表示一个月中的最后一个 [`weekday`](https://cppreference.cn/w/cpp/chrono/weekday)  (类) |
| [ month_day](https://cppreference.cn/w/cpp/chrono/month_day)(C++20) | 表示特定 [`month`](https://cppreference.cn/w/cpp/chrono/month) 的特定 [`day`](https://cppreference.cn/w/cpp/chrono/day)  (类) |
| [ month_day_last](https://cppreference.cn/w/cpp/chrono/month_day_last)(C++20) | 表示特定 [`month`](https://cppreference.cn/w/cpp/chrono/month) 的最后一天  (类) |
| [ month_weekday](https://cppreference.cn/w/cpp/chrono/month_weekday)(C++20) | 表示特定 [`month`](https://cppreference.cn/w/cpp/chrono/month) 的第 n 个 [`weekday`](https://cppreference.cn/w/cpp/chrono/weekday)  (类) |
| [ month_weekday_last](https://cppreference.cn/w/cpp/chrono/month_weekday_last)(C++20) | 表示特定 [`month`](https://cppreference.cn/w/cpp/chrono/month) 的最后一个 [`weekday`](https://cppreference.cn/w/cpp/chrono/weekday)  (类) |
| [ year_month](https://cppreference.cn/w/cpp/chrono/year_month)(C++20) | 表示特定 [`year`](https://cppreference.cn/w/cpp/chrono/year) 的特定 [`month`](https://cppreference.cn/w/cpp/chrono/month)  (类) |
| [ year_month_day](https://cppreference.cn/w/cpp/chrono/year_month_day)(C++20) | 表示特定的 [`year`](https://cppreference.cn/w/cpp/chrono/year)、[`month`](https://cppreference.cn/w/cpp/chrono/month) 和 [`day`](https://cppreference.cn/w/cpp/chrono/day)  (类) |
| [ year_month_day_last](https://cppreference.cn/w/cpp/chrono/year_month_day_last)(C++20) | 表示特定 [`year`](https://cppreference.cn/w/cpp/chrono/year) 和 [`month`](https://cppreference.cn/w/cpp/chrono/month) 的最后一天  (类) |
| [ year_month_weekday](https://cppreference.cn/w/cpp/chrono/year_month_weekday)(C++20) | 表示特定 [`year`](https://cppreference.cn/w/cpp/chrono/year) 和 [`month`](https://cppreference.cn/w/cpp/chrono/month) 的第 n 个 [`weekday`](https://cppreference.cn/w/cpp/chrono/weekday)  (类) |
| [ year_month_weekday_last](https://cppreference.cn/w/cpp/chrono/year_month_weekday_last)(C++20) | 表示特定 [`year`](https://cppreference.cn/w/cpp/chrono/year) 和 [`month`](https://cppreference.cn/w/cpp/chrono/month) 的最后一个 [`weekday`](https://cppreference.cn/w/cpp/chrono/weekday)  (类) |
| 一天中的时间                                                 |                                                              |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ hh_mm_ss](https://cppreference.cn/w/cpp/chrono/hh_mm_ss)(C++20) | 表示一天中的时间  (类模板)                                   |

### 日历支持方法

| 日历                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/day/operator_cmp)(C++20) | 比较两个 `day` 值  (函数)                                    |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/month/operator_cmp)(C++20) | 比较两个 `month` 值  (函数)                                  |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/year/operator_cmp)(C++20) | 比较两个 `year` 值  (函数)                                   |
| [ operator==](https://cppreference.cn/w/cpp/chrono/weekday/operator_cmp)(C++20) | 比较两个 `weekday` 值  (函数)                                |
| [ operator==](https://cppreference.cn/w/cpp/chrono/weekday_indexed/operator_cmp)(C++20) | 比较两个 `weekday_indexed` 值  (函数)                        |
| [ operator==](https://cppreference.cn/w/cpp/chrono/weekday_last/operator_cmp)(C++20) | 比较两个 `weekday_last` 值  (函数)                           |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/month_day/operator_cmp)(C++20) | 比较两个 `month_day` 值  (函数)                              |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/month_day_last/operator_cmp)(C++20) | 比较两个 `month_day_last` 值  (函数)                         |
| [ operator==](https://cppreference.cn/w/cpp/chrono/month_weekday/operator_cmp)(C++20) | 比较两个 `month_weekday` 值  (函数)                          |
| [ operator==](https://cppreference.cn/w/cpp/chrono/month_weekday_last/operator_cmp)(C++20) | 比较两个 `month_weekday_last` 值  (函数)                     |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/year_month/operator_cmp)(C++20) | 比较两个 `year_month` 值  (函数)                             |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/year_month_day/operator_cmp)(C++20) | 比较两个 `year_month_day` 值  (函数)                         |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/year_month_day_last/operator_cmp)(C++20) | 比较两个 `year_month_day_last` 值  (函数)                    |
| [ operator==](https://cppreference.cn/w/cpp/chrono/year_month_weekday/operator_cmp)(C++20) | 比较两个 `year_month_weekday` 值  (函数)                     |
| [ operator==](https://cppreference.cn/w/cpp/chrono/year_month_weekday_last/operator_cmp)(C++20) | 比较两个 `year_month_weekday_last` 值  (函数)                |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/day/operator_arith_2)(C++20) | 添加或减去天数和一个 `day`，或查找两个 `day` 之间的差值  (函数) |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/month/operator_arith_2)(C++20) | 对 `month` 执行算术运算  (函数)                              |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/year/operator_arith_2)(C++20) | 对 `year` 执行算术运算  (函数)                               |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/weekday/operator_arith_2)(C++20) | 对 `weekday` 执行算术运算  (函数)                            |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/year_month/operator_arith_2)(C++20) | 对 `year_month` 执行算术运算  (函数)                         |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/year_month_day/operator_arith_2)(C++20) | 添加或减去 `year_month_day` 和一些年或月  (函数)             |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/year_month_day_last/operator_arith_2)(C++20) | 添加或减去 `year_month_day_last` 和一些年或月  (函数)        |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/year_month_weekday/operator_arith_2)(C++20) | 添加或减去 `year_month_weekday` 和一些年或月  (函数)         |
| [ operator+operator-](https://cppreference.cn/w/cpp/chrono/year_month_weekday_last/operator_arith_2)(C++20) | 添加或减去 `year_month_weekday_last` 和一些年或月  (函数)    |
| [ operator/](https://cppreference.cn/w/cpp/chrono/operator_slash)(C++20) | 用于创建公历日期的传统语法  (函数)                           |
| 一天中的时间                                                 |                                                              |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ is_am<br />is_pm<br />make12<br />make24](https://cppreference.cn/w/cpp/chrono/hour_fun)(C++20) | 在 12 小时/24 小时制之间转换时间  (函数)                     |

### 日历操作示例

```cpp
#include <iostream>
#include <chrono>

#if __cplusplus >= 202002L

int main() {
    using namespace std::chrono;
    
    // 创建日历类型
    auto d = day(15);
    auto m = month(8);
    auto y = year(2023);
    auto wd = weekday(Monday);

    // 组合日期
    auto md = month_day(m, d);
    auto ym = year_month(y, m);
    auto ymd = year_month_day(y, m, d);
    
    // 闰年是否
    std::println("{}是不是闰年: {}", y, y.is_leap());

    // 检查日期有效性
    if (md.ok()) {
        std::cout << "日期有效: " << static_cast<unsigned>(m) << "/"
            << static_cast<unsigned>(d) << std::endl;
    }

    std::println("day: {}, month: {}, year: {}, weekday: {}, md: {}, ym: {}, ymd: {}"
        , d, m, y, wd, md, ym, ymd);

    // 日期算术运算
    auto next_month = ym + months(1);
    auto next_year = y + years(1);
    auto next_weekday = wd + days(6);
#pragma push_macro("min")
#undef min
    std::cout << "下个月: " << static_cast<unsigned>(next_month.month())
        << " 下个年: " << next_year.operator int() << " 当前星期: " << wd.c_encoding() << " 六天过后星期" << next_weekday.iso_encoding() << std::endl;
#pragma pop_macro("min")

    // 获取当前日期
    auto today = floor<days>(system_clock::now());
    auto ymd_today = year_month_day(today);

    std::cout << "今天是: " << static_cast<int>(ymd_today.year()) << "-"
        << static_cast<unsigned>(ymd_today.month()) << "-"
        << static_cast<unsigned>(ymd_today.day()) << std::endl;

    // 日期比较
    auto christmas = year_month_day(year(2023) / December / 25);
    if (ymd_today < christmas) {
        std::cout << "圣诞节还没到" << std::endl;
    }
    
    return 0;
}

#else

int main() {
    std::cout << "此示例需要 C++20 支持" << std::endl;
    return 0;
}

#endif
```

## 4. 时区操作 (C++20)

### 时区类型

| 时区                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ tzdb](https://cppreference.cn/w/cpp/chrono/tzdb)(C++20)    | 描述 [IANA 时区数据库](https://www.iana.org/time-zones) 的副本  (类) |
| [ tzdb_list](https://cppreference.cn/w/cpp/chrono/tzdb_list)(C++20) | 表示 [`tzdb`](https://cppreference.cn/w/cpp/chrono/tzdb) 的链表  (类) |
| [ time_zone](https://cppreference.cn/w/cpp/chrono/time_zone)(C++20) | 表示时区  (类)                                               |
| [ sys_info](https://cppreference.cn/w/cpp/chrono/sys_info)(C++20) | 表示关于特定时间点的时区信息  (类)                           |
| [ local_info](https://cppreference.cn/w/cpp/chrono/local_info)(C++20) | 表示关于本地时间到 UNIX 时间转换的信息  (类)                 |
| [ choose](https://cppreference.cn/w/cpp/chrono/choose)(C++20) | 选择如何解析不明确的本地时间  (枚举)                         |
| [ zoned_traits](https://cppreference.cn/w/cpp/chrono/zoned_traits)(C++20) | 由 [`zoned_time`](https://cppreference.cn/w/cpp/chrono/zoned_time) 使用的时区指针的 traits 类  (类模板) |
| [ zoned_time](https://cppreference.cn/w/cpp/chrono/zoned_time)(C++20) | 表示时区和时间点  (类)                                       |
| [ time_zone_link](https://cppreference.cn/w/cpp/chrono/time_zone_link)(C++20) | 表示时区的别名  (类)                                         |
| [ nonexistent_local_time](https://cppreference.cn/w/cpp/chrono/nonexistent_local_time)(C++20) | 抛出异常以报告本地时间不存在  (类)                           |
| [ ambiguous_local_time](https://cppreference.cn/w/cpp/chrono/ambiguous_local_time)(C++20) | 抛出异常以报告本地时间不明确  (类)                           |

### 时区支持方法

| 时区                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ get_tzdbget_tzdb_listreload_tzdbremote_version](https://cppreference.cn/w/cpp/chrono/tzdb_functions)(C++20) | 访问和控制全局时区数据库信息  (函数)                         |
| [ locate_zone](https://cppreference.cn/w/cpp/chrono/locate_zone)(C++20) | 根据名称定位 [`time_zone`](https://cppreference.cn/w/cpp/chrono/time_zone)  (函数) |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/time_zone/operator_cmp)(C++20) | 比较两个 `time_zone` 对象  (函数)                            |
| [ operator==](https://cppreference.cn/w/cpp/chrono/zoned_time/operator_cmp)(C++20) | 比较两个 `zoned_time` 值  (函数模板)                         |
| [ operator==operator<=>](https://cppreference.cn/w/cpp/chrono/time_zone_link/operator_cmp)(C++20) | 比较两个 `time_zone_link` 对象  (函数)                       |
| Leap second                                                  |                                                              |
| 定义于命名空间 `std::chrono`                                 |                                                              |
| [ get_leap_second_info](https://cppreference.cn/w/cpp/chrono/utc_clock/get_leap_second_info)(C++20) | 从 `utc_time` 对象获取闰秒插入信息  (函数模板)               |

### 时区操作示例

```cpp
#include <iostream>
#include <chrono>

#if __cplusplus >= 202002L

int main() {
    using namespace std::chrono;
    
    try {
        // 获取时区数据库
        const auto& tz_db = get_tzdb();
        std::cout << "时区数据库版本: " << tz_db.version << std::endl;
        
        // 定位特定时区
        auto ny_tz = locate_zone("America/New_York");
        auto london_tz = locate_zone("Europe/London");
        auto tokyo_tz = locate_zone("Asia/Tokyo");
        
        // 创建带时区的时间
        auto now = system_clock::now();
        zoned_time ny_time{ny_tz, now};
        zoned_time london_time{london_tz, now};
        zoned_time tokyo_time{tokyo_tz, now};
        
        std::cout << "纽约时间: " << ny_time << std::endl;
        std::cout << "伦敦时间: " << london_time << std::endl;
        std::cout << "东京时间: " << tokyo_time << std::endl;
        
        // 转换时区
        auto ny_to_london = zoned_time{london_tz, ny_time};
        std::cout << "纽约时间对应的伦敦时间: " << ny_to_london << std::endl;
        
        // 处理本地时间
        auto local = zoned_time{current_zone(), now};
        std::cout << "本地时间: " << local << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "时区错误: " << e.what() << std::endl;
    }
    
    return 0;
}

#else

int main() {
    std::cout << "此示例需要 C++20 支持" << std::endl;
    return 0;
}

#endif
```

## 5. 格式化输出 (C++20)

### std::formatter定义

具体匹配符号见官网

| Specializations                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间 `std`                                         |                                                              |
| [ std::common_type](https://cppreference.cn/w/cpp/chrono/duration/common_type)(C++11) | 特化 [std::common_type](https://cppreference.cn/w/cpp/types/common_type) trait  (类模板特化) |
| [ std::common_type](https://cppreference.cn/w/cpp/chrono/time_point/common_type)(C++11) | 特化 [std::common_type](https://cppreference.cn/w/cpp/types/common_type) trait  (类模板特化) |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/duration/formatter)(C++20) | `duration` 的格式化支持  (类模板特化)                        |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/system_clock/formatter)(C++20) | `sys_time` 的格式化支持  (类模板特化)                        |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/utc_clock/formatter)(C++20) | `utc_time` 的格式化支持  (类模板特化)                        |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/tai_clock/formatter)(C++20) | `tai_time` 的格式化支持  (类模板特化)                        |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/gps_clock/formatter)(C++20) | `gps_time` 的格式化支持  (类模板特化)                        |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/file_clock/formatter)(C++20) | `file_time` 的格式化支持  (类模板特化)                       |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/local_t/formatter)(C++20) | `local_time` 的格式化支持  (类模板特化)                      |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/day/formatter)(C++20) | `day` 的格式化支持  (类模板特化)                             |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/month/formatter)(C++20) | `month` 的格式化支持  (类模板特化)                           |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/year/formatter)(C++20) | `year` 的格式化支持  (类模板特化)                            |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/weekday/formatter)(C++20) | `weekday` 的格式化支持  (类模板特化)                         |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/weekday_indexed/formatter)(C++20) | `weekday_indexed` 的格式化支持  (类模板特化)                 |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/weekday_last/formatter)(C++20) | `weekday_last` 的格式化支持  (类模板特化)                    |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/month_day/formatter)(C++20) | `month_day` 的格式化支持  (类模板特化)                       |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/month_day_last/formatter)(C++20) | `month_day_last` 的格式化支持  (类模板特化)                  |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/month_weekday/formatter)(C++20) | `month_weekday` 的格式化支持  (类模板特化)                   |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/month_weekday_last/formatter)(C++20) | `month_weekday_last` 的格式化支持  (类模板特化)              |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/year_month/formatter)(C++20) | `year_month` 的格式化支持  (类模板特化)                      |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/year_month_day/formatter)(C++20) | `year_month_day` 的格式化支持  (类模板特化)                  |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/year_month_day_last/formatter)(C++20) | `year_month_day_last` 的格式化支持  (类模板特化)             |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/year_month_weekday/formatter)(C++20) | `year_month_weekday` 的格式化支持  (类模板特化)              |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/year_month_weekday_last/formatter)(C++20) | `year_month_weekday_last` 的格式化支持  (类模板特化)         |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/hh_mm_ss/formatter)(C++20) | `hh_mm_ss` 的格式化支持  (类模板特化)                        |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/sys_info/formatter)(C++20) | `sys_info` 的格式化支持  (类模板特化)                        |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/local_info/formatter)(C++20) | `local_info` 的格式化支持  (类模板特化)                      |
| [ std::formatter](https://cppreference.cn/w/cpp/chrono/zoned_time/formatter)(C++20) | `zoned_time` 的格式化支持  (类模板特化)                      |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/duration/hash)(C++26) | [`std::chrono::duration`](https://cppreference.cn/w/cpp/chrono/duration) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/time_point/hash)(C++26) | [`std::chrono::time_point`](https://cppreference.cn/w/cpp/chrono/time_point) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/day/hash)(C++26) | [`std::chrono::day`](https://cppreference.cn/w/cpp/chrono/day) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/month/hash)(C++26) | [`std::chrono::month`](https://cppreference.cn/w/cpp/chrono/month) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/year/hash)(C++26) | [`std::chrono::year`](https://cppreference.cn/w/cpp/chrono/year) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/weekday/hash)(C++26) | [`std::chrono::weekday`](https://cppreference.cn/w/cpp/chrono/weekday) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/weekday_indexed/hash)(C++26) | [`std::chrono::weekday_indexed`](https://cppreference.cn/w/cpp/chrono/weekday_indexed) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/weekday_last/hash)(C++26) | [`std::chrono::weekday_last`](https://cppreference.cn/w/cpp/chrono/weekday_last) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/month_day/hash)(C++26) | [`std::chrono::month_day`](https://cppreference.cn/w/cpp/chrono/month_day) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/month_day_last/hash)(C++26) | [`std::chrono::month_day_last`](https://cppreference.cn/w/cpp/chrono/month_day_last) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/month_weekday/hash)(C++26) | [`std::chrono::month_weekday`](https://cppreference.cn/w/cpp/chrono/month_weekday) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/month_weekday_last/hash)(C++26) | [`std::chrono::month_weekday_last`](https://cppreference.cn/w/cpp/chrono/month_weekday_last) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/year_month/hash)(C++26) | [`std::chrono::year_month`](https://cppreference.cn/w/cpp/chrono/year_month) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/year_month_day/hash)(C++26) | [`std::chrono::year_month_day`](https://cppreference.cn/w/cpp/chrono/year_month_day) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/year_month_day_last/hash)(C++26) | [`std::chrono::year_month_day_last`](https://cppreference.cn/w/cpp/chrono/year_month_day_last) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/year_month_weekday/hash)(C++26) | [`std::chrono::year_month_weekday`](https://cppreference.cn/w/cpp/chrono/year_month_weekday) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/year_month_weekday_last/hash)(C++26) | [`std::chrono::year_month_weekday_last`](https://cppreference.cn/w/cpp/chrono/year_month_weekday_last) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/zoned_time/hash)(C++26) | [`std::chrono::zoned_time`](https://cppreference.cn/w/cpp/chrono/zoned_time) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/chrono/leap_second/hash)(C++26) | [`std::chrono::leap_second`](https://cppreference.cn/w/cpp/chrono/leap_second) 的哈希支持  (类模板特化) |
| Forward declarations                                         |                                                              |
| 定义于头文件 `<functional>`                                  |                                                              |
| [ hash](https://cppreference.cn/w/cpp/utility/hash)(C++11)   | 哈希函数对象  (类模板)                                       |

### 格式化示例

```cpp
#include <iostream>
#include <chrono>
#include <format>

#if __cplusplus >= 202002L

int main() {
    using namespace std::chrono;
    
    auto now = system_clock::now();
    
    // 格式化持续时间
    auto duration = 123456789ns;
    std::cout << std::format("持续时间: {:%H:%M:%S}", duration) << std::endl;
    
    // 格式化时间点
    std::cout << std::format("当前时间: {:%Y-%m-%d %H:%M:%S}", now) << std::endl;
    
    // 格式化日历类型
    auto today = floor<days>(now);
    year_month_day ymd{today};
    std::cout << std::format("今天是: {:%Y年%m月%d日}", ymd) << std::endl;
    
    // 带时区的格式化
    auto tz = locate_zone("Asia/Shanghai");
    zoned_time shanghai_time{tz, now};
    std::cout << std::format("上海时间: {:%Y-%m-%d %H:%M:%S %Z}", shanghai_time) << std::endl;
    
    return 0;
}

#else

int main() {
    std::cout << "此示例需要 C++20 支持" << std::endl;
    return 0;
}

#endif
```

## 6. 综合示例

```cpp
#include <iostream>
#include <chrono>
#include <thread>
#include <vector>
#include <algorithm>

int main() {
    using namespace std::chrono;
    
    // 1. 测量代码执行时间
    auto start = high_resolution_clock::now();
    
    // 模拟一些工作
    std::vector<int> numbers(1000000);
    std::generate(numbers.begin(), numbers.end(), []() {
        return rand() % 1000;
    });
    std::sort(numbers.begin(), numbers.end());
    
    auto end = high_resolution_clock::now();
    auto elapsed = duration_cast<microseconds>(end - start);
    std::cout << "排序耗时: " << elapsed.count() << " 微秒" << std::endl;
    
    // 2. 创建定时器
    auto timeout = steady_clock::now() + seconds(5);
    std::cout << "程序将在5秒后超时..." << std::endl;
    
    while (steady_clock::now() < timeout) {
        std::this_thread::sleep_for(500ms);
        auto remaining = duration_cast<seconds>(timeout - steady_clock::now());
        std::cout << "剩余时间: " << remaining.count() << " 秒" << std::endl;
    }
    
    std::cout << "时间到!" << std::endl;
    
    // 3. 处理日期
    #if __cplusplus >= 202002L
    auto today = floor<days>(system_clock::now());
    auto ymd = year_month_day(today);
    
    // 计算下个月的同一天
    auto next_month = ymd.year() / ymd.month() / ymd.day() + months(1);
    
    if (next_month.ok()) {
        std::cout << "下个月的今天是: " 
                  << static_cast<unsigned>(next_month.day()) << "/"
                  << static_cast<unsigned>(next_month.month()) << "/"
                  << static_cast<int>(next_month.year()) << std::endl;
    } else {
        // 处理无效日期（如下个月没有这一天）
        auto last_day = year_month_day_last{next_month.year(), 
                                           month_day_last{next_month.month()}};
        std::cout << "下个月没有这一天，最后一天是: " 
                  << static_cast<unsigned>(last_day.day()) << std::endl;
    }
    #endif
    
    return 0;
}
```

## 总结

C++ `<chrono>` 库提供了强大而灵活的时间处理功能：

1. **持续时间 (Duration)**: 表示时间间隔，支持各种时间单位和算术运算
2. **时间点 (Time Point)**: 表示特定时间点，支持与持续时间的算术运算
3. **时钟 (Clocks)**: 提供不同精度和特性的时间来源
4. **日历 (Calendar) (C++20)**: 提供日期相关的类型和操作
5. **时区 (Time Zone) (C++20)**: 提供时区支持和转换功能
6. **格式化 (Formatting) (C++20)**: 提供灵活的时间格式化输出

这些功能使得C++能够处理各种时间相关的需求，从简单的计时到复杂的跨时区日期计算。